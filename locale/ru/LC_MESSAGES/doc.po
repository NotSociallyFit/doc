# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2018-08-13 12:53+0300\n"
"PO-Revision-Date: 2018-10-04 11:21+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"
"X-Generator: Poedit 1.8.12\n"

#: ../doc/1.7/book/admin/backups.rst:5
msgid "Backups"
msgstr "Резервное копирование"

#: ../doc/1.7/book/admin/backups.rst:7
msgid "Tarantool storage architecture is append-only: files are only appended to, and are never overwritten. Old files are removed by garbage collection after a checkpoint. You can configure the amount of past checkpoints preserved by garbage collection by configuring Tarantool's :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`. Backups can be taken at any time, with minimal overhead on database performance."
msgstr "Архитектура Tarantool-хранилища позволяет производить обновление только путем присоединения новых записей: сами файлы никогда не перезаписываются. Сборщик мусора удаляет старые файлы после определенной контрольной точки. В настройках :ref:`демона создания контрольных точек <book_cfg_checkpoint_daemon>` можно указать, какое количество предыдущих контрольных точек сборщик мусора должен оставить. Резервное копирование может проводиться в любое время с минимальной затратой ресурсов."

#: ../doc/1.7/book/admin/backups.rst:18
msgid "Hot backup (memtx)"
msgstr "Горячее резервирование (memtx)"

#: ../doc/1.7/book/admin/backups.rst:20
msgid "This is a special case when there are only in-memory tables."
msgstr "Это особый случай, когда все таблицы хранятся в памяти."

#: ../doc/1.7/book/admin/backups.rst:22
msgid "The last :ref:`snapshot file<index-box_persistence>` is a backup of the entire database; and the :ref:`WAL<internals-wal>` files that are made after the last snapshot are incremental backups. Therefore taking a backup is a matter of copying the snapshot and WAL files."
msgstr "Последний созданный Tarantool'ом :ref:`файл-снимок <index-box_persistence>` является резервной копией всей базы данных; а созданные следом :ref:`WAL-файлы <internals-wal>` являются инкрементными копиями. Поэтому процедура резервирования сводится к копированию последнего файла-снимка и следующих за ним WAL-файлов."

#: ../doc/1.7/book/admin/backups.rst:27
msgid "Use ``tar`` to make a (possibly compressed) copy of the latest .snap and .xlog files on the :ref:`memtx_dir <cfg_basic-memtx_dir>` and :ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr "С помощью ``tar`` создайте (зачастую сжатую) копию последнего .snap-файла и следующих за ним .xlog-файлов из директорий :ref:`memtx_dir <cfg_basic-memtx_dir>` и :ref:`wal_dir <cfg_basic-wal_dir>`."

#: ../doc/1.7/book/admin/backups.rst:31
msgid "If there is a security policy, encrypt the .tar file."
msgstr "Если того требуют правила безопасности, зашифруйте получившийся .tar-файл."

#: ../doc/1.7/book/admin/backups.rst:33
msgid "Copy the .tar file to a safe place."
msgstr "Скопируйте .tar-файл в надежное место."

#: ../doc/1.7/book/admin/backups.rst:35
msgid "Later, restoring the database is a matter of taking the .tar file and putting its contents back in the memtx_dir and wal_dir directories."
msgstr "В дальнейшем базу данных можно восстановить, разархивировав содержимое .tar-файла в директории ``memtx_dir`` и ``wal_dir``."

#: ../doc/1.7/book/admin/backups.rst:42
msgid "Hot backup (vinyl/memtx)"
msgstr "Горячее резервирование (vinyl/memtx)"

#: ../doc/1.7/book/admin/backups.rst:44
msgid "Vinyl stores its files in :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, and creates a folder for each database space. Dump and compaction processes are append-only and create new files. Old files are garbage collected after each checkpoint."
msgstr "Vinyl хранит свои файлы в :ref:`vinyl_dir <cfg_basic-vinyl_dir>` и создает для каждого спейса в базе данных отдельную поддиректорию. Создание дампов и слияние — это процессы, которые могут лишь добавлять записи, поэтому в результате создаются новые файлы. Старые же удаляются сборщиком мусора после каждой контрольной точки."

#: ../doc/1.7/book/admin/backups.rst:48
msgid "To take a mixed backup:"
msgstr "Для создания смешанной резервной копии:"

#: ../doc/1.7/book/admin/backups.rst:50
msgid "Issue ``box.backup.start()`` on the :ref:`administrative console <admin-security>`. This will suspend garbage collection till the next ``box.backup.stop()`` and will return a list of files to backup."
msgstr "Выполните команду `box.backup.start()`` в :ref:`административной консоли <admin-security>`. Эта команда приостановит сборку мусора до вызова ``box.backup.stop()`` и покажет список файлов для резервирования."

#: ../doc/1.7/book/admin/backups.rst:54
msgid "Copy the files from the list to a safe location. This will include memtx snapshot files, vinyl run and index files, at a state consistent with the last checkpoint."
msgstr "Скопируйте файлы из списка в надежное место. Это касается файлов-снимков memtx, выполняемых vinyl-файлов и индексных файлов, соответствующих последней контрольной точке."

#: ../doc/1.7/book/admin/backups.rst:58
msgid "Resume garbage collection with ``box.backup.stop()``."
msgstr "Возобновите сборку мусора с помощью команды ``box.backup.stop()``."

#: ../doc/1.7/book/admin/backups.rst:64
msgid "Continuous remote backup (memtx)"
msgstr "Непрерывное удаленное резервирование"

#: ../doc/1.7/book/admin/backups.rst:66
msgid "The :ref:`replication <replication>` feature is useful for backup as well as for load balancing."
msgstr ":ref:`Репликация <replication>` используется не только для резервирования, но и для выравнивания нагрузки."

#: ../doc/1.7/book/admin/backups.rst:69
msgid "Therefore taking a backup is a matter of ensuring that any given replica is up to date, and doing a cold backup on it. Since all the other replicas continue to operate, this is not a cold backup from the end user’s point of view. This could be done on a regular basis, with a ``cron`` job or with a Tarantool fiber."
msgstr "Поэтому процесс создания резервной копии сводится к обновлению (при необходимости) одной из реплик с последующим холодным резервированием. Так как все остальные реплики продолжают функционировать, с точки зрения конечного пользователя, этот процесс не является холодным резервированием. Такое резервирование можно выполнять регулярно с помощью  планировщика ``cron`` или файбера Tarantool'а."

#: ../doc/1.7/book/admin/backups.rst:78
msgid "Continuous backup (memtx)"
msgstr "Непрерывное резервирование"

#: ../doc/1.7/book/admin/backups.rst:80
msgid "The logged changes done since the last cold backup must be secured, while the system is running."
msgstr "По ходу работы системы необходимо сохранять записи об изменениях, внесенных со времени последнего холодного резервирования."

#: ../doc/1.7/book/admin/backups.rst:83
msgid "For this purpose, you need a file copy utility that will do the copying remotely and continuously, copying only the parts of a write ahead log file that are changing. One such utility is `rsync <https://en.wikipedia.org/wiki/Rsync>`_."
msgstr "Для этого нужна специальная утилита для копирования файлов (например, `rsync <https://en.wikipedia.org/wiki/rsync>`_), которая позволит удаленно и на постоянной основе копировать только изменившиеся части WAL-файла, а не весь файл целиком."

#: ../doc/1.7/book/admin/backups.rst:88
msgid "Alternatively, you need an ordinary file copy utility, but there should be frequent production of new snapshot files or new WAL files as changes occur, so that only the new files need to be copied."
msgstr "Можно взять и обычную утилиту для копирования целых файлов, но тогда придется создавать файлы-снимки и WAL-файлы на каждое изменение, чтобы нужно было копировать только новые файлы."

#: ../doc/1.7/book/admin/bug_reports.rst:5
msgid "Bug reports"
msgstr "Сообщения об ошибках"

#: ../doc/1.7/book/admin/bug_reports.rst:7
msgid "If you found a bug in Tarantool, you’re doing us a favor by taking the time to tell us about it."
msgstr "Если вы нашли ошибку в Tarantool, вы окажете нам услугу, сообщив о ней."

#: ../doc/1.7/book/admin/bug_reports.rst:10
msgid "Please create an issue at Tarantool repository at GitHub. We encourage you to include the following information:"
msgstr "Пожалуйста, откройте тикет в репозитории Tarantool на GitHub. Рекомендуем  включить следующую информацию:"

#: ../doc/1.7/book/admin/bug_reports.rst:13
msgid "Steps needed to reproduce the bug, and an explanation why this differs from the expected behavior according to our manual. Please provide specific unique information. For example, instead of \"I can’t get certain information\", say \"box.space.x:delete() didn’t report what was deleted\"."
msgstr "Шаги для воспроизведения ошибки с объяснением того, как ошибочное поведение отличается от описанного в документации ожидаемого поведения. Пожалуйста, указывайте как можно более конкретную информацию. Например, вместо \"Я не могу получить определенную информацию\" лучше написать \"box.space.x:delete() не указывает, что именно было удалено\"."

#: ../doc/1.7/book/admin/bug_reports.rst:18
msgid "Your operating system name and version, the Tarantool name and version, and any unusual details about your machine and its configuration."
msgstr "Название и версию вашей операционной системы, название и версию Tarantool  и любую информацию об особенностях вашей машины и ее конфигурации."

#: ../doc/1.7/book/admin/bug_reports.rst:21
msgid "Related files like a :ref:`stack trace <admin-stack_traces>` or a Tarantool :ref:`log file <admin-logs>`."
msgstr "Сопутствующие файлы — такие как :ref:`трассировка стека <admin-stack_traces>` или :ref:`файл журнала <admin-logs>` Tarantool'а."

#: ../doc/1.7/book/admin/bug_reports.rst:24
msgid "If this is a feature request or if it affects a special category of users, be sure to mention that."
msgstr "Если это запрос новой функции или это затрагивает определенную группу пользователей, не забудьте это указать."

#: ../doc/1.7/book/admin/bug_reports.rst:27
msgid "Usually within one or two workdays a Tarantool team member will write an acknowledgment, or some questions, or suggestions for a workaround."
msgstr "Обычно член команды Tarantool отвечает в течение одного-двух рабочих дней, чтобы подтвердить, что тикет взят в работу, задать уточняющие вопросы или предложить альтернативное решение описанной проблемы."

#: ../doc/1.7/book/admin/daemon_supervision.rst:5
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../doc/1.7/book/admin/daemon_supervision.rst:11
msgid "Server signals"
msgstr "Сигналы от сервера"

#: ../doc/1.7/book/admin/daemon_supervision.rst:13
msgid "Tarantool processes these signals during the event loop in the transaction processor thread:"
msgstr "Во время событийного цикла в потоке обработки транзакций Tarantool обрабатывает следующие сигналы:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:22
msgid "Signal"
msgstr "Сигнал"

#: ../doc/1.7/book/admin/daemon_supervision.rst:22
#: ../doc/1.7/book/box/box_schema.rst:129 ../doc/1.7/book/box/box_space.rst:265
#: ../doc/1.7/book/box/data_model.rst:851
msgid "Effect"
msgstr "Эффект"

#: ../doc/1.7/book/admin/daemon_supervision.rst:24
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../doc/1.7/book/admin/daemon_supervision.rst:24
msgid "May cause log file rotation. See the :ref:`example <cfg_logging-logging_example>` in reference on Tarantool logging parameters."
msgstr "Может привести к ротации журналов, см. :ref:`пример <cfg_logging-logging_example>` в справочнике по параметрам журналирования Tarantool'а."

#: ../doc/1.7/book/admin/daemon_supervision.rst:28
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../doc/1.7/book/admin/daemon_supervision.rst:28
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr "Может привести к созданию снимка состояния базы данных, см. описание функции :ref:`box.snapshot <box-snapshot>`."

#: ../doc/1.7/book/admin/daemon_supervision.rst:31
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../doc/1.7/book/admin/daemon_supervision.rst:31
msgid "May cause graceful shutdown (information will be saved first)."
msgstr "Может привести к корректному завершению работы (с предварительным сохранением всех данных)."

#: ../doc/1.7/book/admin/daemon_supervision.rst:34
msgid "SIGINT (also known as keyboard interrupt)"
msgstr "SIGINT (или \"прерывание от клавиатуры\")"

#: ../doc/1.7/book/admin/daemon_supervision.rst:34
msgid "May cause graceful shutdown."
msgstr "Может привести к корректному завершению работы."

#: ../doc/1.7/book/admin/daemon_supervision.rst:38
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../doc/1.7/book/admin/daemon_supervision.rst:38
msgid "Causes an immediate shutdown."
msgstr "Приводит к аварийному завершению работы."

#: ../doc/1.7/book/admin/daemon_supervision.rst:41
msgid "Other signals will result in behavior defined by the operating system. Signals other than SIGKILL may be ignored, especially if Tarantool is executing a long-running procedure which prevents return to the event loop in the transaction processor thread."
msgstr "Остальные сигналы приводят к заданному операционной системой поведению. Все сигналы, за исключением SIGKILL, можно игнорировать, особенно если Tarantool выполняет длительную процедуру и не может вернуться в событийный цикл в потоке обработки транзакций."

#: ../doc/1.7/book/admin/daemon_supervision.rst:50
msgid "Automatic instance restart"
msgstr "Автоматическая перезагрузка экземпляра"

#: ../doc/1.7/book/admin/daemon_supervision.rst:52
msgid "On ``systemd``-enabled platforms, ``systemd`` automatically restarts all Tarantool instances in case of failure. To demonstrate it, let’s try to destroy an instance:"
msgstr "На платформах, где доступна утилита ``systemd``, ``systemd`` автоматически перезагружает все экземпляры Tarantool'а при сбое. Чтобы продемонстрировать это, отключим один из экземпляров:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:56
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed connection"
msgstr ""
"$ systemctl status tarantool@my_app|grep PID\n"
"        Main PID: 5885 (tarantool)\n"
"        $ tarantoolctl enter my_app\n"
"        /bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available \n"
"        /bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"        /bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"        unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"        /bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed connection"

#: ../doc/1.7/book/admin/daemon_supervision.rst:67
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr "А теперь убедимся, что ``systemd`` перезапустила его:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:69
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@my_app|grep PID\n"
"        Main PID: 5914 (tarantool)"

#: ../doc/1.7/book/admin/daemon_supervision.rst:74
msgid "Finally, let’s check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:76
msgid ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database Server."
msgstr ""
"$ journalctl -u tarantool@my_app -n 8\n"
"        -- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 MSK. --\n"
"        Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Unit entered failed state.\n"
"        Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Failed with result 'exit-code'.\n"
"        Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Service hold-off time over, scheduling restart. \n"
"        Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"        Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"        Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"        Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Starting instance...\n"
"        Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database Server."

#: ../doc/1.7/book/admin/daemon_supervision.rst:93
msgid "Core dumps"
msgstr "Создание дампов памяти"

#: ../doc/1.7/book/admin/daemon_supervision.rst:95
msgid "Tarantool makes a core dump if it receives any of the following signals: SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool crashes."
msgstr "Tarantool создает дамп памяти при получении одного из следующих сигналов:  SIGSEGV, SIGFPE, SIGABRT или SIGQUIT. При сбое Tarantool'а дамп создается автоматически."

#: ../doc/1.7/book/admin/daemon_supervision.rst:98
msgid "On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves core dumps and stack traces in case of a crash. Here is a general \"how to\" for how to enable core dumps on a Unix system:"
msgstr "На платформах, где доступна утилита ``systemd``, ``coredumpctl`` автоматически сохраняет дампы памяти и трассировку стека при аварийном завершении Tarantool-сервера. Вот как включить создание дампов памяти в Unix-системе:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:102
msgid "Ensure session limits are configured to enable core dumps, i.e. say ``ulimit -c unlimited``. Check  \"man 5 core\" for other reasons why a core dump may not be produced."
msgstr "Убедитесь, что лимиты для сессии установлены таким образом, чтобы можно было создавать дампы памяти, - выполните команду ``ulimit -c unlimited``.  Также проверьте \"man 5 core\" на другие причины, по которым дамп памяти  может не создаваться."

#: ../doc/1.7/book/admin/daemon_supervision.rst:106
msgid "Set a directory for writing core dumps to, and make sure that the directory is writable. On Linux, the directory path is set in a kernel parameter configurable via ``/proc/sys/kernel/core_pattern``."
msgstr "Создайте директорию для записи дампов памяти и убедитесь, что в эту директорию действительно можно производить запись. На Linux путь до директории задается в параметре ядра, который настраивается через ``/proc/sys/kernel/core_pattern``."

#: ../doc/1.7/book/admin/daemon_supervision.rst:110
msgid "Make sure that core dumps include stack trace information. If you use a binary Tarantool distribution, this is automatic. If you build Tarantool from source, you will not get detailed information if you pass ``-DCMAKE_BUILD_TYPE=Release`` to CMake."
msgstr "Убедитесь, что дампы памяти включают трассировку стека. При использовании  бинарного дистрибутива Tarantool'а эта информация включается автоматически. При сборке Tarantool'а из исходников, если передать CMake флаг ``-DCMAKE_BUILD_TYPE=Release``, вы не получите подробной информации."

#: ../doc/1.7/book/admin/daemon_supervision.rst:115
msgid "To simulate a crash, you can execute an illegal command against a Tarantool instance:"
msgstr "Для симуляции сбоя можно попытаться выполнить нелегальную команду на работающем экземпляре Tarantool'а:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:118
msgid ""
"$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', 0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed connection"
msgstr ""
"$ # !!! пожалуйста, никогда не делайте этого на боевом сервере !!!\n"
"        $ tarantoolctl enter my_app\n"
"        unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', 0)[0] = 48\n"
"        /bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed connection"

#: ../doc/1.7/book/admin/daemon_supervision.rst:125
msgid "Alternatively, if you know the process ID of the instance (here we refer to it as $PID), you can abort a Tarantool instance by running ``gdb`` debugger:"
msgstr "Есть другой способ: если вы знаете PID экземпляра ($PID в нашем примере),  можно остановить этот экземпляр, запустив отладчик ``gdb``:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:128
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr "$ gdb -batch -ex \"generate-core-file\" -p $PID"

#: ../doc/1.7/book/admin/daemon_supervision.rst:132
msgid "or manually sending a SIGABRT signal:"
msgstr "или послав вручную сигнал SIGABRT:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:134
msgid "$ kill -SIGABRT $PID"
msgstr "$ kill -SIGABRT $PID"

#: ../doc/1.7/book/admin/daemon_supervision.rst:140
msgid "To find out the process id of the instance ($PID), you can:"
msgstr "Чтобы узнать PID экземпляра, можно:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:142
msgid "look it up in the instance's :ref:`box.info.pid <box_introspection-box_info>`,"
msgstr "посмотреть его с помощью :ref:`box.info.pid <box_introspection-box_info>`,"

#: ../doc/1.7/book/admin/daemon_supervision.rst:144
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr "использовать команду ``ps -A | grep tarantool``, или"

#: ../doc/1.7/book/admin/daemon_supervision.rst:146
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr "выполнить ``systemctl status tarantool@my_app|grep PID``."

#: ../doc/1.7/book/admin/daemon_supervision.rst:148
msgid "On a ``systemd-enabled`` system, to see the latest crashes of the Tarantool daemon, say:"
msgstr "Чтобы посмотреть на последние сбои Tarantool-демона на платформах, где доступна утилита ``systemd``, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:151
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"        MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"        Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"        Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../doc/1.7/book/admin/daemon_supervision.rst:158
msgid "To save a core dump into a file, say:"
msgstr "Чтобы сохранить дамп памяти в файл, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:160
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr "$ coredumpctl -o filename.core info <pid>"

#: ../doc/1.7/book/admin/daemon_supervision.rst:168
msgid "Stack traces"
msgstr "Трассировка стека"

#: ../doc/1.7/book/admin/daemon_supervision.rst:170
msgid "Since Tarantool stores tuples in memory, core files may be large. For investigation, you normally don't need the whole file, but only a \"stack trace\" or \"backtrace\"."
msgstr "Так как Tarantool хранит кортежи в памяти, файлы с дампами памяти могут быть довольно большими. Чтобы найти проблему, обычно целый файл не нужен - достаточно только \"трассировки стека\" или \"обратной трассировки\"."

#: ../doc/1.7/book/admin/daemon_supervision.rst:174
msgid "To save a stack trace into a file, say:"
msgstr "Чтобы сохранить трассировку стека в файл, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:176
msgid "$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" --batch -c core> /tmp/tarantool_trace.txt"
msgstr "$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" --batch -c core> /tmp/tarantool_trace.txt"

#: ../doc/1.7/book/admin/daemon_supervision.rst:180
#: ../doc/1.7/book/admin/instance_config.rst:116
#: ../doc/1.7/book/replication/repl_bootstrap.rst:39
#: ../doc/1.7/dev_guide/developer_guidelines.rst:160
#: ../doc/1.7/reference/tarantoolctl.rst:24
msgid "where:"
msgstr "где:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:182
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr "\"tarantool\" - это путь до исполняемого файла Tarantool'а,"

#: ../doc/1.7/book/admin/daemon_supervision.rst:183
msgid "\"core\" is the path to the core file, and"
msgstr "\"core\" - это путь до файла с дампом памяти, и"

#: ../doc/1.7/book/admin/daemon_supervision.rst:184
msgid "\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the stack trace."
msgstr "\"/tmp/tarantool_trace.txt\" - это пример пути до файла, в который сохраняется трассировка стека."

#: ../doc/1.7/book/admin/daemon_supervision.rst:188
msgid "Occasionally, you may find that the trace file contains output without debug symbols – the lines will contain ”??” instead of names. If this happens, check the instructions on these Tarantool wiki pages: `How to debug core dump of stripped tarantool <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-stripped-tarantool>`_ and `How to debug core from different OS <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-different-OS>`_."
msgstr "Иногда может оказаться, что файл с трассировкой стека не содержит отладочных символов - в таких строках вместо имени будет стоять ”??”. Если это произошло, ознакомьтесь с инструкциями на этих двух wiki-страницах Tarantool'а: `How to debug core dump of stripped tarantool  <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of- stripped-tarantool>`_ и `How to debug core from different OS <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from- different-OS>`_."

#: ../doc/1.7/book/admin/daemon_supervision.rst:195
msgid "To see the stack trace and other useful information in console, say:"
msgstr "Чтобы получить трассировку стека и прочую полезную информацию в консоли, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:197
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c _ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"                  PID: 21035 (tarantool)\n"
"                  UID: 995 (tarantool)\n"
"                  GID: 992 (tarantool)\n"
"               Signal: 6 (ABRT)\n"
"            Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
"         Command Line: tarantool my_app.lua <running>\n"
"           Executable: /usr/bin/tarantool\n"
"        Control Group: /system.slice/system- tarantool.slice/tarantool@my_app.service\n"
"                 Unit: tarantool@my_app.service\n"
"                Slice: system-tarantool.slice\n"
"              Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"           Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"             Hostname: localhost.localdomain\n"
"              Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"        \n"
"                       Stack trace of thread 21035:\n"
"                       #0  0x00007f84993aa618 raise (libc.so.6)\n"
"                       #1  0x00007f84993ac21a abort (libc.so.6)\n"
"                       #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"                       #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"                       #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"                       #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"                       #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"                       #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"                       #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"                       #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"                       #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"                       #11 0x0000560d0a9e8d0c _ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"                       #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"                       #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"                       ..."

#: ../doc/1.7/book/admin/daemon_supervision.rst:236
msgid "Debugger"
msgstr "Отладчик"

#: ../doc/1.7/book/admin/daemon_supervision.rst:238
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr "Для запуска отладчика ``gdb``, выполните команду:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:240
msgid "$ coredumpctl gdb <pid>"
msgstr "$ coredumpctl gdb <pid>"

#: ../doc/1.7/book/admin/daemon_supervision.rst:244
msgid "It is highly recommended to install ``tarantool-debuginfo`` package to improve ``gdb`` experience, for example:"
msgstr "Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы сделать отладку средствами ``gdb`` более эффективной. Например:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:247
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../doc/1.7/book/admin/daemon_supervision.rst:251
msgid "``gdb`` also provides information about the debuginfo packages you need to install:"
msgstr "С помощью ``gdb`` можно узнать, какие еще ``debuginfo``-пакеты нужно установить:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:254
msgid ""
"$ gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ gdb -p <pid>\n"
"      ...\n"
"      Missing separate debuginfos, use: dnf debuginfo-install\n"
"      glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"      libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"      libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"      libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"      openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../doc/1.7/book/admin/daemon_supervision.rst:265
msgid "Symbolic names are present in stack traces even if you don’t have ``tarantool-debuginfo`` package installed."
msgstr "В трассировке стека присутствуют символические имена, даже если у вас не установлен пакет ``tarantool-debuginfo``."

#: ../doc/1.7/book/admin/disaster_recovery.rst:5
msgid "Disaster recovery"
msgstr "Аварийное восстановление"

#: ../doc/1.7/book/admin/disaster_recovery.rst:7
msgid "The minimal fault-tolerant Tarantool configuration would be a :ref:`replication cluster<replication-topologies>` that includes a master and a replica, or two masters."
msgstr "Минимальная отказоустойчивая конфигурация Tarantool'а - это :ref:`репликационный кластер <replication-topologies>`, содержащий мастер и реплику или два мастера."

#: ../doc/1.7/book/admin/disaster_recovery.rst:11
msgid "The basic recommendation is to configure all Tarantool instances in a cluster to create :ref:`snapshot files <index-box_persistence>` at a regular basis."
msgstr "Основная рекомендация - настраивать все экземпляры Tarantool'а в кластере  таким образом, чтобы они регулярно создавали :ref:`файлы-снимки <index-box_persistence>`."

#: ../doc/1.7/book/admin/disaster_recovery.rst:14
msgid "Here follow action plans for typical crash scenarios."
msgstr "Ниже дано несколько инструкций для типовых аварийных сценариев."

#: ../doc/1.7/book/admin/disaster_recovery.rst:20
msgid "Master-replica"
msgstr "Мастер-реплика"

#: ../doc/1.7/book/admin/disaster_recovery.rst:22
msgid "Configuration: One master and one replica."
msgstr "Конфигурация: один мастер и одна реплика."

#: ../doc/1.7/book/admin/disaster_recovery.rst:24
msgid "Problem: The master has crashed."
msgstr "Проблема: мастер вышел из строя."

#: ../doc/1.7/book/admin/disaster_recovery.rst:26
#: ../doc/1.7/book/admin/disaster_recovery.rst:93
msgid "Your actions:"
msgstr "План действий:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:28
msgid "Ensure the master is stopped for good. For example, log in to the master machine and use ``systemctl stop tarantool@<instance_name>``."
msgstr "Убедитесь, что мастер полностью остановлен. Например, подключитесь к мастеру и используйте команду ``systemctl stop tarantool@<имя_экземпляра>``."

#: ../doc/1.7/book/admin/disaster_recovery.rst:31
msgid "Switch the replica to master mode by setting :ref:`box.cfg.read_only <cfg_basic-read_only>` parameter to *false* and let the load be handled by the replica (effective master)."
msgstr "Переключите реплику в режим мастера, установив параметру :ref:`box.cfg.read_only <cfg_basic-read_only>` значение *false*. Теперь вся нагрузка пойдет только на реплику (по сути ставшую мастером)."

#: ../doc/1.7/book/admin/disaster_recovery.rst:35
msgid "Set up a replacement for the crashed master on a spare host, with :ref:`replication <cfg_replication-replication>` parameter set to replica (effective master), so it begins to catch up with the new master’s state. The new instance should have :ref:`box.cfg.read_only <cfg_basic-read_only>` parameter set to *true*."
msgstr "Настройте на свободной машине замену вышедшему из строя мастеру, установив параметру :ref:`replication <cfg_replication-replication>` в качестве значения URI реплики (которая в данный момент выполняет роль мастера), чтобы новая реплика начала синхронизироваться с текущим мастером. Значение параметра :ref:`box.cfg.read_only <cfg_basic-read_only>` в новом экземпляре должно быть установлено на *true*."

#: ../doc/1.7/book/admin/disaster_recovery.rst:41
msgid "You lose the few transactions in the master :ref:`write ahead log file <index-box_persistence>`, which it may have not transferred to the replica before crash. If you were able to salvage the master .xlog file, you may be able to recover these. In order to do it:"
msgstr "Все немногочисленные транзакции в :ref:`WAL-файле <index-box_persistence>` мастера, которые он не успел передать реплике до выхода  из строя, будут потеряны. Однако если удастся получить .xlog-файл мастера, их можно будет восстановить. Для этого:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:46
msgid "Find out the position of the crashed master, as reflected on the new master."
msgstr "Узнайте позицию вышедшего из строя мастера -- эта информация доступна из нового мастера."

#: ../doc/1.7/book/admin/disaster_recovery.rst:48
msgid "Find out instance UUID from the crashed master :ref:`xlog <internals-wal>`:"
msgstr "Посмотрите UUID экземпляра в .:ref:`xlog-файле <internals-wal>` вышедшего  из строя мастера:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:50
msgid ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""
"$ head -5 *.xlog | grep Instance\n"
"        Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"

#: ../doc/1.7/book/admin/disaster_recovery.rst:55
msgid "On the new master, use the UUID to find the position:"
msgstr "Используйте этот UUID на новом мастере для поиска позиции:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:57
msgid ""
"tarantool> box.info.vclock[box.space._cluster.index.uuid:select{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""
"tarantool> box.info.vclock[box.space._cluster.index.uuid:select{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"      ---\n"
"      - 23425\n"
"      <...>"

#: ../doc/1.7/book/admin/disaster_recovery.rst:64
msgid "Play the records from the crashed .xlog to the new master, starting from the new master position:"
msgstr "Запишите транзакции из .xlog-файла вышедшего из строя мастера в новый мастер, начиная с позиции нового мастера:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:67
msgid "Issue this request locally at the new master's machine to find out instance ID of the new master:"
msgstr "Локально выполните эту команду на новом мастере, чтобы узнать его ID экземпляра:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:70
#: ../doc/1.7/book/replication/repl_architecture.rst:84
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""
"tarantool> box.space._cluster:select{}\n"
"        ---\n"
"        - - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"        ..."

#: ../doc/1.7/book/admin/disaster_recovery.rst:77
msgid "Play the records to the new master:"
msgstr "Запишите транзакции в новый мастер:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:79
msgid "$ tarantoolctl <new_master_uri> <xlog_file> play --from-lsn 23425 --replica 1"
msgstr "$ tarantoolctl <uri_нового_мастера> <xlog_файл> play --from-lsn 23425 --replica 1"

#: ../doc/1.7/book/admin/disaster_recovery.rst:87
msgid "Master-master"
msgstr "Мастер-мастер"

#: ../doc/1.7/book/admin/disaster_recovery.rst:89
msgid "Configuration: Two masters."
msgstr "Конфигурация: два мастера."

#: ../doc/1.7/book/admin/disaster_recovery.rst:91
msgid "Problem: Master#1 has crashed."
msgstr "Проблема: мастер #1 вышел из строя."

#: ../doc/1.7/book/admin/disaster_recovery.rst:95
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr "Пусть вся нагрузка идет только на мастер #2 (действующий мастер)."

#: ../doc/1.7/book/admin/disaster_recovery.rst:97
msgid "2. Follow the same steps as in the :ref:`master-replica <admin-disaster_recovery-master_replica>` recovery scenario to create a new master and salvage lost data."
msgstr "2. Создайте новый мастер и восстановите данные, проделав те же шаги, что и в сценарии для конфигурации :ref:`мастер-реплика <admin-disaster_recovery-master_replica>`."

#: ../doc/1.7/book/admin/disaster_recovery.rst:105
msgid "Data loss"
msgstr "Потеря данных"

#: ../doc/1.7/book/admin/disaster_recovery.rst:107
msgid "Configuration: Master-master or master-replica."
msgstr "Конфигурация: мастер-мастер или мастер-реплика."

#: ../doc/1.7/book/admin/disaster_recovery.rst:109
msgid "Problem: Data was deleted at one master and this data loss was propagated to the other node (master or replica)."
msgstr "Проблема: данные были удалены на одном мастере, а затем эти изменения реплицировались на другом узле (мастере или реплике)."

#: ../doc/1.7/book/admin/disaster_recovery.rst:112
msgid "The following steps are applicable only to data in memtx storage engine. Your actions:"
msgstr "Эта инструкция применима только для данных, хранящихся на движке memtx. План действий:"

#: ../doc/1.7/book/admin/disaster_recovery.rst:115
msgid "Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable checkpointing with ``box.backup.start()``. Disabling the checkpointing is necessary to prevent automatic garbage collection of older checkpoints."
msgstr "Переключите все узлы в :ref:`режим read-only <cfg_basic-read_only>` и отключите командой ``box.backup.begin()`` создание контрольных точек. Последнее действие необходимо, чтобы сборщик мусора автоматически не удалил более старые контрольные точки."

#: ../doc/1.7/book/admin/disaster_recovery.rst:119
msgid "Get the latest valid :ref:`.snap file <internals-snapshot>` and use ``tarantoolctl cat`` command to calculate at which lsn the data loss occurred."
msgstr "Возьмите последний корректный :ref:`.snap-файл <internals-snapshot>` и, используя команду ``tarantoolctl cat``, выясните, на каком именно lsn произошла потеря данных."

#: ../doc/1.7/book/admin/disaster_recovery.rst:122
msgid "Start a new instance (instance#1) and use ``tarantoolctl play`` command to play to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr "Запустите новый экземпляр (экземпляр #1) и с помощью команды ``tarantoolctl play`` скопируйте в него содержимое .snap/.xlog-файлов вплоть до вычисленного lsn."

#: ../doc/1.7/book/admin/disaster_recovery.rst:125
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr "Настройте новую реплику с помощью восстановленного мастера (экземпляра #1)."

#: ../doc/1.7/book/admin/index.rst:5
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../doc/1.7/book/admin/index.rst:7
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr "Tarantool устроен таким образом, что возможно запустить несколько экземпляров программы на одном компьютере."

#: ../doc/1.7/book/admin/index.rst:9
msgid "Here we show how to administer Tarantool instances using any of the following utilities:"
msgstr "Здесь мы показываем, как администрировать экземпляры Tarantool’а с помощью любой из следующих утилит:"

#: ../doc/1.7/book/admin/index.rst:12
msgid "``systemd`` native utilities, or"
msgstr "встроенные утилиты ``systemd`` или"

#: ../doc/1.7/book/admin/index.rst:13
msgid ":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as part of Tarantool distribution."
msgstr ":ref:`tarantoolctl <tarantoolctl>`, утилита, поставляемая и устанавливаемая вместе с дистрибутивом Tarantool’а."

#: ../doc/1.7/book/admin/index.rst:18
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr "В отличие от остальной части руководства, в этой главе мы используем общесистемные пути."

#: ../doc/1.7/book/admin/index.rst:19
msgid "Console examples here are for Fedora."
msgstr "Здесь мы приводим примеры консольного вывода для Fedora."

#: ../doc/1.7/book/admin/index.rst:21 ../doc/1.7/book/replication/index.rst:11
msgid "This chapter includes the following sections:"
msgstr "Эта глава включает в себя следующие разделы:"

#: ../doc/1.7/book/admin/instance_config.rst:5
msgid "Instance configuration"
msgstr "Настройка экземпляров Tarantool’а"

#: ../doc/1.7/book/admin/instance_config.rst:7
msgid "For each Tarantool instance, you need two files:"
msgstr "Для каждого экземпляра Tarantool’а понадобится два файла:"

#: ../doc/1.7/book/admin/instance_config.rst:9
msgid "[Optional] An :ref:`application file <app_server-launching_app>` with instance-specific logic. Put this file into the ``/usr/share/tarantool/`` directory."
msgstr "[Необязательный] :ref:`Файл приложения <app_server-launching_app>`, содержащий логику данного экземпляра. Поместите его в папку ``/usr/share/tarantool/``."

#: ../doc/1.7/book/admin/instance_config.rst:13
msgid "For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as a :ref:`Lua module <app_server-modules>` that bootstraps the database and exports ``start()`` function for API calls):"
msgstr "Например, ``/usr/share/tarantool/my_app.lua`` (здесь мы реализуем его как  :ref:`Lua-модуль <app_server-modules>`, который запускает базу данных и экспортирует функцию ``start()`` для API -вызовов):"

#: ../doc/1.7/book/admin/instance_config.rst:17
msgid ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""
"local function start()\n"
"           box.schema.space.create(\"somedata\")\n"
"           box.space.somedata:create_index(\"primary\")\n"
"           <...>\n"
"       end\n"
"       \n"
"       return {\n"
"         start = start;\n"
"       }"

#: ../doc/1.7/book/admin/instance_config.rst:29
msgid "An :ref:`instance file <admin-instance_file>` with instance-specific initialization logic and parameters. Put this file, or a symlink to it, into the **instance directory** (see :ref:`instance_dir <admin-instance_dir>` parameter in ``tarantoolctl`` configuration file)."
msgstr ":ref:`Файл экземпляра <admin-instance_file>`, содержащий логику и параметры инициализации данного экземпляра. Поместите этот файл или символьную ссылку на него в **директорию экземпляра** (см. параметр :ref:`instance_dir <admin-instance_dir>` в конфигурационном файле ``tarantoolctl``)."

#: ../doc/1.7/book/admin/instance_config.rst:35
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we load ``my_app.lua`` module and make a call to ``start()`` function from that module):"
msgstr "Например, ``/etc/tarantool/instances.enabled/my_app.lua`` (здесь мы загружаем модуль ``my_app.lua`` и вызываем из него функцию ``start()``):"

#: ../doc/1.7/book/admin/instance_config.rst:39
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        box.cfg {\n"
"            listen = 3301;\n"
"        }\n"
"        \n"
"        -- загрузить модуль my_app и вызвать функцию start()\n"
"        -- некоторые опции приложения под контролем сисадминов\n"
"        local m = require('my_app').star{...}.})"

#: ../doc/1.7/book/admin/instance_config.rst:55
msgid "Instance file"
msgstr "Файл экземпляра"

#: ../doc/1.7/book/admin/instance_config.rst:57
msgid "After this short introduction, you may wonder what an instance file is, what it is for, and how ``tarantoolctl`` uses it. After all, Tarantool is an application server, so why not start the application stored in ``/usr/share/tarantool`` directly?"
msgstr "После столь краткого предисловия может возникнуть вопрос: что из себя представляет файл экземпляра, для чего он нужен и как ``tarantoolctl`` использует его? Если Tarantool -- это сервер приложений, так почему бы не запускать хранящееся в ``/usr/share/tarantool`` приложение напрямую?"

#: ../doc/1.7/book/admin/instance_config.rst:62
msgid "A typical Tarantool application is not a script, but a daemon running in background mode and processing requests, usually sent to it over a TCP/IP socket. This daemon needs to be started automatically when the operating system starts, and managed with the operating system standard tools for service management -- such as ``systemd`` or ``init.d``. To serve this very purpose, we created **instance files**."
msgstr "Типичное приложение для Tarantool -- это не скрипт, а демон, запущенный в фоновом режиме и обрабатывающий запросы, которые, как правило, посылаются  через TCP/IP-сокет. Необходимо запускать этот демон со стартом операционной системы и управлять им с помощью стандартных средств операционной системы для управления сервисами — таких как ``systemd`` или ``init.d``. С этой целью и были созданы **файлы экземпляра**."

#: ../doc/1.7/book/admin/instance_config.rst:69
msgid "You can have more than one instance file. For example, a single application in ``/usr/share/tarantool`` can run in multiple instances, each of them having its own instance file. Or you can have multiple applications in ``/usr/share/tarantool`` -- again, each of them having its own instance file."
msgstr "Файлов экземпляра может быть больше одного. Например, одно и то же приложение в ``/usr/share/tarantool`` может быть запущено на нескольких экземплярах Tarantool'а, у каждого из которых есть свой файл экземпляра. Или в ``/usr/share/tarantool`` может быть несколько приложений, и на каждое из них будет опять же приходиться свой файл экземпляра."

#: ../doc/1.7/book/admin/instance_config.rst:74
msgid "An instance file is typically created by a system administrator. An application file is often provided by a developer, in a Lua rock or an rpm/deb package."
msgstr "Обычно файл экземпляра создает системный администратор, а файл приложения  предоставляет разработчик в Lua-модуле или rpm/deb-пакете."

#: ../doc/1.7/book/admin/instance_config.rst:77
msgid "An instance file is designed to not differ in any way from a Lua application. It must, however, configure the database, i.e. contain a call to :ref:`box.cfg{} <box_introspection-box_cfg>` somewhere in it, because it’s the only way to turn a Tarantool script into a background process, and ``tarantoolctl`` is a tool to manage background processes. Other than that, an instance file may contain arbitrary Lua code, and, in theory, even include the entire application business logic in it. We, however, do not recommend this, since it clutters the instance file and leads to unnecessary copy-paste when you need to run multiple instances of an application."
msgstr "По своему устройству файл экземпляра ничем не отличается от Lua-приложения. Однако с его помощью должна настраиваться база данных, поэтому в нем должен содержаться вызов :ref:`box.cfg{} <box_introspection-box_cfg>`, потому что это единственный способ превратить Tarantool-скрипт в фоновый процесс, а ``tarantoolctl`` -- это инструмент для управления фоновыми процессами. За исключением этого вызова, файл экземпляра может содержать произвольный код на Lua и, теоретически, даже всю бизнес-логику приложения. Однако мы не рекомендуем  хранить весь код в файле экземпляра, потому что это приводит как к замусориванию самого файла, так и к ненужному копированию кода при необходимости запустить несколько экземпляров приложения."

#: ../doc/1.7/book/admin/instance_config.rst:91
msgid "`tarantoolctl` configuration file"
msgstr "Конфигурационный файл `tarantoolctl`"

#: ../doc/1.7/book/admin/instance_config.rst:93
msgid "While instance files contain instance configuration, ``tarantoolctl`` configuration file contains the configuration that ``tarantoolctl`` uses to override instance configuration. In other words, it contains system-wide configuration defaults."
msgstr "Файлы экземпляра содержат конфигурацию экземпляра, тогда как конфигурационный файл ``tarantoolctl`` содержит конфигурацию, которую ``tarantoolctl`` использует, чтобы переопределять конфигурацию экземпляров. Другими словами, он содержит общесистемную конфигурацию по умолчанию."

#: ../doc/1.7/book/admin/instance_config.rst:98
msgid "Most of the parameters are similar to those used by :ref:`box.cfg{} <box_introspection-box_cfg>`. Here are the default settings (installed to ``/etc/default/tarantool`` or ``/etc/sysconfig/tarantool`` as part of Tarantool distribution -- see OS-specific default paths in :ref:`Notes for operating systems <admin-os_notes>`):"
msgstr "Большинство параметров схожи с теми, которые используются в :ref:`box.cfg{} <box_introspection-box_cfg>`. Ниже даны настройки по умолчанию (устанавливаемые в ``/etc/default/tarantool`` или ``/etc/sysconfig/tarantool`` как часть дистрибутива Tarantool'а — см. пути по умолчанию для разных ОС в :ref:`Замечаниях по поводу некоторых операционных систем <admin-os_notes>`):"

#: ../doc/1.7/book/admin/instance_config.rst:104
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""
"default_cfg = {\n"
"            pid_file  = \"/var/run/tarantool\",\n"
"            wal_dir   = \"/var/lib/tarantool\",\n"
"            memtx_dir = \"/var/lib/tarantool\",\n"
"            vinyl_dir = \"/var/lib/tarantool\",\n"
"            log       = \"/var/log/tarantool\",\n"
"            username  = \"tarantool\",\n"
"        }\n"
"        instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid "Directory for the pid file and control-socket file; ``tarantoolctl`` will add “/instance_name” to the directory name."
msgstr "Директория, где хранятся pid-файл и socket-файл; ``tarantoolctl`` добавляет “/имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid "Directory for write-ahead .xlog files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr "Директория, где хранятся .xlog-файлы; ``tarantoolctl`` добавляет “/имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``memtx_dir``"
msgstr "``memtx_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid "Directory for snapshot .snap files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr "Директория, где хранятся .snap-файлы; ``tarantoolctl`` добавляет “/имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``vinyl_dir``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid "Directory for vinyl files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr "Директория, где хранятся vinyl-файлы; ``tarantoolctl`` добавляет “/имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``log``"
msgstr "``log``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid "The place where the application log will go; ``tarantoolctl`` will add \"/instance_name.log\" to the name."
msgstr "Директория, где хранятся файлы журнала с сообщениями от Tarantool-приложения; ``tarantoolctl`` добавляет “/имя_экземпляра” к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``username``"
msgstr "``username``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid "The user that runs the Tarantool instance. This is the operating-system user name rather than the Tarantool-client user name. Tarantool will change its effective user to this user after becoming a daemon."
msgstr "Пользователь, запускающий экземпляр Tarantool'а. Это пользователь операционной системы, а не Tarantool-клиента. Став демоном, Tarantool сменит своего пользователя на указанного."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid "The directory where all instance files for this host are stored. Put instance files in this directory, or create symbolic links."
msgstr "Директория, где хранятся все файлы экземпляра для данного компьютера. Поместите сюда файлы экземпляра или создайте символьные ссылки на них."

#: ../doc/1.7/book/admin/instance_config.rst:149
msgid "The default instance directory depends on Tarantool's ``WITH_SYSVINIT`` build option: when ON, it is ``/etc/tarantool/instances.enabled``, otherwise (OFF or not set) it is ``/etc/tarantool/instances.available``. The latter case is typical for Tarantool builds for Linux distros with ``systemd``."
msgstr "Директория с экземплярами, которая используется по умолчанию, зависит от параметра ``WITH_SYSVINIT`` сборки Tarantool'а: когда его значение \"ON\", то ``/etc/tarantool/instances.enabled``, в противном случае (\"OFF\" или значение не установлено), то ``/etc/tarantool/instances.available``. Последний случай характерен для сборок Tarantool'а для дистрибутивов Linux с ``systemd``."

#: ../doc/1.7/book/admin/instance_config.rst:155
msgid "To check the build options, say ``tarantool --version``."
msgstr "Для проверки параметров сборки выполните команду ``tarantool --version``."

#: ../doc/1.7/book/admin/instance_config.rst:157
msgid "As a full-featured example, you can take `example.lua <https://github.com/tarantool/tarantool/blob/1.7/extra/dist/example.lua>`_ script that ships with Tarantool and defines all configuration options."
msgstr "В качестве полноценного примера можно использовать скрипт `example.lua <https://github.com/tarantool/tarantool/blob/1.7/extra/dist/example.lua>`_,  который поставляется вместе с Tarantool и задает все конфигурационные параметры."

#: ../doc/1.7/book/admin/logs.rst:5
msgid "Logs"
msgstr "Журналирование"

#: ../doc/1.7/book/admin/logs.rst:7
msgid "Tarantool logs important events to a file, e.g. ``/var/log/tarantool/my_app.log``. To build the log file path, ``tarantoolctl`` takes the instance name, prepends the instance directory and appends “.log” extension."
msgstr "Все важные события Tarantool записывает в файл журнала -- например, в ``/var/log/tarantool/my_app.log``.  ``tarantoolctl`` строит путь до файла  журнала следующим образом: \"путь до директории с экземплярами\" + \"имя  экземпляра\" + \".lua\"."

#: ../doc/1.7/book/admin/logs.rst:11
msgid "Let’s write something to the log file:"
msgstr "Запишем что-нибудь в файл журнала:"

#: ../doc/1.7/book/admin/logs.rst:13
msgid ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for the manual readers\")\n"
"---\n"
"..."
msgstr ""
"$ tarantoolctl enter my_app\n"
"        /bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"        unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for the manual readers\")\n"
"        ---\n"
"        ..."

#: ../doc/1.7/book/admin/logs.rst:21
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../doc/1.7/book/admin/logs.rst:23
msgid ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version 1.7.3-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping 134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to [::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from `/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set 'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the manual readers"
msgstr ""
"$ tail /var/log/tarantool/my_app.log\n"
"        2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version 1.7.3-382-g68ef3f6a9\n"
"        2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"        2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping 134217728 bytes for tuple arena...\n"
"        2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to [::1]:3301\n"
"        2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"        2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from `/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"        2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept requests\n"
"        2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set 'checkpoint_interval' configuration option to 3600\n"
"        2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at unix/:/var/run/tarantool/my_app.control\n"
"        2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"        2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"        2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the manual readers"

#: ../doc/1.7/book/admin/logs.rst:39
msgid "When logging to a file, the system administrator must ensure logs are rotated timely and do not take up all the available disk space. With ``tarantoolctl``, log rotation is pre-configured to use ``logrotate`` program, which you must have installed."
msgstr "При включенном журналировании системный администратор должен обеспечивать  своевременную ротацию журналов, чтобы избежать переполнения дискового пространства. Ротация журналов в ``tarantoolctl`` производится с помощью программы ``logrotate``, которую необходимо установить заранее."

#: ../doc/1.7/book/admin/logs.rst:44
msgid "File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool distribution, and you can modify it to change the default behavior. This is what this file is usually like:"
msgstr "Файл ``/etc/logrotate.d/tarantool`` поставляется со стандартным дистрибутивом Tarantool. Его можно редактировать для изменения поведения по умолчанию. Содержимое файла обычно выглядит так:"

#: ../doc/1.7/book/admin/logs.rst:48
#, python-format
msgid ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""
"/var/log/tarantool/*.log {\n"
"            daily\n"
"            size 512k\n"
"            missingok\n"
"            rotate 10\n"
"            compress\n"
"            delaycompress\n"
"            create 0640 tarantool adm\n"
"            postrotate\n"
"                /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"            endscript\n"
"        }"

#: ../doc/1.7/book/admin/logs.rst:63
msgid "If you use a different log rotation program, you can invoke ``tarantoolctl logrotate`` command to request instances to reopen their log files after they were moved by the program of your choice."
msgstr "Если вы используете другую программу для ротации журналов, можно вызвать команду ``tarantoolctl logrotate``, чтобы экземпляры переоткрыли свои файлы журнала после того, как выбранная вами программа переместила их."

#: ../doc/1.7/book/admin/logs.rst:67
msgid "Tarantool can write its logs to a log file, ``syslog`` or a program specified in the configuration file (see :ref:`log <cfg_logging-log>` parameter)."
msgstr "Tarantool может писать события в файл журнала, ``syslog`` или программу, указанную в конфигурационном файле (см. параметр :ref:`log <cfg_logging-log>`)."

#: ../doc/1.7/book/admin/logs.rst:70
msgid "By default, logs are written to a file as defined in ``tarantoolctl`` defaults. ``tarantoolctl`` automatically detects if an instance is using ``syslog`` or an external program for logging, and does not override the log destination in this case. In such configurations, log rotation is usually handled by the external program used for logging. So, ``tarantoolctl logrotate`` command works only if logging-into-file is enabled in the instance file."
msgstr "По умолчанию запись производится в файл журнала, как указано в исходных настройках ``tarantoolctl``. Скрипт ``tarantoolctl`` автоматически определяет, когда экземпляр использует для журналирования ``syslog`` или внешнюю программу, и не изменяет то, куда ведется запись. В таких случаях  ротацию журналов обычно выполняет та же программа, которая используется для журналирования. Именно поэтому команда ``tarantoolctl logrotate`` сработает только в том случае, если в файле экземпляра включена возможность вести запись в файл."

#: ../doc/1.7/book/admin/os_notes.rst:5
msgid "Notes for operating systems"
msgstr "Замечания по поводу некоторых операционных систем"

#: ../doc/1.7/book/admin/os_notes.rst:11
msgid "Mac OS"
msgstr "Mac OS"

#: ../doc/1.7/book/admin/os_notes.rst:13
msgid "On Mac OS, you can administer Tarantool instances only with ``tarantoolctl``. No native system tools are supported."
msgstr "Администрирование экземпляров Tarantool'а на Mac OS возможно только с помощью ``tarantoolctl``. Встроенные системные инструменты не поддерживаются."

#: ../doc/1.7/book/admin/os_notes.rst:20
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../doc/1.7/book/admin/os_notes.rst:22
msgid "To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD, use paths other than those suggested in :ref:`Instance configuration <admin-instance_config>`. Instead of ``/usr/share/tarantool/`` directory, use ``/usr/local/etc/tarantool/`` and create the following subdirectories:"
msgstr "Чтобы ``tarantoolctl`` и утилиты ``init.d`` работали на FreeBSD, используйте пути, отличные от предложенных в разделе :ref:`Настройка экземпляров Tarantool’а <admin-instance_config>`. Используйте ``/usr/local/etc/tarantool/`` вместо ``/usr/share/tarantool/`` и создайте  следующие поддиректории:"

#: ../doc/1.7/book/admin/os_notes.rst:28
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr "``default`` для хранения настроек ``tarantoolctl`` по умолчанию (см. пример ниже),"

#: ../doc/1.7/book/admin/os_notes.rst:29
msgid "``instances.available`` for all available instance files, and"
msgstr "``instances.available`` для хранения всех доступных файлов экземпляра, и"

#: ../doc/1.7/book/admin/os_notes.rst:30
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr "``instances.enabled`` для хранения файлов экземпляра, которые необходимо запускать автоматически с помощью sysvinit."

#: ../doc/1.7/book/admin/os_notes.rst:32
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr "Так выглядят настройки ``tarantoolctl`` по умолчанию на FreeBSD:"

#: ../doc/1.7/book/admin/os_notes.rst:34
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- /var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- /var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""
"default_cfg = {\n"
"            pid_file   = \"/var/run/tarantool\", -- /var/run/tarantool/${INSTANCE}.pid\n"
"            wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/ \n"
"            snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"            vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"            logger     = \"/var/log/tarantool\", -- /var/log/tarantool/${INSTANCE}.log\n"
"            username   = \"tarantool\",\n"
"        }\n"
"        \n"
"        -- instances.available - все доступные экземпляры\n"
"        -- instances.enabled - экземпляры для автоматического запуска через sysvinit\n"
"        instance_dir = \"/usr/local/etc/tarantool/instances.available\""

#: ../doc/1.7/book/admin/os_notes.rst:53
msgid "Gentoo Linux"
msgstr "Gentoo Linux"

#: ../doc/1.7/book/admin/os_notes.rst:55
msgid "The section below is about a dev-db/tarantool package installed from the official layman overlay (named ``tarantool``)."
msgstr "В разделе ниже описывается пакет \"dev-db/tarantool\", установленный из официального оверлея layman (под названием ``tarantool``)."

#: ../doc/1.7/book/admin/os_notes.rst:58
msgid "The default instance directory is ``/etc/tarantool/instances.available``, can be redefined in ``/etc/default/tarantool``."
msgstr "По умолчанию с экземплярами используется директория ``/etc/tarantool/instances.available``,  ее можно переопределить в ``/etc/default/tarantool``."

#: ../doc/1.7/book/admin/os_notes.rst:61
msgid "Tarantool instances can be managed (start/stop/reload/status/...) using OpenRC. Consider the example how to create an OpenRC-managed instance:"
msgstr "Управление экземплярами Tarantool'а (запуск/остановка/перезагрузка/проверка статуса и т.д.) можно осуществлять с помощью OpenRC. Рассмотрим пример, как создать экземпляр с управлением OpenRC:"

#: ../doc/1.7/book/admin/os_notes.rst:64
msgid ""
"$ cd /etc/init.d\n"
"$ ln -s tarantool your_service_name\n"
"$ ln -s /usr/share/tarantool/your_service_name.lua /etc/tarantool/instances.available/your_service_name.lua"
msgstr ""
"$ cd /etc/init.d\n"
"        $ ln -s tarantool your_service_name\n"
"        $ ln -s /usr/share/tarantool/your_service_name.lua /etc/tarantool/instances.available/your_service_name.lua"

#: ../doc/1.7/book/admin/os_notes.rst:70
msgid "Checking that it works:"
msgstr "Проверяем, что работает:"

#: ../doc/1.7/book/admin/os_notes.rst:72
msgid ""
"$ /etc/init.d/your_service_name start\n"
"$ tail -f -n 100 /var/log/tarantool/your_service_name.log"
msgstr ""
"$ /etc/init.d/your_service_name start\n"
"        $ tail -f -n 100 /var/log/tarantool/your_service_name.log"

#: ../doc/1.7/book/admin/security.rst:5
msgid "Security"
msgstr "Безопасность"

#: ../doc/1.7/book/admin/security.rst:7
msgid "Tarantool allows for two types of connections:"
msgstr "Tarantool разрешает два типа подключений:"

#: ../doc/1.7/book/admin/security.rst:9
msgid "With :ref:`console.listen() <console-listen>` function from ``console`` module, you can set up a port which can be used to open an administrative console to the server. This is for administrators to connect to a running instance and make requests. ``tarantoolctl`` invokes ``console.listen()`` to create a control socket for each started instance."
msgstr "Используя функцию :ref:`console.listen() <console-listen>` из модуля ``console``, можно настроить порт для подключения к серверной административной консоли. Этот вариант для администраторов, которым необходимо подключиться к работающему экземпляру и послать некоторые запросы. ``tarantoolctl`` вызывает ``console.listen()``, чтобы создать управляющий сокет для каждого запущенного экземпляра."

#: ../doc/1.7/book/admin/security.rst:15
msgid "With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box`` module, you can set up a binary port for connections which read and write to the database or invoke stored procedures."
msgstr "Используя параметр :ref:`box.cfg{listen=...} <cfg_basic-listen>` из модуля ``box``, можно настроить бинарный порт для соединений, которые читают и пишут в базу данных или вызывают хранимые процедуры."

#: ../doc/1.7/book/admin/security.rst:19
msgid "When you connect to an admin console:"
msgstr "Если вы подключены к административной консоли:"

#: ../doc/1.7/book/admin/security.rst:21
msgid "The client-server protocol is plain text."
msgstr "Клиент-серверный протокол -- это простой текст."

#: ../doc/1.7/book/admin/security.rst:22
msgid "No password is necessary."
msgstr "Пароль не требуется."

#: ../doc/1.7/book/admin/security.rst:23
msgid "The user is automatically 'admin'."
msgstr "Пользователь автоматически получает права администратора."

#: ../doc/1.7/book/admin/security.rst:24
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr "Каждая команда напрямую обрабатывается встроенным интерпретатором Lua."

#: ../doc/1.7/book/admin/security.rst:26
msgid "Therefore you must set up ports for the admin console very cautiously. If it is a TCP port, it should only be opened for a specific IP. Ideally, it should not be a TCP port at all, it should be a Unix domain socket, so that access to the server machine is required. Thus a typical port setup for admin console is:"
msgstr "Поэтому порты для административной консоли следует настраивать очень осторожно. Если это TCP-порт, он должен быть открыть только для определенного IP-адреса. В идеале вместо TCP-порта лучше настроить доменный Unix-сокет, который требует наличие прав доступа к серверной машине. Тогда типичная настройка порта для административной консоли будет  выглядеть следующим образом:"

#: ../doc/1.7/book/admin/security.rst:31
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../doc/1.7/book/admin/security.rst:35
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../doc/1.7/book/admin/security.rst:37
msgid "/var/lib/tarantool/socket_name.sock"
msgstr "/var/lib/tarantool/socket_name.sock"

#: ../doc/1.7/book/admin/security.rst:41
msgid "if the listener has the privilege to write on ``/var/lib/tarantool`` and the connector has the privilege to read on ``/var/lib/tarantool``. Alternatively, to connect to an admin console of an instance started with ``tarantoolctl``, use :ref:`tarantoolctl enter <admin-executing_code_on_an_instance>`."
msgstr "если у приемника событий есть права на запись в ``/var/lib/tarantool`` и у коннектора есть права на чтение из ``/var/lib/tarantool``. Еще один способ подключиться к административной консоли экземпляра, запущенного с помощью ``tarantoolctl``, -- использовать  :ref:`tarantoolctl enter <admin-executing_code_on_an_instance>`."

#: ../doc/1.7/book/admin/security.rst:46
msgid "To find out whether a TCP port is a port for admin console, use ``telnet``. For example:"
msgstr "Выяснить, является ли некоторый TCP-порт портом для административной консоли, можно с помощью ``telnet``. Например:"

#: ../doc/1.7/book/admin/security.rst:49
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.3 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"        Trying 0.0.0.0...\n"
"        Connected to 0.\n"
"        Escape character is '^]'.\n"
"        Tarantool 1.7.3 (Lua console)\n"
"        type 'help' for interactive help"

#: ../doc/1.7/book/admin/security.rst:58
msgid "In this example, the response does not include the word \"binary\" and does include the words \"Lua console\". Therefore it is clear that this is a successful connection to a port for admin console, and you can now enter admin requests on this terminal."
msgstr "В этом примере в ответе от сервера нет слова \"binary\" и есть слова \"Lua console\". Это значит, что мы успешно подключились к порту для административной консоли и можем вводить администраторские запросы на этом терминале."

#: ../doc/1.7/book/admin/security.rst:63
msgid "When you connect to a binary port:"
msgstr "Если вы подключены к бинарному порту:"

#: ../doc/1.7/book/admin/security.rst:65
msgid "The client-server protocol is :ref:`binary <box_protocol-iproto_protocol>`."
msgstr "Клиент-серверный протокол -- :ref:`бинарный <box_protocol- iproto_protocol>`."

#: ../doc/1.7/book/admin/security.rst:66
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr "Автоматически выбирается пользователь ':ref:`guest <authentication-users>`'."

#: ../doc/1.7/book/admin/security.rst:67
msgid "To change the user, it’s necessary to authenticate."
msgstr "Для смены пользователя необходимо пройти аутентификацию."

#: ../doc/1.7/book/admin/security.rst:69
msgid "For ease of use, ``tarantoolctl connect`` command automatically detects the type of connection during handshake and uses :ref:`EVAL <box_protocol-eval>` binary protocol command when it’s necessary to execute Lua commands over a binary connection. To execute EVAL, the authenticated user must have global \"EXECUTE\" privilege."
msgstr "Для удобства использования команда ``tarantoolctl connect`` автоматически  определяет тип подключения при установке соединения и использует команду  бинарного протокола :ref:`EVAL <box_protocol-eval>` для выполнения Lua-команд по бинарному подключению. Чтобы выполнить команду EVAL, аутентифицированный пользователь должен иметь глобальные \"EXECUTE\"-права."

#: ../doc/1.7/book/admin/security.rst:75
msgid "Therefore, when ``ssh`` access to the machine is not available, creating a Tarantool user with global \"EXECUTE\" privilege and non-empty password can be used to provide a system administrator **remote** access to an instance."
msgstr "Поэтому при невозможности подключиться к машине по ``ssh`` системный администратор может получить **удаленный** доступ к экземпляру, создав пользователя Tarantool с глобальными \"EXECUTE\"-правами и непустым паролем."

#: ../doc/1.7/book/admin/server_introspection.rst:5
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../doc/1.7/book/admin/server_introspection.rst:11
msgid "Using Tarantool as a client"
msgstr "Использование Tarantool'а в качестве клиента"

#: ../doc/1.7/book/admin/server_introspection.rst:13
msgid "Tarantool enters the interactive mode if:"
msgstr "Tarantool входит в интерактивный режим, если:"

#: ../doc/1.7/book/admin/server_introspection.rst:15
msgid "you start Tarantool without an :ref:`instance file <admin-instance_file>`, or"
msgstr "вы запускаете его без :ref:`файла экземпляра <admin-instance_file>`, либо"

#: ../doc/1.7/book/admin/server_introspection.rst:18
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr "в файле экземпляра содержится команда :ref:`console.start() <console-start>`."

#: ../doc/1.7/book/admin/server_introspection.rst:20
msgid "Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter requests. When used this way, Tarantool can be a client for a remote server. See basic examples in :ref:`Getting started <getting_started>`."
msgstr "Tarantool выводит приглашение командной строки (например, \"tarantool>\")  -- и вы можете посылать запросы. Если использовать Tarantool таким образом, он может выступать клиентом для удаленного сервера, см. простые примеры в :ref:`Руководстве для начинающих <getting_started>`."

#: ../doc/1.7/book/admin/server_introspection.rst:24
msgid "The interactive mode is used by ``tarantoolctl`` to implement \"enter\" and \"connect\" commands."
msgstr "Скрипт ``tarantoolctl`` использует интерактивный режим для реализации команд  \"enter\" и \"connect\"."

#: ../doc/1.7/book/admin/server_introspection.rst:31
msgid "Executing code on an instance"
msgstr "Выполнение кода на экземпляре Tarantool'а"

#: ../doc/1.7/book/admin/server_introspection.rst:33
msgid "You can attach to an instance's :ref:`admin console <admin-security>` and execute some Lua code using ``tarantoolctl``:"
msgstr "Можно подключиться к :ref:`административной консоли <admin-security>` экземпляра и выполнить некий Lua-код с помощью утилиты ``tarantoolctl``:"

#: ../doc/1.7/book/admin/server_introspection.rst:36
msgid ""
"$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""
"$ # для локальных экземпляров:\n"
"        $ tarantoolctl enter my_app\n"
"        /bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available \n"
"        /bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"        /bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"        unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"        ---\n"
"        - 2\n"
"        ...\n"
"        unix/:/var/run/tarantool/my_app.control>\n"
"        \n"
"        $ # для локальных и удаленных экземпляров:\n"
"        $ tarantoolctl connect username:password@127.0.0.1:3306"

#: ../doc/1.7/book/admin/server_introspection.rst:52
msgid "You can also use ``tarantoolctl`` to execute Lua code on an instance without attaching to its admin console. For example:"
msgstr "Можно также использовать ``tarantoolctl`` для выполнения Lua-кода на запущенном экземпляре Tarantool-сервера, не подключаясь к его административной консоли. Например:"

#: ../doc/1.7/book/admin/server_introspection.rst:55
msgid ""
"$ # executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"\n"
"$ # - OR -\n"
"\n"
"$ # executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""
"$ # выполнение команд напрямую из командной строки\n"
"        $ <command> | tarantoolctl eval my_app\n"
"        <...>\n"
"        \n"
"        $ # - ИЛИ -\n"
"        \n"
"        $ # выполнение команд из скрипта\n"
"        $ tarantoolctl eval my_app script.lua\n"
"        <...>"

#: ../doc/1.7/book/admin/server_introspection.rst:69
msgid "Alternatively, you can use the :ref:`console <console-module>` module or the :ref:`net.box <net_box-module>` module from a Tarantool server. Also, you can write your client programs with any of the :ref:`connectors <index-box_connectors>`. However, most of the examples in this manual illustrate usage with either ``tarantoolctl connect`` or :ref:`using the Tarantool server as a client <admin-using_tarantool_as_a_client>`."
msgstr "Еще можно использовать модули :ref:`console <console-module>` и :ref:`net.box <net_box-module>` из Tarantool-сервера. Также вы можете писать свои клиентские программы с использованием любого из доступных :ref:`коннекторов <index-box_connectors>`. Однако большинство примеров в данном документе использует или ``tarantoolctl connect``, или :ref:`Tarantool-сервер как клиент <admin-using_tarantool_as_a_client>`."

#: ../doc/1.7/book/admin/server_introspection.rst:80
msgid "Health checks"
msgstr "Проверка состояния экземпляра"

#: ../doc/1.7/book/admin/server_introspection.rst:82
msgid "To check the instance status, say:"
msgstr "Чтобы проверить статус экземпляра Tarantool-сервера, выполните команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:84
msgid ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"\n"
"$ # - OR -\n"
"\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""
"$ tarantoolctl status my_app\n"
"        my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"        \n"
"        $ # - ИЛИ -\n"
"        \n"
"        $ systemctl status tarantool@my_app\n"
"        tarantool@my_app.service - Tarantool Database Server\n"
"        Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: disabled)\n"
"        Active: active (running)\n"
"        Docs: man:tarantool(1)\n"
"        Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/SUCCESS)\n"
"        Main PID: 5350 (tarantool)\n"
"        Tasks: 11 (limit: 512)\n"
"        CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"        + 5350 tarantool my_app.lua <running>"

#: ../doc/1.7/book/admin/server_introspection.rst:102
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr "Если вы используете систему, на которой доступна утилита ``systemd``, выполните следующую команду для проверки содержимого журнала загрузки:"

#: ../doc/1.7/book/admin/server_introspection.rst:104
msgid ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database Server"
msgstr ""
"$ journalctl -u tarantool@my_app -n 5\n"
"        -- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 MSK. --\n"
"        Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"        Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"        Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"        Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Starting instance...\n"
"        Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database Server"

#: ../doc/1.7/book/admin/server_introspection.rst:114
msgid "For more details, use the reports provided by functions in the following submodules:"
msgstr "Более подробная информация содержится в отчетах, которые можно получить с  помощью функций из следующих подмодулей:"

#: ../doc/1.7/book/admin/server_introspection.rst:116
msgid ":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify all configuration parameters for the Tarantool server)"
msgstr ":ref:`box.cfg <box_introspection-box_cfg>` -- проверка и указание всех конфигурационных параметров Tarantool-сервера,"

#: ../doc/1.7/book/admin/server_introspection.rst:119
msgid ":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total use and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ":ref:`box.slab <box_introspection-box_slab>` -- мониторинг использования и  фрагментированности памяти, выделенной для хранения данных в Tarantool'е,"

#: ../doc/1.7/book/admin/server_introspection.rst:122
msgid ":ref:`box.info <box_introspection-box_info>` submodule (introspect Tarantool server variables, primarily those related to replication)"
msgstr ":ref:`box.info <box_introspection-box_info>` -- просмотр переменных Tarantool-сервера -- в первую очередь тех, что относятся к репликации,"

#: ../doc/1.7/book/admin/server_introspection.rst:125
msgid ":ref:`box.stat <box_introspection-box_stat>` submodule (introspect Tarantool request and network statistics)"
msgstr ":ref:`box.stat <box_introspection-box_stat>` -- просмотр статистики Tarantool'а по запросам и использованию сети,"

#: ../doc/1.7/book/admin/server_introspection.rst:128
msgid "You can also try `tarantool/prometheus <https://github.com/tarantool/prometheus>`_, a Lua module that makes it easy to collect metrics (e.g. memory usage or number of requests) from Tarantool applications and databases and expose them via the Prometheus protocol."
msgstr "Можно также попробовать воспользоваться Lua-модулем `tarantool/prometheus  <https://github.com/tarantool/prometheus>`_, который облегчает сбор метрик (например, использование памяти или количество запросов) с Tarantool-приложений и баз данных и их публикацию через протокол Prometheus."

#: ../doc/1.7/book/admin/server_introspection.rst:133
#: ../doc/1.7/book/box/authentication.rst:225
#: ../doc/1.7/book/box/box_schema.rst:177
#: ../doc/1.7/book/box/box_session.rst:173
#: ../doc/1.7/book/box/box_session.rst:231
#: ../doc/1.7/book/box/box_session.rst:261
#: ../doc/1.7/book/box/box_session.rst:305 ../doc/1.7/book/box/triggers.rst:74
msgid "**Example**"
msgstr "**Пример**"

#: ../doc/1.7/book/admin/server_introspection.rst:135
msgid "A very popular administrator request is :ref:`box.slab.info() <box_slab_info>`, which displays detailed memory usage statistics for a Tarantool instance."
msgstr "Очень часто администраторам приходится вызывать функцию :ref:`box.slab.info() <box_slab_info>`, которая показывает подробную статистику по использованию памяти для конкретного экземпляра Tarantool'а."

#: ../doc/1.7/book/admin/server_introspection.rst:138
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""
"tarantool> box.slab.info()\n"
"        ---\n"
"        - items_size: 228128\n"
"          items_used_ratio: 1.8%\n"
"          quota_size: 1073741824\n"
"          quota_used_ratio: 0.8%\n"
"          arena_used_ratio: 43.2%\n"
"          items_used: 4208\n"
"          quota_used: 8388608\n"
"          arena_size: 2325176\n"
"          arena_used: 1003632\n"
"        ..."

#: ../doc/1.7/book/admin/server_introspection.rst:153
msgid "Tarantool takes memory from the operating system, for example when a user does many insertions. You can see how much it has taken by saying (on Linux):"
msgstr "Tarantool занимает память операционной системы, например, когда пользователь вставляет много данных. Можно проверить, сколько памяти занято, выполнив команду (в Linux):"

#: ../doc/1.7/book/admin/server_introspection.rst:157
msgid "ps -eo args,%mem | grep \"tarantool\""
msgstr "ps -eo args,%mem | grep \"tarantool\""

#: ../doc/1.7/book/admin/server_introspection.rst:161
msgid "Tarantool almost never releases this memory, even if the user deletes everything that was inserted, or reduces fragmentation by calling the Lua `collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr "Tarantool почти никогда не освобождает эту память, даже если пользователь удалит все, что было вставлено, или уменьшит фрагментацию, вызвав Lua-функцию  `collectgarbage <https://www.lua.org/manual/5.1/manual.html #pdf-collectgarbage>`_."

#: ../doc/1.7/book/admin/server_introspection.rst:166
msgid "Ordinarily this does not affect performance. But, to force Tarantool to release memory, you can call :ref:`box.snapshot <box-snapshot>`, stop the server instance, and restart it."
msgstr "Как правило, это не влияет на производительность. Однако, чтобы заставить Tarantool высвободить память, можно вызвать :ref:`box.snapshot <box-snapshot>`, остановить экземпляр и перезапустить его."

#: ../doc/1.7/book/admin/server_introspection.rst:175
msgid "Profiling performance issues"
msgstr "Профилирование производительности"

#: ../doc/1.7/book/admin/server_introspection.rst:177
msgid "Tarantool can at times work slower than usual. There can be multiple reasons, such as disk issues, CPU-intensive Lua scripts or misconfiguration. Tarantool’s log may lack details in such cases, so the only indications that something goes wrong are log entries like this: ``W> too long DELETE: 8.546 sec``. Here are tools and techniques that can help you collect Tarantool’s performance profile, which is helpful in troubleshooting slowdowns."
msgstr "Иногда Tarantool может работать медленнее, чем обычно. Причин такого поведения может быть несколько: проблемы с диском, Lua-скрипты, активно использующие процессор, или неправильная настройка. В таких случаях в журнале Tarantool’а могут отсутствовать необходимые подробности, поэтому единственным признаком неправильного поведения является наличие в журнале  записей вида ``W> too long DELETE: 8.546 sec``. Ниже приведены инструменты и приемы, которые облегчают снятие профиля производительности  Tarantool’а. Эта процедура может помочь при решении проблем с замедлением."

#: ../doc/1.7/book/admin/server_introspection.rst:186
msgid "Most of these tools -- except ``fiber.info()`` -- are intended for generic GNU/Linux distributions, but not FreeBSD or Mac OS."
msgstr "Большинство инструментов, за исключением ``fiber.info()``, предназначено для дистрибутивов GNU/Linux, но не для FreeBSD или Mac OS."

#: ../doc/1.7/book/admin/server_introspection.rst:191
msgid "fiber.info()"
msgstr "fiber.info()"

#: ../doc/1.7/book/admin/server_introspection.rst:193
msgid "The simplest profiling method is to take advantage of Tarantool’s built-in functionality. :ref:`fiber.info() <fiber-info>` returns information about all running fibers with their corresponding C stack traces. You can use this data to see how many fibers are running and which C functions are executed more often than others."
msgstr "Самый простой способ профилирования -- это использование встроенных функций Tarantool’а. :ref:`fiber.info() <fiber-info>` возвращает информацию обо всех работающих файберах с соответствующей трассировкой стека для языка C. Эти данные показывают, сколько файберов запущенно на данный момент и какие функции, написанные на C, вызываются чаще остальных."

#: ../doc/1.7/book/admin/server_introspection.rst:199
msgid "First, enter your instance’s interactive administrator console:"
msgstr "Сначала войдите в интерактивную административную консоль вашего экземпляра Tarantool’а:"

#: ../doc/1.7/book/admin/server_introspection.rst:201
#: ../doc/1.7/book/admin/server_introspection.rst:479
msgid "$ tarantoolctl enter NAME"
msgstr "$ tarantoolctl enter NAME"

#: ../doc/1.7/book/admin/server_introspection.rst:205
msgid "Once there, load the ``fiber`` module:"
msgstr "После этого загрузите модуль ``fiber``:"

#: ../doc/1.7/book/admin/server_introspection.rst:207
msgid "tarantool> fiber = require('fiber')"
msgstr "tarantool> fiber = require('fiber')"

#: ../doc/1.7/book/admin/server_introspection.rst:211
msgid "After that you can get the required information with ``fiber.info()``."
msgstr "Теперь можно получить необходимую информацию с помощью `fiber.info()`."

#: ../doc/1.7/book/admin/server_introspection.rst:213
msgid "At this point, you console output should look something like this:"
msgstr "На этом шаге в вашей консоли должно выводиться следующее:"

#: ../doc/1.7/book/admin/server_introspection.rst:215
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"        ---\n"
"        ...\n"
"        tarantool> fiber.info()\n"
"        ---\n"
"        - 360:\n"
"            csw: 2098165\n"
"            backtrace:\n"
"            - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"            - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"            - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"            - '#3 0x4bed48 in box_process1+104'\n"
"            - '#4 0x4d72f8 in lbox_replace+120'\n"
"            - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"            fid: 360\n"
"            memory:\n"
"              total: 61744\n"
"              used: 480\n"
"            name: main\n"
"          129:\n"
"            csw: 113\n"
"            backtrace: []\n"
"            fid: 129\n"
"            memory:\n"
"              total: 57648\n"
"              used: 0\n"
"            name: 'console/unix/:'\n"
"        ..."

#: ../doc/1.7/book/admin/server_introspection.rst:246
msgid "We highly recommend to assign meaningful names to fibers you create so that you can find them in the ``fiber.info()`` list. In the example below, we create a fiber named ``myworker``:"
msgstr "Мы рекомендуем присваивать создаваемым файберам понятные имена, чтобы их можно было легко найти в списке, выводимом ``fiber.info()``. В примере ниже создается файбер с именем ``myworker``:"

#: ../doc/1.7/book/admin/server_introspection.rst:250
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- assigning the name to a fiber\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- newly created background fiber\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber = require('fiber')\n"
"        ---\n"
"        ...\n"
"        tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end  end)\n"
"        ---\n"
"        ...\n"
"        tarantool> f:name('myworker') <!-- назначить имя файберу\n"
"        ---\n"
"        ...\n"
"        tarantool> fiber.info()\n"
"        ---\n"
"        - 102:\n"
"            csw: 14\n"
"            backtrace:\n"
"            - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"            - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"            - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"            fid: 102\n"
"            memory:\n"
"              total: 57656\n"
"              used: 0\n"
"            name: myworker <!-- newly created background fiber\n"
"          101:\n"
"            csw: 284\n"
"            backtrace: []\n"
"            fid: 101\n"
"            memory:\n"
"              total: 57656\n"
"              used: 0\n"
"            name: interactive\n"
"        ..."

#: ../doc/1.7/book/admin/server_introspection.rst:284
msgid "You can kill any fiber with :ref:`fiber.kill(fid) <fiber-kill>`:"
msgstr "Для принудительного завершения файбера используется команда :ref:`fiber.kill(fid) <fiber-kill>`:"

#: ../doc/1.7/book/admin/server_introspection.rst:286
msgid ""
"tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""
"tarantool> fiber.kill(102)\n"
"        ---\n"
"        ...\n"
"        tarantool> fiber.info()\n"
"        ---\n"
"        - 101:\n"
"            csw: 324\n"
"            backtrace: []\n"
"            fid: 101\n"
"            memory:\n"
"              total: 57656\n"
"              used: 0\n"
"            name: interactive\n"
"        ..."

#: ../doc/1.7/book/admin/server_introspection.rst:303
msgid "If you want to dynamically obtain information with ``fiber.info()``, the shell script below may come in handy. It connects to a Tarantool instance specified by ``NAME`` every 0.5 seconds, grabs the ``fiber.info()`` output and writes it to the ``fiber-info.txt`` file:"
msgstr "Если вам необходимо динамически получать информацию с помощью ``fiber.info()``, вам может пригодиться приведенный ниже скрипт. Он каждые полсекунды подключается к экземпляру Tarantool’а, указанному в переменной ``NAME``, выполняет команду ``fiber.info()`` и записывает ее выход в файл ``fiber-info.txt``:"

#: ../doc/1.7/book/admin/server_introspection.rst:308
msgid ""
"$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl enter NAME | tee -a fiber-info.txt\""
msgstr ""
"$ rm -f fiber.info.txt\n"
"        $ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl enter NAME | tee -a fiber-info.txt\""

#: ../doc/1.7/book/admin/server_introspection.rst:313
msgid "If you can't understand which fiber causes performance issues, collect the metrics of the ``fiber.info()`` output for 10-15 seconds using the script above and contact the Tarantool team at support@tarantool.org."
msgstr "Если вы не можете самостоятельно разобраться, какой именно файбер вызывает проблемы с производительностью, запустите данный скрипт на 10-15  секунд и пришлите получившийся файл команде Tarantool’а на адрес support@tarantool.org."

#: ../doc/1.7/book/admin/server_introspection.rst:319
msgid "Poor man’s profilers"
msgstr "Простейшие профилировщики"

#: ../doc/1.7/book/admin/server_introspection.rst:321
msgid "**pstack <pid>**"
msgstr "**pstack <pid>**"

#: ../doc/1.7/book/admin/server_introspection.rst:323
msgid "To use this tool, first install it with a package manager that comes with your Linux distribution. This command prints an execution stack trace of a running process specified by the PID. You might want to run this command several times in a row to pinpoint the bottleneck that causes the slowdown."
msgstr "Чтобы использовать этот инструмент, его необходимо установить с помощью пакетного менеджера, поставляемого с вашим дистрибутивом Linux. Данная команда выводит трассировку стека выполнения для работающего процесса с соответствующим PID. При необходимости команду можно запустить несколько раз, чтобы выявить узкое место, которое вызывает падение производительности."

#: ../doc/1.7/book/admin/server_introspection.rst:328
msgid "Once installed, say:"
msgstr "После установки воспользуйтесь следующей командой:"

#: ../doc/1.7/book/admin/server_introspection.rst:330
msgid "$ pstack $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ pstack $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.7/book/admin/server_introspection.rst:334
#: ../doc/1.7/book/admin/server_introspection.rst:381
msgid "Next, say:"
msgstr "Затем выполните:"

#: ../doc/1.7/book/admin/server_introspection.rst:336
#: ../doc/1.7/book/admin/server_introspection.rst:383
msgid "$ echo $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ echo $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.7/book/admin/server_introspection.rst:340
#: ../doc/1.7/book/admin/server_introspection.rst:387
msgid "to show the PID of the Tarantool instance that runs the ``INSTANCENAME.lua`` file."
msgstr "чтобы вывести на экран PID экземпляра Tarantool’а, использующего файл ``INSTANCENAME.lua``."

#: ../doc/1.7/book/admin/server_introspection.rst:342
msgid "You should get similar output:"
msgstr "В вашей консоли должно отображаться приблизительно следующее:"

#: ../doc/1.7/book/admin/server_introspection.rst:344
msgid ""
"Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), __va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"
msgstr ""
"Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"        #0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"        #1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"        #2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"        #3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"        Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"        #0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"        #1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"        #2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"        #3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"        <...>\n"
"        Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"        #0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n"
"        #1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"        #2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"        #3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), __va_list_tag*) ()\n"
"        #4 0x00000000004b52a0 in fiber_loop ()\n"
"        #5 0x00000000006099cf in coro_init ()\n"
"        Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"        #0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"        #1 0x00000000006051c8 in epoll_poll ()\n"
"        #2 0x0000000000607533 in ev_run ()\n"
"        #3 0x0000000000428e13 in main ()"

#: ../doc/1.7/book/admin/server_introspection.rst:370
msgid "**gdb -ex \"bt\" -p <pid>**"
msgstr "**gdb -ex \"bt\" -p <pid>**"

#: ../doc/1.7/book/admin/server_introspection.rst:372
msgid "As with ``pstack``, the GNU debugger (also known as ``gdb``) needs to be installed before you can start using it. Your Linux package manager can help you with that."
msgstr "Как и в случае с ``pstack``,  перед использованием GNU-отладчик (также известный как ``gdb``) необходимо сначала установить через пакетный менеджер, встроенный в ваш дистрибутив Linux."

#: ../doc/1.7/book/admin/server_introspection.rst:375
msgid "Once the debugger is installed, say:"
msgstr "После установки воспользуйтесь следующей командой:"

#: ../doc/1.7/book/admin/server_introspection.rst:377
msgid "$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.7/book/admin/server_introspection.rst:389
msgid "After using the debugger, your console output should look like this:"
msgstr "После использования отладчика в консоль должна выводиться следующая информация:"

#: ../doc/1.7/book/admin/server_introspection.rst:391
msgid ""
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, bytes=bytes@entry=504) at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, elem_size=<optimized out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) at /usr/src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at /usr/src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at /usr/src/tarantool/src/box/vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at /usr/src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next (itr=itr@entry=0x7f72264af990, result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized out>, result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, space=0x2567ea0, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl.c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized out>, txn=<optimized out>, space=<optimized out>, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw (request=request@entry=0x7f72265a70f8, space=space@entry=0x2567ea0, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, tuple=<optimized out>, tuple_end=<optimized out>, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at /usr/src/tarantool/src/box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at /usr/src/tarantool/src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) at /usr/src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 <execute_lua_call>, out=out@entry=0x7f7213020600, request=request@entry=0x413c5780) at /usr/src/tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call (request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at /usr/src/tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at /usr/src/tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value has been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef __va_list_tag __va_list_tag *) (f=<optimized out>, ap=<optimized out>) at /usr/src/tarantool/src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at /usr/src/tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at /usr/src/tarantool/third_party/coro/coro.c:110"
msgstr ""
"[Thread debugging using libthread_db enabled]\n"
"        Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n"
"        \n"
"        [CUT]\n"
"        \n"
"        Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"        #0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, bytes=bytes@entry=504) at malloc.c:3697\n"
"        #1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, elem_size=<optimized out>) at malloc.c:3234\n"
"        #2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"        #3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) at /usr/src/tarantool/src/box/vinyl.c:7660\n"
"        #4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at  /usr/src/tarantool/src/box/vinyl.c:8387\n"
"        #5 vy_read_iterator_use_range (itr=0x7f72264af990) at /usr/src/tarantool/src/box/vinyl.c:8453\n"
"        #6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at /usr/src/tarantool/src/box/vinyl.c:8501\n"
"        #7 0x00000000004766b5 in vy_read_iterator_next (itr=itr@entry=0x7f72264af990, result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:8592\n"
"        #8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized out>, result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:5705\n"
"        #9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"        #10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, space=0x2567ea0, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl.c:6608\n"
"        #11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized out>, txn=<optimized out>, space=<optimized out>, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl_space.cc:108\n"
"        #12 0x00000000004bd723 in process_rw (request=request@entry=0x7f72265a70f8, space=space@entry=0x2567ea0, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:182\n"
"        #13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:700\n"
"        #14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, tuple=<optimized out>, tuple_end=<optimized out>, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:754\n"
"        #15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at /usr/src/tarantool/src/box/lua/index.c:72\n"
"        #16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"        #17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at /usr/src/tarantool/src/box/lua/call.c:282\n"
"        #18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"        #19 0x0000000000529c7b in lua_cpcall ()\n"
"        #20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) at /usr/src/tarantool/src/lua/utils.c:962\n"
"        #21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 <execute_lua_call>, out=out@entry=0x7f7213020600, request=request@entry=0x413c5780) at /usr/src/tarantool/src/box/lua/call.c:382\n"
"        #22 box_lua_call (request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/lua/call.c:405\n"
"        #23 0x00000000004c0f27 in box_process_call (request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/box.cc:1074\n"
"        #24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at /usr/src/tarantool/src/box/iproto.cc:942\n"
"        #25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at /usr/src/tarantool/src/cbus.c:302\n"
"        #26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value  has been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"        #27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef __va_list_tag __va_list_tag *) (f=<optimized out>, ap=<optimized out>) at  /usr/src/tarantool/src/fiber.h:645\n"
"        #28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at /usr/src/tarantool/src/fiber.c:641\n"
"        #29 0x0000000000688fbf in coro_init () at /usr/src/tarantool/third_party/coro/coro.c:110"

#: ../doc/1.7/book/admin/server_introspection.rst:430
msgid "Run the debugger in a loop a few times to collect enough samples for making conclusions about why Tarantool demonstrates suboptimal performance. Use the following script:"
msgstr "Запустите отладчик в цикле, чтобы собрать достаточно информации, которая поможет установить причину спада производительности Tarantool’а. Можно воспользоваться следующим скриптом:"

#: ../doc/1.7/book/admin/server_introspection.rst:434
msgid ""
"$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' --batch -p $(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""
msgstr ""
"$ rm -f stack-trace.txt\n"
"        $ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' --batch -p $(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""

#: ../doc/1.7/book/admin/server_introspection.rst:439
msgid "Structurally and functionally, this script is very similar to the one used with ``fiber.info()`` above."
msgstr "С точки зрения структуры и функциональности, этот скрипт идентичен тому, что используется выше с ``fiber.info()``."

#: ../doc/1.7/book/admin/server_introspection.rst:442
msgid "If you have any difficulties troubleshooting, let the script run for 10-15 seconds and then send the resulting ``stack-trace.txt`` file to the Tarantool team at support@tarantool.org."
msgstr "Если вам не удается отыскать причину пониженной производительности, запустите данный скрипт на 10-15 секунд и пришлите получившийся файл ``stack-trace.txt`` команде Tarantool’а на адрес support@tarantool.org."

#: ../doc/1.7/book/admin/server_introspection.rst:448
msgid "Use the poor man’s profilers with caution: each time they attach to a running process, this stops the process execution for about a second, which may leave a serious footprint in high-load services."
msgstr "Следует использовать ``pstack`` и ``gdb`` с осторожностью: каждый раз, подключаясь с работающему процессу, они приостанавливают выполнение этого  процесса приблизительно на одну секунду, что может иметь серьезные последствия для высоконагруженных сервисов."

#: ../doc/1.7/book/admin/server_introspection.rst:454
msgid "gperftools"
msgstr "gperftools"

#: ../doc/1.7/book/admin/server_introspection.rst:456
msgid "To use the CPU profiler from the Google Performance Tools suite with Tarantool, first take care of the prerequisites:"
msgstr "Чтобы использовать профилировщик процессора из набора Google Performance Tools с Tarantool’ом, необходимо сначала установить зависимости:"

#: ../doc/1.7/book/admin/server_introspection.rst:459
msgid "For Debian/Ubuntu, run:"
msgstr "Если вы используете Debian/Ubuntu, запустите эту команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:461
msgid "$ apt-get install libgoogle-perftools4"
msgstr "$ apt-get install libgoogle-perftools4"

#: ../doc/1.7/book/admin/server_introspection.rst:465
msgid "For RHEL/CentOS/Fedora, run:"
msgstr "Если вы используете RHEL/CentOS/Fedora, запустите эту команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:467
msgid "$ yum install gperftools-libs"
msgstr "$ yum install gperftools-libs"

#: ../doc/1.7/book/admin/server_introspection.rst:471
msgid "Once you do this, install Lua bindings:"
msgstr "После этого установите привязки для Lua:"

#: ../doc/1.7/book/admin/server_introspection.rst:473
msgid "$ tarantoolctl rocks install gperftools"
msgstr "$ tarantoolctl rocks install gperftools"

#: ../doc/1.7/book/admin/server_introspection.rst:477
msgid "Now you're ready to go. Enter your instance’s interactive administrator console:"
msgstr "После окончания установки войдите в интерактивную административную консоль вашего экземпляра Tarantool’а:"

#: ../doc/1.7/book/admin/server_introspection.rst:483
msgid "To start profiling, say:"
msgstr "Для запуска профилировщика выполните следующий код:"

#: ../doc/1.7/book/admin/server_introspection.rst:485
msgid ""
"tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<username>/tarantool-on-production.prof')"
msgstr ""
"tarantool> cpuprof = require('gperftools.cpu')\n"
"        tarantool> cpuprof.start('/home/<имя_пользователя>/tarantool-on-production.prof')"

#: ../doc/1.7/book/admin/server_introspection.rst:490
msgid "It takes at least a couple of minutes for the profiler to gather performance metrics. After that, save the results to disk (you can do that as many times as you need):"
msgstr "На сбор метрик производительности у профилировщика уходит по крайней мере  пара минут. По истечении этого времени можно сохранять информацию на диск (неограниченное количество раз):"

#: ../doc/1.7/book/admin/server_introspection.rst:494
msgid "tarantool> cpuprof.flush()"
msgstr "tarantool> cpuprof.flush()"

#: ../doc/1.7/book/admin/server_introspection.rst:498
msgid "To stop profiling, say:"
msgstr "Для остановки профилировщика выполните следующую команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:500
msgid "tarantool> cpuprof.stop()"
msgstr "tarantool> cpuprof.stop()"

#: ../doc/1.7/book/admin/server_introspection.rst:504
msgid "You can now analyze the output with the ``pprof`` utility that comes with the ``gperftools`` package:"
msgstr "Теперь можно проанализировать собранные данные с помощью утилиты ``pprof``, которая входит в пакет ``gperftools``:"

#: ../doc/1.7/book/admin/server_introspection.rst:507
msgid "$ pprof --text /usr/bin/tarantool /home/<username>/tarantool-on-production.prof"
msgstr "$ pprof --text /usr/bin/tarantool /home/<имя_пользователя>/tarantool-on-production.prof"

#: ../doc/1.7/book/admin/server_introspection.rst:513
msgid "On Debian/Ubuntu, the ``pprof`` utility is called ``google-pprof``."
msgstr "В дистрибутивах Debian/Ubuntu утилита ``pprof`` называется ``google-pprof``."

#: ../doc/1.7/book/admin/server_introspection.rst:515
msgid "Your output should look similar to this:"
msgstr "В консоль должно выводиться приблизительно следующее:"

#: ../doc/1.7/book/admin/server_introspection.rst:517
#, python-format
msgid ""
"Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"
msgstr ""
"Total: 598 samples\n"
"              83 13.9% 13.9% 83 13.9% epoll_wait\n"
"              54 9.0% 22.9% 102 17.1%\n"
"        vy_mem_tree_insert.constprop.35\n"
"              32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"              28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"              26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"              21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"              19 3.2% 44.0% 19 3.2%\n"
"        ::TupleCompareWithKey::compare\n"
"              19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"              12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"               9 1.5% 50.7% 9 1.5%\n"
"        ::TupleCompare::compare@42efc0\n"
"               9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"               9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"               8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"               6 1.0% 56.0% 25 4.2% gc_onestep\n"
"               6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"               5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"               5 0.8% 58.7% 131 21.9% vy_prepare"

#: ../doc/1.7/book/admin/server_introspection.rst:543
msgid "perf"
msgstr "perf"

#: ../doc/1.7/book/admin/server_introspection.rst:545
msgid "This tool for performance monitoring and analysis is installed separately via your package manager. Try running the ``perf`` command in the terminal and follow the prompts to install the necessary package(s)."
msgstr "Этот инструмент для мониторинга и анализа производительности устанавливается отдельно с помощью пакетного менеджера. Попробуйте ввести  в окне консоли команду ``perf`` и следуйте подсказкам, чтобы установить необходимые пакеты."

#: ../doc/1.7/book/admin/server_introspection.rst:551
msgid "By default, some ``perf`` commands are restricted to **root**, so, to be on the safe side, either run all commands as **root** or prepend them with ``sudo``."
msgstr "По умолчанию некоторые команды из пакета ``perf`` можно выполнять только с **root**-правами, поэтому необходимо либо зайти в систему из-под пользователя **root**, либо добавлять перед каждой командой ``sudo``."

#: ../doc/1.7/book/admin/server_introspection.rst:555
msgid "To start gathering performance statistics, say:"
msgstr "Чтобы начать сбор показателей производительности, выполните следующую команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:557
msgid "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"
msgstr "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"

#: ../doc/1.7/book/admin/server_introspection.rst:561
msgid "This command saves the gathered data to a file named ``perf.data`` inside the current working directory. To stop this process (usually, after 10-15 seconds), press **ctrl+C**. In your console, you’ll see:"
msgstr "Эта команда сохраняет собранные данные в файл ``perf.data``, который находится в текущей рабочей папке. Для остановки процесса (обычно через 10-15 секунд) нажмите **ctrl+C**. В консоли должно появиться следующее:"

#: ../doc/1.7/book/admin/server_introspection.rst:565
msgid ""
"^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"
msgstr ""
"^C[ perf record: Woken up 1 times to write data ]\n"
"        [ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"

#: ../doc/1.7/book/admin/server_introspection.rst:570
msgid "Now run the following command:"
msgstr "Затем выполните эту команду:"

#: ../doc/1.7/book/admin/server_introspection.rst:572
msgid "$ perf report -n -g --stdio | tee perf-report.txt"
msgstr "$ perf report -n -g --stdio | tee perf-report.txt"

#: ../doc/1.7/book/admin/server_introspection.rst:576
msgid "It formats the statistical data in the ``perf.data`` file into a performance report and writes it to the ``perf-report.txt`` file."
msgstr "Она превращает содержащиеся в ``perf.data`` статистические данные в отчет  о производительности, который сохраняется в файл ``perf-report.txt``."

#: ../doc/1.7/book/admin/server_introspection.rst:579
msgid "The resulting output should look similar to this:"
msgstr "Получившийся отчет выглядит следующим образом:"

#: ../doc/1.7/book/admin/server_introspection.rst:581
#, python-format
msgid ""
"# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. .......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"
msgstr ""
"# Samples: 14K of event 'cycles'\n"
"        # Event count (approx.): 9927346847\n"
"        #\n"
"        # Children Self Samples Command Shared Object Symbol\n"
"        # ........ ........ ............ ......... .................. .......................................\n"
"        #\n"
"            35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"                    |\n"
"                     --34.95%--lj_gc_step\n"
"                               |\n"
"                               |--29.26%--gc_onestep\n"
"                               | |\n"
"                               | |--13.85%--gc_sweep\n"
"                               | | |\n"
"                               | | |--5.59%--lj_alloc_free\n"
"                               | | |\n"
"                               | | |--1.33%--lj_tab_free\n"
"                               | | | |\n"
"                               | | | --1.01%--lj_alloc_free\n"
"                               | | |\n"
"                               | | --1.17%--lj_cdata_free\n"
"                               | |\n"
"                               | |--5.41%--gc_finalize\n"
"                               | | |\n"
"                               | | |--1.06%--lj_obj_equal\n"
"                               | | |\n"
"                               | | --0.95%--lj_tab_set\n"
"                               | |\n"
"                               | |--4.97%--rehashtab\n"
"                               | | |\n"
"                               | | --3.65%--lj_tab_resize\n"
"                               | | |\n"
"                               | | |--0.74%--lj_tab_set\n"
"                               | | |\n"
"                               | | --0.72%--lj_tab_newkey\n"
"                               | |\n"
"                               | |--0.91%--propagatemark\n"
"                               | |\n"
"                               | --0.67%--lj_cdata_free\n"
"                               |\n"
"                                --5.43%--propagatemark\n"
"                                          |\n"
"                                           --0.73%--gc_mark"

#: ../doc/1.7/book/admin/server_introspection.rst:627
msgid "Unlike the poor man’s profilers, ``gperftools`` and ``perf`` have low overhead (almost negligible as compared with ``pstack`` and ``gdb``): they don’t result in long delays when attaching to a process and therefore can be used without serious consequences."
msgstr "Инструменты ``gperftools`` и ``perf`` отличаются от ``pstack`` и ``gdb`` низкой затратой ресурсов (пренебрежимо малой по сравнению с ``pstack`` и ``gdb``): они подключаются к работающим процессам без больших задержек, а потому могут использоваться без серьезных последствий."

#: ../doc/1.7/book/admin/start_stop_instance.rst:5
msgid "Starting/stopping an instance"
msgstr "Запуск/остановка экземпляра"

#: ../doc/1.7/book/admin/start_stop_instance.rst:7
msgid "While a Lua application is executed by Tarantool, an instance file is executed by ``tarantoolctl`` which is a Tarantool script."
msgstr "Lua-приложение выполняется Tarantool'ом, тогда как файл экземпляра выполняется Tarantool-скриптом ``tarantoolctl``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:10
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr "Вот что делает ``tarantoolctl`` при вводе следующей команды:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:12
msgid "$ tarantoolctl start <instance_name>"
msgstr "$ tarantoolctl start <имя_экземпляра>"

#: ../doc/1.7/book/admin/start_stop_instance.rst:16
msgid "Read and parse the command line arguments. The last argument, in our case, contains an instance name."
msgstr "Считывает и разбирает аргументы командной строки. В нашем случае последний аргумент содержит имя экземпляра."

#: ../doc/1.7/book/admin/start_stop_instance.rst:19
msgid "Read and parse its own configuration file. This file contains ``tarantoolctl`` defaults, like the path to the directory where instances should be searched for."
msgstr "Считывает и разбирает собственный конфигурационный файл. Этот файл содержит параметры ``tarantoolctl`` по умолчанию — такие как путь до директории, в которой располагаются экземпляры."

#: ../doc/1.7/book/admin/start_stop_instance.rst:23
msgid "The default ``tarantoolctl`` configuration file is installed in ``/etc/default/tarantool``. This file is used when ``tarantoolctl`` is invoked by root. When invoked by a local user, ``tarantoolctl`` first looks for its defaults file in the current directory (``$PWD/.tarantoolctl``), and then in the current user’s home directory (``$HOME/.config/tarantool/tarantool``). If not found, ``tarantoolctl`` falls back to :ref:`built-in defaults <admin-tarantoolctl_config_file>`."
msgstr "Конфигурационный файл с параметрами ``tarantoolctl`` по умолчанию устанавливается в ``/etc/default/tarantool``. Этот файл используется, когда ``tarantoolctl`` вызывается с root-правами. Если вызов производит локальный пользователь, ``tarantoolctl`` сперва ищет свой файл с параметрами по умолчанию в текущей директории (``$PWD/.tarantoolctl``), затем в домашней директории текущего пользователя (``$HOME/.config/tarantool/tarantool``). Если файл не найден, ``tarantoolctl`` принимает :ref:`встроенные параметры по умолчанию <admin-tarantoolctl_config_file>`."

#: ../doc/1.7/book/admin/start_stop_instance.rst:31
msgid "Look up the instance file in the instance directory, e.g. ``/etc/tarantool/instances.enabled``. To build the instance file path, ``tarantoolctl`` takes the instance name, prepends the instance directory and appends \".lua\" extension to the instance file."
msgstr "Ищет файл экземпляра в директории, где располагаются экземпляры, -- например, в ``/etc/tarantool/instances.enabled``. ``tarantoolctl`` строит  путь до файла экземпляра следующим образом: \"путь до директории с экземплярами\" + \"имя экземпляра\" + \".lua\"."

#: ../doc/1.7/book/admin/start_stop_instance.rst:36
msgid "Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-process its parameters and ensure that instance paths are pointing to the paths defined in the ``tarantoolctl`` configuration file. For example, if the configuration file specifies that instance work directory must be in ``/var/tarantool``, then the new implementation of ``box.cfg{}`` ensures that :ref:`work_dir <cfg_basic-work_dir>` parameter in ``box.cfg{}`` is set to ``/var/tarantool/<instance_name>``, regardless of what the path is set to in the instance file itself."
msgstr "Переопределяет функцию :ref:`box.cfg{} <box_introspection-box_cfg>`, чтобы предобработать ее параметры и сделать так, чтобы пути к экземплярам  указывали на пути, прописанные в конфигурационном файле ``tarantoolctl``. Например, если в конфигурационном файле указано, что рабочей директорией экземпляра является ``/var/tarantool``, то новая реализация ``box.cfg{}`` сделает так, чтобы параметр :ref:`work_dir <cfg_basic-work_dir>` в ``box.cfg{}`` имел значение ``/var/tarantool/<имя_экземпляра>``, независимо от того, какой путь указан в самом файле экземпляра."

#: ../doc/1.7/book/admin/start_stop_instance.rst:45
msgid "Create a so-called \"instance control file\". This is a Unix socket with Lua console attached to it. This file is used later by ``tarantoolctl`` to query the instance state, send commands to the instance and so on."
msgstr "Создает так называемый \"файл для управления экземпляром\". Это Unix-сокет с прикрепленной к нему Lua-консолью. В дальнейшем ``tarantoolctl`` использует этот файл для получения состояния экземпляра,  отправки команд и т.д."

#: ../doc/1.7/book/admin/start_stop_instance.rst:49
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr "Наконец, использует Lua-команду ``dofile`` для выполнения файла экземпляра."

#: ../doc/1.7/book/admin/start_stop_instance.rst:51
msgid "If you start an instance using ``systemd`` tools, like this (the instance name is ``my_app``):"
msgstr "При запуске экземпляра с помощью инструментария ``systemd`` указанным ниже способом (имя экземпляра -- ``my_app``):"

#: ../doc/1.7/book/admin/start_stop_instance.rst:54
msgid ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool my_app.lua <running>"
msgstr ""
"$ systemctl start tarantool@my_app\n"
"        $ ps axuf|grep exampl[e]\n"
"        taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool my_app.lua <running>"

#: ../doc/1.7/book/admin/start_stop_instance.rst:60
msgid "... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl start my_app``."
msgstr "...на самом деле вызывается ``tarantoolctl`` -- так же, как и в случае ``tarantoolctl start my_app``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:63
msgid "To check the instance file for syntax errors prior to starting ``my_app`` instance, say:"
msgstr "Для проверки файла экземпляра на наличие синтаксических ошибок перед запуском экземпляра ``my_app`` используйте команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:66
msgid "$ tarantoolctl check my_app"
msgstr "$ tarantoolctl check my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:70
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr "Для включения автоматической загрузки экземпляра ``my_app`` при запуске всей системы используйте команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:72
msgid "$ systemctl enable tarantool@my_app"
msgstr "$ systemctl enable tarantool@my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:76
msgid "To stop a running ``my_app`` instance, say:"
msgstr "Для остановки работающего экземпляра ``my_app`` используйте команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:78
msgid ""
"$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""
"$ tarantoolctl stop my_app\n"
"        $ # - ИЛИ -\n"
"        $ systemctl stop tarantool@my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:84
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr "Для перезапуска (т.е. остановки и запуска) работающего экземпляра ``my_app`` используйте команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:86
msgid ""
"$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""
"$ tarantoolctl restart my_app\n"
"        $ # - ИЛИ -\n"
"        $ systemctl restart tarantool@my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:96
msgid "Running Tarantool locally"
msgstr "Локальный запуск Tarantool"

#: ../doc/1.7/book/admin/start_stop_instance.rst:98
msgid "Sometimes you may need to run a Tarantool instance locally, e.g. for test purposes. Let's configure a local instance, then start and monitor it with ``tarantoolctl``."
msgstr "Иногда бывает необходимо запустить Tarantool локально -- например, для тестирования. Давайте настроим локальный экземпляр, запустим его и будем мониторить с помощью ``tarantoolctl``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:102
msgid "First, we create a sandbox directory on the user's path:"
msgstr "Сперва создадим директорию-песочницу по следующему пути:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:104
msgid "$ mkdir ~/tarantool_test"
msgstr "$ mkdir ~/tarantool_test"

#: ../doc/1.7/book/admin/start_stop_instance.rst:108
msgid "... and set default ``tarantoolctl`` configuration in ``$HOME/.config/tarantool/tarantool``. Let the file contents be:"
msgstr "...и поместим конфигурационный файл с параметрами ``tarantoolctl`` по умолчанию в ``$HOME/.config/tarantool/tarantool``. Содержимое файла будет  таким:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:111
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""
"default_cfg = {\n"
"            pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"            wal_dir   = \"/home/user/tarantool_test\",\n"
"            snap_dir  = \"/home/user/tarantool_test\",\n"
"            vinyl_dir = \"/home/user/tarantool_test\",\n"
"            log       = \"/home/user/tarantool_test/log\",\n"
"        }\n"
"        instance_dir = \"/home/user/tarantool_test\""

#: ../doc/1.7/book/admin/start_stop_instance.rst:124
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr "Указывайте полный путь к домашней директории пользователя вместо \"~/\"."

#: ../doc/1.7/book/admin/start_stop_instance.rst:126
msgid "Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have permissions to switch current user when invoked by a local user. The instance will be running under 'admin'."
msgstr "Опустите параметр ``username``. Обычно, когда запуск производит локальный  пользователь, у ``tarantoolctl`` нет разрешения на смену текущего пользователя. Экземпляр будет работать с пользователем 'admin'."

#: ../doc/1.7/book/admin/start_stop_instance.rst:130
msgid "Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let the file contents be:"
msgstr "Далее создадим файл экземпляра ``~/tarantool_test/my_app.lua``. Содержимое файла будет таким:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:133
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"        box.schema.user.passwd('Gx5!')\n"
"        box.schema.user.grant('guest','read,write,execute','universe')\n"
"        fiber = require('fiber')\n"
"        box.schema.space.create('tester')\n"
"        box.space.tester:create_index('primary',{})\n"
"        i = 0\n"
"        while 0 == 0 do\n"
"            fiber.sleep(5)\n"
"            i = i + 1\n"
"            print('insert ' .. i)\n"
"            box.space.tester:insert{i, 'my_app tuple'}\n"
"        end"

#: ../doc/1.7/book/admin/start_stop_instance.rst:149
msgid "Let’s verify our instance file by starting it without ``tarantoolctl`` first:"
msgstr "Проверим наш файл экземпляра, сперва запустив его без ``tarantoolctl``:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:151
msgid ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version 1.7.3-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""
"$ cd ~/tarantool_test\n"
"        $ tarantool my_app.lua\n"
"        2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version 1.7.3-489-gd86e36d5b\n"
"        2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"        2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 bytes for tuple arena...\n"
"        2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to [::]:3301\n"
"        2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an empty data directory\n"
"        2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"        2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"        2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint done\n"
"        2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept requests\n"
"        insert 1\n"
"        insert 2\n"
"        insert 3\n"
"        <...>"

#: ../doc/1.7/book/admin/start_stop_instance.rst:169
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr "Запустим экземпляр Tarantool'а с помощью ``tarantoolctl``:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:171
msgid "$ tarantoolctl start my_app"
msgstr "$ tarantoolctl start my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:175
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr "В консоли должны появиться сообщения о том, что экземпляр запущен. Затем выполним следующую команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:177
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr "$ ls -l ~/tarantool_test/my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:181
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr "В консоли должны появиться .snap-файл и .xlog-файл. Затем выполним следующую команду:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:183
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr "$ less ~/tarantool_test/log/my_app.log"

#: ../doc/1.7/book/admin/start_stop_instance.rst:187
msgid "Expect to see the contents of ``my_app``‘s log, including error messages, if any. Then:"
msgstr "В консоли должно отобразиться содержимое файла журнала для приложения ``my_app``, в том числе сообщения об ошибках, если они были. Затем выполним серию команд:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:190
msgid ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ tarantoolctl enter my_app\n"
"        tarantool> box.cfg{}\n"
"        tarantool> console = require('console')\n"
"        tarantool> console.connect('localhost:3301')\n"
"        tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../doc/1.7/book/admin/start_stop_instance.rst:198
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr "В консоли должны появиться несколько кортежей, которые создало приложение  ``my_app``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:200
msgid "Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus we say:"
msgstr "Теперь остановим приложение ``my_app``. Корректный способ остановки -- это  использовать``tarantoolctl``:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:202
msgid "$ tarantoolctl stop my_app"
msgstr "$ tarantoolctl stop my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:206
msgid "Finally, we make a cleanup."
msgstr "Последний шаг -- удаление тестовых данных."

#: ../doc/1.7/book/admin/start_stop_instance.rst:208
msgid "$ rm -R tarantool_test"
msgstr "$ rm -R tarantool_test"

#: ../doc/1.7/book/admin/troubleshoot.rst:5
msgid "Troubleshooting guide"
msgstr "Руководство по разрешению проблем"

#: ../doc/1.7/book/admin/troubleshoot.rst:7
msgid "For this guide, you need to install Tarantool `stat <https://github.com/tarantool/stat>`_ module:"
msgstr "В данном руководстве используется сторонний модуль `stat <https://github.com/tarantool/stat>`_. Для его установки выполните команду:"

#: ../doc/1.7/book/admin/troubleshoot.rst:10
msgid ""
"$ sudo yum install tarantool-stat\n"
"$ # -- OR --\n"
"$ sudo apt-get install tarantool-stat"
msgstr ""
"$ sudo yum install tarantool-stat\n"
"        $ # -- ИЛИ --\n"
"        $ sudo apt-get install tarantool-stat"

#: ../doc/1.7/book/admin/troubleshoot.rst:20
msgid "Problem: INSERT/UPDATE-requests result in ER_MEMORY_ISSUE error"
msgstr "Проблема: при выполнении INSERT/UPDATE-запросов возникает ошибка ER_MEMORY_ISSUE"

#: ../doc/1.7/book/admin/troubleshoot.rst:22
#: ../doc/1.7/book/admin/troubleshoot.rst:79
#: ../doc/1.7/book/admin/troubleshoot.rst:125
#: ../doc/1.7/book/admin/troubleshoot.rst:187
#: ../doc/1.7/book/admin/troubleshoot.rst:210
#: ../doc/1.7/book/admin/troubleshoot.rst:235
#: ../doc/1.7/book/admin/troubleshoot.rst:252
#: ../doc/1.7/book/admin/troubleshoot.rst:287
msgid "**Possible reasons**"
msgstr "**Возможные причины**"

#: ../doc/1.7/book/admin/troubleshoot.rst:24
msgid "Lack of RAM (parameters ``arena_used_ratio`` and ``quota_used_ratio`` in :ref:`box.slab.info() <box_slab_info>` report are getting close to 100%)."
msgstr "Нехватка памяти (значения параметров ``arena_used_ratio`` и ``quota_used_ratio`` из  :ref:`box.slab.info() <box_slab_info>` приближаются к 100%)."

#: ../doc/1.7/book/admin/troubleshoot.rst:27
msgid "To check these parameters, say:"
msgstr "Чтобы проверить значения данных параметров, выполните соответствующие команды:"

#: ../doc/1.7/book/admin/troubleshoot.rst:29
#: ../doc/1.7/book/admin/troubleshoot.rst:90
#: ../doc/1.7/book/admin/troubleshoot.rst:147
#: ../doc/1.7/book/admin/troubleshoot.rst:264
#: ../doc/1.7/book/admin/troubleshoot.rst:300
msgid ""
"$ # attaching to a Tarantool instance\n"
"$ tarantoolctl enter <instance_name>\n"
"$ # -- OR --\n"
"$ tarantoolctl connect <URI>"
msgstr ""
"$ # подключаемся к админ-консоли нужного экземпляра Tarantool\n"
"        $ tarantoolctl enter <instance_name>\n"
"        $ # -- ИЛИ --\n"
"        $ tarantoolctl connect <URI>"

#: ../doc/1.7/book/admin/troubleshoot.rst:36
msgid ""
"-- requesting arena_used_ratio value\n"
"tarantool> require('stat').stat()['slab.arena_used_ratio']\n"
"\n"
"-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']"
msgstr ""
"-- запрашиваем значение arena_used_ratio value\n"
"        tarantool> require('stat').stat()['slab.arena_used_ratio']\n"
"        \n"
"        -- запрашиваем значение quota_used_ratio value\n"
"        tarantool> require('stat').stat()['slab.quota_used_ratio']"

#: ../doc/1.7/book/admin/troubleshoot.rst:44
#: ../doc/1.7/book/admin/troubleshoot.rst:84
#: ../doc/1.7/book/admin/troubleshoot.rst:135
#: ../doc/1.7/book/admin/troubleshoot.rst:168
#: ../doc/1.7/book/admin/troubleshoot.rst:192
#: ../doc/1.7/book/admin/troubleshoot.rst:215
#: ../doc/1.7/book/admin/troubleshoot.rst:239
#: ../doc/1.7/book/admin/troubleshoot.rst:260
#: ../doc/1.7/book/admin/troubleshoot.rst:291
msgid "**Solution**"
msgstr "**Решение**"

#: ../doc/1.7/book/admin/troubleshoot.rst:46
#: ../doc/1.7/book/admin/troubleshoot.rst:137
msgid "Try either of the following measures:"
msgstr "У вас есть несколько вариантов действий:"

#: ../doc/1.7/book/admin/troubleshoot.rst:48
msgid "In Tarantool's :ref:`instance file <admin-instance_config>`, increase the value of :ref:`box.cfg{memtx_memory} <cfg_storage-memtx_memory>` (if memory resources are available)."
msgstr "Зайти в :ref:`конфигурационный файл <admin-instance_config>` Tarantool и увеличить значение параметра :ref:`box.cfg{memtx_memory} <cfg_storage-memtx_memory>` (при наличии свободных ресурсов)."

#: ../doc/1.7/book/admin/troubleshoot.rst:52
msgid "Tarantool needs to be restarted to change this parameter. The Tarantool server will be unavailable while restarting from .xlog files, unless you restart it using :ref:`hot standby <index-hot_standby>` mode. In the latter case, nearly 100% server availability is guaranteed."
msgstr "Для изменения данного параметра требуется перезагрузить Tarantool. При обычной перезагрузке сервер будет недоступен на время старта Tarantool из  .xlog-файлов. При перезагрузке в режиме :ref:`hot standby <index-hot_standby>` гарантирована практически 100-процентная доступность."

#: ../doc/1.7/book/admin/troubleshoot.rst:57
msgid "Clean up the database."
msgstr "Провести очистку базы данных."

#: ../doc/1.7/book/admin/troubleshoot.rst:59
msgid "Check the indicators of memory fragmentation:"
msgstr "Проверьте, нет ли проблем с фрагментацией памяти:"

#: ../doc/1.7/book/admin/troubleshoot.rst:61
msgid ""
"-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']\n"
"\n"
"-- requesting items_used_ratio value\n"
"tarantool> require('stat').stat()['slab.items_used_ratio']"
msgstr ""
"-- запрашиваем значение quota_used_ratio value\n"
"        tarantool> require('stat').stat()['slab.quota_used_ratio']\n"
"        \n"
"        -- запрашиваем значение items_used_ratio value\n"
"        tarantool> require('stat').stat()['slab.items_used_ratio']"

#: ../doc/1.7/book/admin/troubleshoot.rst:69
msgid "In case of heavy memory fragmentation (``quota_used_ratio`` is getting close to 100%, ``items_used_ratio`` is about 50%), we recommend restarting Tarantool in the :ref:`hot standby <index-hot_standby>` mode."
msgstr "При высокой степени фрагментации памяти (значение параметра ``quota_used_ratio`` приближается к 100%, ``items_used_ratio`` около 50%)  рекомендуется перезапустить Tarantool в режиме :ref:`hot standby <index-hot_standby>`."

#: ../doc/1.7/book/admin/troubleshoot.rst:77
msgid "Problem: Tarantool generates too heavy CPU load"
msgstr "Проблема: Tarantool создает большую нагрузку на CPU"

#: ../doc/1.7/book/admin/troubleshoot.rst:81
msgid "The :ref:`transaction processor thread <atomic-threads_fibers_yields>` consumes over 60% CPU."
msgstr ":ref:`Поток обработки транзакций <atomic-threads_fibers_yields>` нагружает ЦП более чем на 60%."

#: ../doc/1.7/book/admin/troubleshoot.rst:86
msgid "Attach to the Tarantool instance with :ref:`tarantoolctl <tarantoolctl>` utility, analyze the query statistics with :ref:`box.stat() <box_introspection-box_stat>` and spot the CPU consumption leader. The following commands can help:"
msgstr "Подключиться к Tarantool с помощью утилиты :ref:`tarantoolctl <tarantoolctl>`, внимательно изучить статистику запросов с помощью :ref:`box.stat() <box_introspection-box_stat>` и выявить источник потребления. Для этой цели могут оказаться полезными следующие команды:"

#: ../doc/1.7/book/admin/troubleshoot.rst:97
msgid ""
"-- checking the RPS of calling stored procedures\n"
"tarantool> require('stat').stat()['stat.op.call.rps']"
msgstr ""
"-- запрашиваем RPS для вызовов хранимых процедур\n"
"        tarantool> require('stat').stat()['stat.op.call.rps']"

#: ../doc/1.7/book/admin/troubleshoot.rst:102
msgid "The critical RPS value is 75 000, boiling down to 10 000 - 20 000 for a rich Lua application (a Lua module of 200+ lines)."
msgstr "Критическое значение RPS — 75 000, в случае большого Lua-приложения (модульного приложения, содержащего более 200 строк кода) — 10 000 - 20 000."

#: ../doc/1.7/book/admin/troubleshoot.rst:105
msgid ""
"-- checking RPS per query type\n"
"tarantool> require('stat').stat()['stat.op.<query_type>.rps']"
msgstr ""
"-- запрашиваем RPS для запросов указанного типа\n"
"        tarantool> require('stat').stat()['stat.op.<query_type>.rps']"

#: ../doc/1.7/book/admin/troubleshoot.rst:110
msgid "The critical RPS value for SELECT/INSERT/UPDATE/DELETE requests is 100 000."
msgstr "Критическое значение RPS для запросов типа SELECT/INSERT/UPDATE/DELETE — 100 000."

#: ../doc/1.7/book/admin/troubleshoot.rst:112
msgid "If the load is mostly generated by SELECT requests, we recommend adding a :ref:`slave server <replication-bootstrap>` and let it process part of the queries."
msgstr "Если основная нагрузка генерируется SELECT-запросами, следует добавить :ref:`slave-сервер <replication-bootstrap>` и часть запросов обрабатывать  на нем."

#: ../doc/1.7/book/admin/troubleshoot.rst:116
msgid "If the load is mostly generated by INSERT/UPDATE/DELETE requests, we recommend :ref:`sharding the database <shard-module>`."
msgstr "Если же нагрузка по большей части приходится на INSERT/UPDATE/DELETE-запросы, рекомендуется провести :ref:`шардинг базы данных <shard-module>`."

#: ../doc/1.7/book/admin/troubleshoot.rst:123
msgid "Problem: Query processing times out"
msgstr "Проблема: обработка запросов прекращается по таймауту"

#: ../doc/1.7/book/admin/troubleshoot.rst:129
msgid "All reasons that we discuss here can be identified by messages in Tarantool's log file, all starting with the words ``'Too long...'``."
msgstr "Все описанные ниже ситуации можно распознать по записям в журнале Tarantool, начинающимся со слов ``'Too long...'``."

#: ../doc/1.7/book/admin/troubleshoot.rst:132
msgid "Both fast and slow queries are processed within a single connection, so the readahead buffer is cluttered with slow queries."
msgstr "Быстрые и медленные запросы обрабатываются в одном подключении, что приводит к забиванию readahead-буфера медленными запросами."

#: ../doc/1.7/book/admin/troubleshoot.rst:139
msgid "Increase the readahead buffer size (:ref:`box.cfg{readahead} <cfg_networking-readahead>` parameter)."
msgstr "Увеличить размер readahead-буфера (:ref:`box.cfg{readahead} <cfg_networking-readahead>`)."

#: ../doc/1.7/book/admin/troubleshoot.rst:142
msgid "This parameter can be changed on the fly, so you don't need to restart Tarantool. Attach to the Tarantool instance with :ref:`tarantoolctl <tarantoolctl>` utility and call ``box.cfg{}`` with a new ``readahead`` value:"
msgstr "Перезапускать Tarantool при этом не требуется. Для обновления конфигурации необходимо подключиться к Tarantool с помощью утилиты :ref:`tarantoolctl <tarantoolctl>` и передать в ``box.cfg{}`` новое значение параметра ``readahead``:"

#: ../doc/1.7/book/admin/troubleshoot.rst:154
msgid ""
"-- changing the readahead value\n"
"tarantool> box.cfg{readahead = 10 * 1024 * 1024}"
msgstr ""
"-- задаем новое значение readahead\n"
"        tarantool> box.cfg{readahead = 10 * 1024 * 1024}"

#: ../doc/1.7/book/admin/troubleshoot.rst:159
msgid "**Example:** Given 1000 RPS, 1 Кbyte of query size, and 10 seconds of maximal query processing time, the minimal readahead buffer size must be 10 Mbytes."
msgstr "**Пример расчета:** при 1000 RPS, размере одного запроса в 1 Кбайт и максимальном времени обработки одного запроса в 10 секунд минимальный размер readahead-буфера должен равняться 10 Мбайт."

#: ../doc/1.7/book/admin/troubleshoot.rst:163
msgid "On the business logic level, split fast and slow queries processing by different connections."
msgstr "Обрабатывать быстрые и медленные запросы в отдельных подключениях (решается на уровне бизнес-логики)."

#: ../doc/1.7/book/admin/troubleshoot.rst:166
msgid "Slow disks."
msgstr "Медленная работа дисков."

#: ../doc/1.7/book/admin/troubleshoot.rst:170
msgid "Check disk performance (use `iostat <https://linux.die.net/man/1/iostat>`_, `iotop <https://linux.die.net/man/1/iotop>`_ or `strace <https://linux.die.net/man/1/strace>`_ utility to check ``iowait`` parameter) and try to put .xlog files and snapshot files on different physical disks (i.e. use different locations for :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>`)."
msgstr "Проверить занятость дисков (с помощью утилиты `iostat <https://linux.die.net/man/1/iostat>`_, `iotop <https://linux.die.net/man/1/iotop>`_ или `strace <https://linux.die.net/man/1/strace>`_ посмотреть на параметр ``iowait``)  и попробовать разнести .xlog-файлы и снимки состояния базы данных по разным дискам (т.е. указать разные значения для параметров  :ref:`wal_dir  <cfg_basic-wal_dir>` и :ref:`memtx_dir <cfg_basic-memtx_dir>`)."

#: ../doc/1.7/book/admin/troubleshoot.rst:181
msgid "Problem: Replication \"lag\" and \"idle\" contain negative values"
msgstr "Проблема: параметры репликации lag и idle принимают отрицательные значения"

#: ../doc/1.7/book/admin/troubleshoot.rst:183
msgid "This is about ``box.info.replication.(upstream.)lag`` and ``box.info.replication.(upstream.)idle`` values in :ref:`box.info.replication <box_info_replication>` section."
msgstr "Речь идет о параметрах ``box.info.replication.(upstream.)lag`` и ``box.info.replication.(upstream.)idle`` из сводной таблицы :ref:`box.info.replication <box_info_replication>`."

#: ../doc/1.7/book/admin/troubleshoot.rst:189
msgid "Operating system clock on the hosts is not synchronized, or the NTP server is faulty."
msgstr "Не синхронизированы часы на машинах или  неправильно работает NTP-сервер."

#: ../doc/1.7/book/admin/troubleshoot.rst:194
msgid "Check NTP server settings."
msgstr "Проверить настройки NTP-сервера."

#: ../doc/1.7/book/admin/troubleshoot.rst:196
msgid "If you found no problems with the NTP server, just do nothing then. Lag calculation uses operating system clock from two different machines. If they get out of sync, the remote master clock can get consistently behind the local instance’s clock."
msgstr "Если проблем с NTP-сервером не обнаружено, то не следует ничего предпринимать, потому что при вычислении лага репликации используются показания системных часов на двух разных машинах, и в случае рассинхронизации может случиться так, что часы удаленного мастер-сервера всегда будут отставать от часов локального экземпляра Tarantool."

#: ../doc/1.7/book/admin/troubleshoot.rst:205
msgid "Problem: Replication \"idle\" keeps growing, but no related log messages appear"
msgstr "Проблема: значение параметра idle растет, но журнал не содержит связанных  с этим сообщений"

#: ../doc/1.7/book/admin/troubleshoot.rst:207
msgid "This is about ``box.info.replication.(upstream.)idle`` value in :ref:`box.info.replication <box_info_replication>` section."
msgstr "Речь идет о параметре ``box.info.replication.(upstream.)idle`` из сводной  таблицы :ref:`box.info.replication <box_info_replication>`."

#: ../doc/1.7/book/admin/troubleshoot.rst:212
msgid "Some server was assigned different IP addresses, or some server was specified twice in ``box.cfg{}``, so duplicate connections were established."
msgstr "Одному серверу были назначены различные IP-адреса или один и тот же сервер был указан в ``box.cfg{}`` дважды, что привело к установлению дублирующего подключения."

#: ../doc/1.7/book/admin/troubleshoot.rst:217
msgid ":ref:`Upgrade Tarantool 1.6 to 1.7 <admin-upgrades_instance>`, where this error is fixed: in case of duplicate connections, replication is stopped and the following message is added to the log: ``'Incorrect value for option ''replication_source'': duplicate connection with the same replica UUID'``."
msgstr ":ref:`Обновить Tarantool 1.6 до 1.7 <admin-upgrades_instance>`, где эта ошибка была исправлена: в описанной ситуации репликация будет остановлена, а в журнал будет записана следующая ошибка: ``'Incorrect value for option ''replication_source'': duplicate connection with the same replica UUID'``."

#: ../doc/1.7/book/admin/troubleshoot.rst:227
msgid "Problem: Replication statistics differ on replicas within a replica set"
msgstr "Проблема: общие параметры репликации не совпадают на репликах в рамках одного кластера"

#: ../doc/1.7/book/admin/troubleshoot.rst:229
msgid "This is about a replica set that consists of one master and several replicas. In a replica set of this type, values in :ref:`box.info.replication <box_info_replication>` section, like ``box.info.replication.lsn``, come from the master and must be the same on all replicas within the replica set. The problem is that they get different."
msgstr "Речь идет о кластере, состоящем из одного мастера и нескольких реплик. В таком случае значения общих параметров из сводной таблицы :ref:`box.info.replication <box_info_replication>`, например ``box.info.replication.lsn``, должны приходить с мастера и должны быть одинаковыми на всех репликах. Если такие параметры не совпадают, это свидетельствует о наличии проблем."

#: ../doc/1.7/book/admin/troubleshoot.rst:237
msgid "Replication is broken."
msgstr "Сбой репликации."

#: ../doc/1.7/book/admin/troubleshoot.rst:241
msgid ":ref:`Restart replication <replication-recover>`."
msgstr ":ref:`Перезапустить репликацию <replication-recover>`."

#: ../doc/1.7/book/admin/troubleshoot.rst:247
msgid "Problem: Master-master replication is stopped"
msgstr "Проблема: репликация мастер-мастер остановлена"

#: ../doc/1.7/book/admin/troubleshoot.rst:249
msgid "This is about :ref:`box.info.replication(.upstream).status <box_info_replication>` = stopped."
msgstr "Речь идет о том, что параметр :ref:`box.info.replication(.upstream).status <box_info_replication>` имеет значение stopped."

#: ../doc/1.7/book/admin/troubleshoot.rst:254
msgid "In a master-master replica set of two Tarantool instances, one of the masters has tried to perform an action already performed by the other server, for example re-insert a tuple with the same unique key. This would cause an error message like ``'Duplicate key exists in unique index 'primary' in space <space_name>'``."
msgstr "В репликационном кластере, состоящем из двух мастер-серверов, один из серверов попытался выполнить действие, уже выполненное другим сервером, -- например, повторно вставить кортеж с таким же уникальным ключом (распознается по ошибке вида ``'Duplicate key exists in unique index 'primary' in space <space_name>'``)."

#: ../doc/1.7/book/admin/troubleshoot.rst:262
msgid "Restart replication with the following commands (at each master instance):"
msgstr "Возобновить репликацию с помощью следующих команд (должны быть выполнены на всех мастер-серверах):"

#: ../doc/1.7/book/admin/troubleshoot.rst:271
msgid ""
"-- restarting replication\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""
"-- перезапускаем репликацию\n"
"        tarantool> original_value = box.cfg.replication\n"
"        tarantool> box.cfg{replication={}}\n"
"        tarantool> box.cfg{replication=original_value}"

#: ../doc/1.7/book/admin/troubleshoot.rst:278
msgid "We also recommend using text primary keys or setting up :ref:`master-slave replication <replication-master_replica_bootstrap>`."
msgstr "Также рекомендуется перейти на текстовые первичные ключи или настроить :ref:`репликацию мастер-реплика <replication-master_replica_bootstrap>`."

#: ../doc/1.7/book/admin/troubleshoot.rst:285
msgid "Problem: Tarantool works much slower than before"
msgstr "Проблема: Tarantool работает заметно медленнее, чем раньше"

#: ../doc/1.7/book/admin/troubleshoot.rst:289
msgid "Inefficient memory usage (RAM is cluttered with a huge amount of unused objects)."
msgstr "Неэффективное использование памяти (память занята большим количеством неиспользуемых объектов)."

#: ../doc/1.7/book/admin/troubleshoot.rst:293
msgid "Call the Lua function `collectgarbage('count') <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_ and measure its execution time with Tarantool functions :ref:`clock.bench() <clock-bench>` or :ref:`clock.proc() <clock-proc>`."
msgstr "Запустить функцию `collectgarbage(count) <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_ и измерить время ее выполнения с помощью :ref:`clock.bench() <clock-bench>`  или :ref:`clock.proc() <clock-proc>`."

#: ../doc/1.7/book/admin/troubleshoot.rst:298
msgid "Example of calculating memory usage statistics:"
msgstr "Пример кода для подсчета потребляемой памяти:"

#: ../doc/1.7/book/admin/troubleshoot.rst:307
msgid ""
"-- loading Tarantool's \"clock\" module with time-related routines\n"
"tarantool> local clock = require 'clock'\n"
"-- starting the timer\n"
"tarantool> local b = clock.proc()\n"
"-- launching garbage collection\n"
"tarantool> local c = collectgarbage('count')\n"
"-- stopping the timer after garbage collection is completed\n"
"tarantool> return c, clock.proc() - b"
msgstr ""
"-- lзагрузка модуля clock для работы со временем\n"
"        tarantool> local clock = require 'clock'\n"
"        -- запускаем таймер\n"
"        tarantool> local b = clock.proc()\n"
"        -- запускаем сборку мусора\n"
"        tarantool> local c = collectgarbage('count')\n"
"        -- останавливаем таймер по завершении сборки мусора\n"
"        tarantool> return c, clock.proc() - b"

#: ../doc/1.7/book/admin/troubleshoot.rst:318
msgid "If the returned ``clock.proc()`` value is greater than 0.001, this may be an indicator of inefficient memory usage (no active measures are required, but we recommend to optimize your Tarantool application code)."
msgstr "Если возвращаемое ``clock.proc()`` значение больше 0.001, это может являться признаком неэффективного использования памяти (активного вмешательства не требуется, но рекомендуется оптимизация кода). Если значение превышает 0.01, необходимо провести подробный анализ кода и оптимизировать потребление памяти."

#: ../doc/1.7/book/admin/troubleshoot.rst:322
msgid "If the value is greater than 0.01, your application definitely needs thorough code analysis aimed at optimizing memory usage."
msgstr "Если значение больше 0,01, код приложения однозначно необходимо проанализировать на предмет оптимизации использования памяти."

#: ../doc/1.7/book/admin/upgrades.rst:5
msgid "Upgrades"
msgstr "Обновление"

#: ../doc/1.7/book/admin/upgrades.rst:11
msgid "Upgrading a Tarantool database"
msgstr "Обновление базы данных Tarantool"

#: ../doc/1.7/book/admin/upgrades.rst:13
msgid "If you created a database with an older Tarantool version and have now installed a newer version, make the request ``box.schema.upgrade()``. This updates Tarantool system spaces to match the currently installed version of Tarantool."
msgstr "Если вы создали базу данных в старой версии Tarantool'а, а потом обновили  Tarantool до более свежей версии, вызовите команду ``box.schema.upgrade()``. Она обновляет системные спейсы Tarantool'а так,  чтобы они совпадали с текущей установленной версией Tarantool'а."

#: ../doc/1.7/book/admin/upgrades.rst:17
msgid "For example, here is what happens when you run ``box.schema.upgrade()`` with a database created with Tarantool version 1.6.4 to version 1.7.2 (only a small part of the output is shown):"
msgstr "Например, вот что происходит, если выполнить команду ``box.schema.upgrade()`` для базы данных, созданной в Tarantool версии 1.6.4 (показана лишь малая часть выводимых сообщений):"

#: ../doc/1.7/book/admin/upgrades.rst:21
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"        alter index primary on _space set options to {\"unique\":true}, parts to [[0,\"unsigned\"]]\n"
"        alter space _schema set options to {}\n"
"        create view _vindex...\n"
"        grant read access to 'public' role for _vindex view\n"
"        set schema version to 1.7.0\n"
"        ---\n"
"        ..."

#: ../doc/1.7/book/admin/upgrades.rst:36
msgid "Upgrading a Tarantool instance"
msgstr "Обновление экземпляра Tarantool'а"

#: ../doc/1.7/book/admin/upgrades.rst:38
msgid "Tarantool is backward compatible between two adjacent versions. For example, you should have no or little trouble when upgrading from Tarantool 1.6 to 1.7, or from Tarantool 1.7 to 1.8. Meanwhile Tarantool 1.8 may have incompatible changes when migrating from Tarantool 1.6. to 1.8 directly."
msgstr "Tarantool поддерживает обратную совместимость между двумя последовательными версиями. Например, обновление Tarantool 1.6 до 1.7 или  Tarantool 1.7 до 1.8 не должно вызвать затруднений, тогда как миграции с  Tarantool 1.6 прямиком на 1.8 могут препятствовать несовместимые изменения."

#: ../doc/1.7/book/admin/upgrades.rst:45
msgid "How to upgrade from Tarantool 1.6 to 1.7"
msgstr "Как обновить Tarantool 1.6 до 1.7"

#: ../doc/1.7/book/admin/upgrades.rst:47
msgid "This procedure is for upgrading a standalone Tarantool instance in production from 1.6.x to 1.7.x (or to 1.9.x, which is actually the renamed 1.7 series). Notice that this will **always imply a downtime**. To upgrade **without downtime**, you need several Tarantool servers running in a replication cluster (see :ref:`below <admin-upgrades_replication_cluster>`)."
msgstr "Этот процесс предназначен для обновления индивидуальных экземпляров Tarantool'а с 1.6.х до 1.7.х (или до 1.9.x, которая на самом деле — переименованная серия 1.7) на боевом сервере. Обратите внимание, что это **всегда приводит к некоторому простою**. Для обновления **без простоев** необходимо, чтобы несколько работающих Tarantool-серверов были объединены в репликационный кластер (см. :ref:`ниже <admin-upgrades_replication_cluster>`)."

#: ../doc/1.7/book/admin/upgrades.rst:54
msgid "Tarantool 1.7 has an incompatible :ref:`.snap <internals-snapshot>` and :ref:`.xlog <internals-wal>` file format: 1.6 files are supported during upgrade, but you won’t be able to return to 1.6 after running under 1.7 for a while. It also renames a few configuration parameters, but old parameters are supported. The full list of breaking changes is available in `release notes for Tarantool 1.7 / 1.9 <https://github.com/tarantool/tarantool/releases>`_."
msgstr "Tarantool 1.7 работает с несовместимыми форматами файлов -- :ref:`.snap <internals-snapshot>` и :ref:`.xlog <internals-wal>`. Файлы Tarantool'а 1.6 поддерживаются при обновлении, но после непродолжительного использования Tarantool'а 1.7 вернуться к 1.6 уже нельзя. Также были переименованы некоторые конфигурационные параметры, но старые параметры еще поддерживаются. Список критических изменений доступен в `Release notes для Tarantool'а 1.7 <https://github.com/tarantool/tarantool/releases>`_."

#: ../doc/1.7/book/admin/upgrades.rst:61
msgid "To upgrade from Tarantool 1.6 to 1.7 (or to 1.9.x, which is actually the renamed 1.7 series):"
msgstr "Чтобы обновить Tarantool 1.6 до 1.7 (или до 1.9.x, которая на самом деле — переименованная серия 1.7):"

#: ../doc/1.7/book/admin/upgrades.rst:64
msgid "Check with application developers whether application files need to be updated due to incompatible changes (see `1.7 / 1.9 release notes <https://github.com/tarantool/tarantool/releases>`_). If yes, back up the old application files."
msgstr "Уточните у разработчиков, необходимо ли обновлять файлы приложения из-за наличия несовместимых изменений (см. `Release notes для Tarantool'а 1.7 / 1.9 <https://github.com/tarantool/tarantool/releases>`_). Если да, то создайте резервные копии старых файлов приложения."

#: ../doc/1.7/book/admin/upgrades.rst:69
msgid "Stop the Tarantool server."
msgstr "Остановите Tarantool-сервер."

#: ../doc/1.7/book/admin/upgrades.rst:71
msgid "Make a copy of all data (see an appropriate hot backup procedure in :ref:`Backups <admin-backups>`) and the package from which the current (old) version was installed (for rollback purposes)."
msgstr "Создайте копию всех данных (см. подразделы про горячее резервное копирование в разделе :ref:`Резервное копирование <admin-backups>`) и пакета, из которого была установлена текущая (старая) версия (на случай отката)."

#: ../doc/1.7/book/admin/upgrades.rst:75
msgid "Update the Tarantool server. See installation instructions at Tarantool `download page <http://tarantool.org/download.html>`_."
msgstr "Обновите Tarantool-сервер. Инструкции по установке доступны на `странице загрузок Tarantool'а <http://tarantool.org/download.html>`_."

#: ../doc/1.7/book/admin/upgrades.rst:78
msgid "Update the Tarantool database. Put the request ``box.schema.upgrade()`` inside a :ref:`box.once() <box-once>` function in your Tarantool :ref:`initialization file <index-init_label>`. On startup, this will create new system spaces, update data type names (e.g. num -> unsigned, str -> string) and options in Tarantool system spaces."
msgstr "Обновите базу данных Tarantool. Выполните команду ``box.schema.upgrade()``, поместив ее внутрь функции :ref:`box.once() <box-once>` в :ref:`файле инициализации <index-init_label>` Tarantool'а. В результате на этапе запуска Tarantool создаст новые системные спейсы, обновит названия типов данных (например, num -> unsigned, str -> string) и список доступных типов данных в системных спейсах."

#: ../doc/1.7/book/admin/upgrades.rst:84
msgid "Update application files, if needed."
msgstr "При необходимости обновите файлы приложения."

#: ../doc/1.7/book/admin/upgrades.rst:86
msgid "Launch the updated Tarantool server using ``tarantoolctl`` or ``systemctl``."
msgstr "Запустите обновленный Tarantool-сервер с помощью ``tarantoolctl`` или ``systemctl``."

#: ../doc/1.7/book/admin/upgrades.rst:92
msgid "Upgrading Tarantool in a replication cluster"
msgstr "Обновление Tarantool'а в репликационном кластере"

#: ../doc/1.7/book/admin/upgrades.rst:94
msgid "Tarantool 1.7 (as well as Tarantool 1.9) can work as a :ref:`replica <replication-architecture>` for Tarantool 1.6 and vice versa. Replicas perform capability negotiation on handshake, and new 1.7 replication features are not used with 1.6 replicas. This allows upgrading clustered configurations."
msgstr "Tarantool 1.7 (а также Tarantool 1.9) может служить :ref:`репликой <replication-architecture>` для Tarantool'а 1.6 -- и наоборот. При установке соединения происходит обсуждение возможностей, и новые для 1.7 репликационные функции не используются при работе с репликами версии 1.6. Такой подход позволяет обновлять кластерные конфигурации."

#: ../doc/1.7/book/admin/upgrades.rst:99
msgid "This procedure allows for a rolling upgrade **without downtime** and works for any cluster configuration: master-master or master-replica."
msgstr "Этот процесс позволяет осуществить последовательное обновление **без простоев** и подходит для любой конфигурации кластера: master-master или мастер-реплика."

#: ../doc/1.7/book/admin/upgrades.rst:102
msgid "Upgrade Tarantool at all replicas (or at any master in a master-master cluster). See details in :ref:`Upgrading a Tarantool instance <admin-upgrades_instance>`."
msgstr "Обновите Tarantool на всех репликах (или на любом мастере в кластере мастер-мастер). Подробные инструкции доступны в подразделе :ref:`Обновление экземпляра Tarantool'а <admin-upgrades_instance>`."

#: ../doc/1.7/book/admin/upgrades.rst:106
msgid "Verify installation on the replicas:"
msgstr "Проверьте работу реплик:"

#: ../doc/1.7/book/admin/upgrades.rst:108
msgid "Start Tarantool."
msgstr "Запустите Tarantool."

#: ../doc/1.7/book/admin/upgrades.rst:110
msgid "Attach to the master and start working as before."
msgstr "Присоединитесь к мастеру и начните работать, как раньше."

#: ../doc/1.7/book/admin/upgrades.rst:112
msgid "The master runs the old Tarantool version, which is always compatible with the next major version."
msgstr "На мастере установлена старая версия Tarantool'а, которая всегда совместима со следующей мажорной версией."

#: ../doc/1.7/book/admin/upgrades.rst:115
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr "Обновите мастер. Процесс такой же, как и при обновлении реплики."

#: ../doc/1.7/book/admin/upgrades.rst:117
msgid "Verify master installation:"
msgstr "Проверьте работу мастера:"

#: ../doc/1.7/book/admin/upgrades.rst:119
msgid "Start Tarantool with replica configuration to catch up."
msgstr "Запустите Tarantool в режиме реплики для получения последней версии данных."

#: ../doc/1.7/book/admin/upgrades.rst:121
msgid "Switch to master mode."
msgstr "Переключитесь в режим мастера."

#: ../doc/1.7/book/admin/upgrades.rst:123
msgid "Upgrade the database on any master node in the cluster. Make the request ``box.schema.upgrade()``. This updates Tarantool system spaces to match the currently installed version of Tarantool. Changes are propagated to other nodes via the regular replication mechanism."
msgstr "Обновите базу данных на любом мастере в кластере. Выполните команду ``box.schema.upgrade()``. Это обновит системные спейсы Tarantool'а так, чтобы они совпадали с текущей установленной версией Tarantool'а. Изменения распространятся на другие узлы кластера через обычный механизм репликации."

#: ../doc/1.7/book/app_server/contributing_module.rst:5
msgid "Contributing a module"
msgstr "Добавление собственного модуля"

#: ../doc/1.7/book/app_server/contributing_module.rst:7
msgid "We have already discussed :ref:`how to create a simple module in Lua for local usage <app_server-modules>`. Now let's discuss how to create a more advanced Tarantool module and then get it published on `Tarantool rocks page <http://tarantool.org/rocks.html>`_ and included in `official Tarantool images <http://github.com/tarantool/docker>`_ for Docker."
msgstr "Мы уже обсуждали, :ref:`как создать простой модуль на языке Lua для локального использования <app_server-modules>`.Теперь давайте обсудим, как создать модуль более продвинутого уровня для Tarantool'а, а затем разместить его на странице модулей Tarantool'а <http://tarantool.org/rocks.html>`_ и включить его в `официальные образы Tarantool'а <http://github.com/tarantool/docker>`_ для Docker."

#: ../doc/1.7/book/app_server/contributing_module.rst:14
msgid "To help our contributors, we have created `modulekit <http://github.com/tarantool/modulekit>`_, a set of templates for creating Tarantool modules in Lua and C."
msgstr "Чтобы помочь разработчикам, мы создали `modulekit <http://github.com/tarantool/modulekit>`_, набор шаблонов для создания Tarantool-модулей на Lua и C."

#: ../doc/1.7/book/app_server/contributing_module.rst:20
msgid "As a prerequisite for using ``modulekit``, install ``tarantool-dev`` package first. For example, in Ubuntu say:"
msgstr "Чтобы использовать ``modulekit``, необходимо предварительно установить пакет ``tarantool-dev``. Например, в Ubuntu выполните команду:"

#: ../doc/1.7/book/app_server/contributing_module.rst:23
#: ../doc/1.7/reference/reference_rock/dbms.rst:61
#: ../doc/1.7/reference/reference_rock/dbms.rst:414
#: ../doc/1.7/tutorials/c_tutorial.rst:48
msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install tarantool-dev"

#: ../doc/1.7/book/app_server/contributing_module.rst:31
msgid "Contributing a module in Lua"
msgstr "Добавление собственного модуля на Lua"

#: ../doc/1.7/book/app_server/contributing_module.rst:33
msgid "See `README in \"luakit\" branch of tarantool/modulekit repository <http://github.com/tarantool/modulekit/blob/luakit/README.md>`_ for detailed instructions and examples."
msgstr "Подробную информацию и примеры см. в `README в ветке \"luakit\" репозитория tarantool/modulekit <http://github.com/tarantool/modulekit/blob/luakit/README.md>`_."

#: ../doc/1.7/book/app_server/contributing_module.rst:41
msgid "Contributing a module in C"
msgstr "Добавление собственного модуля на C"

#: ../doc/1.7/book/app_server/contributing_module.rst:43
msgid "In some cases, you may want to create a Tarantool module in C rather than in Lua. For example, to work with specific hardware or low-level system interfaces."
msgstr "В некоторых случаях может потребоваться создание Tarantool-модуля на C, а не на Lua, например, для работы со специальным оборудованием или низкоуровневыми системными интерфейсами."

#: ../doc/1.7/book/app_server/contributing_module.rst:46
msgid "See `README in \"ckit\" branch of tarantool/modulekit repository <http://github.com/tarantool/modulekit/blob/ckit/README.md>`_ for detailed instructions and examples."
msgstr "Подробную информацию и примеры см. в `README в ветке \"ckit\" репозитория tarantool/modulekit <http://github.com/tarantool/modulekit/blob/ckit/README.md>`_."

#: ../doc/1.7/book/app_server/contributing_module.rst:52
msgid "You can also create modules with C++, provided that the code does not throw exceptions."
msgstr "Вы можете аналогичным образом создавать модули на C++ при условии, что в их коде не будут выбрасываться исключения."

#: ../doc/1.7/book/app_server/cookbook.rst:5
msgid "Cookbook recipes"
msgstr "Примеры и рекомендации по разработке"

#: ../doc/1.7/book/app_server/cookbook.rst:7
msgid "Here are contributions of Lua programs for some frequent or tricky situations."
msgstr "Ниже представлены дополнения в виде Lua-программ для часто встречающихся или сложных случаев."

#: ../doc/1.7/book/app_server/cookbook.rst:9
msgid "You can execute any of these programs by copying the code into a ``.lua`` file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp:`./{program-name}.lua` on the terminal."
msgstr "Любую из этих программ можно выполнить, скопировав код в ``.lua-файл``, а затем выполнив в командной строке :samp:`chmod +x ./{program-name}.lua` и :samp :`./{program-name}.lua`."

#: ../doc/1.7/book/app_server/cookbook.rst:13
msgid "The first line is a \"hashbang\":"
msgstr "Первая строка -- это шебанг:"

#: ../doc/1.7/book/app_server/cookbook.rst:15
msgid "#!/usr/bin/env tarantool"
msgstr "#!/usr/bin/env tarantool"

#: ../doc/1.7/book/app_server/cookbook.rst:19
msgid "This runs  Tarantool Lua application server, which should be on the execution path."
msgstr "Он запускает сервер приложений Tarantool'а на языке Lua, который должен быть в пути выполнения."

#: ../doc/1.7/book/app_server/cookbook.rst:22
msgid "Use freely."
msgstr "Можно использовать свободно."

#: ../doc/1.7/book/app_server/cookbook.rst:28
msgid "hello_world.lua"
msgstr "hello_world.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:30
msgid "The standard example of a simple program."
msgstr "Стандартный пример простой программы."

#: ../doc/1.7/book/app_server/cookbook.rst:32
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        print('Hello, World!')"

#: ../doc/1.7/book/app_server/cookbook.rst:42
msgid "console_start.lua"
msgstr "console_start.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:44
msgid "Use :ref:`box.once() <box-once>` to initialize a database (creating spaces) if this is the first time the server has been run. Then use :ref:`console.start() <console-start>` to start interactive mode."
msgstr "Для инициализации базы данных (создания спейсов) используйте :ref:`box.once() <box-once>`, если сервер запускается впервые. Затем используйте :ref:`console.start() <console-start>`, чтобы запустить интерактивный режим."

#: ../doc/1.7/book/app_server/cookbook.rst:48
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        -- Настроить базу данных\n"
"        box.cfg {\n"
"            listen = 3313\n"
"        }\n"
"        \n"
"        box.once(\"bootstrap\", function()\n"
"            box.schema.space.create('tweedledum')\n"
"            box.space.tweedledum:create_index('primary',\n"
"                { type = 'TREE', parts = {1, 'unsigned'}})\n"
"        end)\n"
"        \n"
"        require('console').start()"

#: ../doc/1.7/book/app_server/cookbook.rst:69
msgid "fio_read.lua"
msgstr "fio_read.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:71
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr "Используйте :ref:`Модуль fio <fio-module>`, чтобы открыть, прочитать и закрыть файл."

#: ../doc/1.7/book/app_server/cookbook.rst:73
#: ../doc/1.7/reference/reference_lua/errcodes.rst:109
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local fio = require('fio')\n"
"        local errno = require('errno')\n"
"        local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"        if not f then\n"
"            error(\"Failed to open file: \"..errno.strerror())\n"
"        end\n"
"        local data = f:read(4096)\n"
"        f:close()\n"
"        print(data)"

#: ../doc/1.7/book/app_server/cookbook.rst:91
msgid "fio_write.lua"
msgstr "fio_write.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:93
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr "Используйте :ref:`Модуль fio <fio-module>`, чтобы открыть, записать данные и закрыть файл."

#: ../doc/1.7/book/app_server/cookbook.rst:95
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local fio = require('fio')\n"
"        local errno = require('errno')\n"
"        local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"            tonumber('0666', 8))\n"
"        if not f then\n"
"            error(\"Failed to open file: \"..errno.strerror())\n"
"        end\n"
"        f:write(\"Hello\\n\");\n"
"        f:close()"

#: ../doc/1.7/book/app_server/cookbook.rst:113
msgid "ffi_printf.lua"
msgstr "ffi_printf.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:115
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C built-in function: printf(). (For help understanding ffi, see the `FFI tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr "Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, чтобы вызвать встроенную в C функцию: printf(). (Чтобы лучше понимать FFI, см. `Учебное пособие по FFI <http://luajit.org/ext_ffi_tutorial.html>`_.)"

#: ../doc/1.7/book/app_server/cookbook.rst:118
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local ffi = require('ffi')\n"
"        ffi.cdef[[\n"
"            int printf(const char *format, ...);\n"
"        ]]\n"
"        \n"
"        ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"

#: ../doc/1.7/book/app_server/cookbook.rst:133
msgid "ffi_gettimeofday.lua"
msgstr "ffi_gettimeofday.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:135
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C function: gettimeofday(). This delivers time with millisecond precision, unlike the time function in Tarantool's :ref:`clock module <clock-module>`."
msgstr "Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, чтобы вызвать встроенную в C функцию: gettimeofday(). Она позволяет получить значение времени с точностью в миллисекундах, в отличие от функции времени в Tarantool'е :ref:`Модуль clock <clock-module>`."

#: ../doc/1.7/book/app_server/cookbook.rst:139
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / 1000))\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local ffi = require('ffi')\n"
"        ffi.cdef[[\n"
"            typedef long time_t;\n"
"            typedef struct timeval {\n"
"            time_t tv_sec;\n"
"            time_t tv_usec;\n"
"        } timeval;\n"
"            int gettimeofday(struct timeval *t, void *tzp);\n"
"        ]]\n"
"        \n"
"        local timeval_buf = ffi.new(\"timeval\")\n"
"        local now = function()\n"
"            ffi.C.gettimeofday(timeval_buf, nil)\n"
"            return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / 1000))\n"
"        end"

#: ../doc/1.7/book/app_server/cookbook.rst:163
msgid "ffi_zlib.lua"
msgstr "ffi_zlib.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:165
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C library function. (For help understanding ffi, see the `FFI tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr "Используйте `Библиотеку LuaJIT FFI  <http://luajit.org/ext_ffi.html>`_, чтобы вызвать библиотечную функцию в C. (Чтобы лучше понимать FFI, см. `Учебное пособие по FFI <http://luajit.org/ext_ffi_tutorial.html>`_.)"

#: ../doc/1.7/book/app_server/cookbook.rst:168
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local ffi = require(\"ffi\")\n"
"        ffi.cdef[[\n"
"            unsigned long compressBound(unsigned long sourceLen);\n"
"            int compress2(uint8_t *dest, unsigned long *destLen,\n"
"            const uint8_t *source, unsigned long sourceLen, int level);\n"
"            int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"            const uint8_t *source, unsigned long sourceLen);\n"
"        ]]\n"
"        local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"        \n"
"        -- Надстройка Lua для функции compress2()\n"
"        local function compress(txt)\n"
"            local n = zlib.compressBound(#txt)\n"
"            local buf = ffi.new(\"uint8_t[?]\", n)\n"
"            local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"            local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"            assert(res == 0)\n"
"            return ffi.string(buf, buflen[0])\n"
"        end\n"
"        \n"
"        -- Надстройка Lua для функции uncompress\n"
"        local function uncompress(comp, n)\n"
"            local buf = ffi.new(\"uint8_t[?]\", n)\n"
"            local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"            local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"            assert(res == 0)\n"
"            return ffi.string(buf, buflen[0])\n"
"        end\n"
"        \n"
"        — Простой код тестов.\n"
"        local txt = string.rep(\"abcd\", 1000)\n"
"        print(\"Uncompressed size: \", #txt)\n"
"        local c = compress(txt)\n"
"        print(\"Compressed size: \", #c)\n"
"        local txt2 = uncompress(c, #txt)\n"
"        assert(txt2 == txt)"

#: ../doc/1.7/book/app_server/cookbook.rst:213
msgid "ffi_meta.lua"
msgstr "ffi_meta.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:215
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access a C object via a metamethod (a method which is defined with a metatable)."
msgstr "Используйте `Библиотеку LuaJIT FFI <http://luajit.org/ext_ffi.html>`_, чтобы получить доступ к объекту в C с помощью метаметода (метод, который определен метатаблицей)."

#: ../doc/1.7/book/app_server/cookbook.rst:219
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local ffi = require(\"ffi\")\n"
"        ffi.cdef[[\n"
"        typedef struct { double x, y; } point_t;\n"
"        ]]\n"
"        \n"
"        local point\n"
"        local mt = {\n"
"          __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"          __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"          __index = {\n"
"            area = function(a) return a.x*a.x + a.y*a.y end,\n"
"          },\n"
"        }\n"
"        point = ffi.metatype(\"point_t\", mt)\n"
"        \n"
"        local a = point(3, 4)\n"
"        print(a.x, a.y)  --> 3  4\n"
"        print(#a)        --> 5\n"
"        print(a:area())  --> 25\n"
"        local b = a + point(0.5, 8)\n"
"        print(#b)        --> 12.5"

#: ../doc/1.7/book/app_server/cookbook.rst:249
msgid "print_arrays.lua"
msgstr "print_arrays.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:251
msgid "Create Lua tables, and print them. Notice that for the 'array' table the iterator function is ipairs(), while for the 'map' table the iterator function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is recommended for map-like tables or mixed tables.) The display will look like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2 v2\"."
msgstr "Используйте, чтобы создать Lua-таблицы и вывести их. Следует отметить, что для таблицы типа массива (array) функция-итератор будет ipairs(), а для таблицы типа ассоциативного массива (map) функция-итератор -- `pairs()`. (`ipairs()` быстрее, чем `pairs()`, но `pairs()` рекомендуется для ассоциативных массивов или смешанных таблиц.) Результат будет выглядеть следующим образом: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2  v2\"."

#: ../doc/1.7/book/app_server/cookbook.rst:259
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"        for k, v in ipairs(array) do print(k, v) end\n"
"        \n"
"        map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"        for k, v in pairs(map) do print(k, v) end"

#: ../doc/1.7/book/app_server/cookbook.rst:273
msgid "count_array.lua"
msgstr "count_array.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:275
msgid "Use the '#' operator to get the number of items in an array-like Lua table. This operation has O(log(N)) complexity."
msgstr "Используйте оператор '#', чтобы получить количество элементов в Lua-таблице типа массива. У этой операции сложность O(log(N))."

#: ../doc/1.7/book/app_server/cookbook.rst:278
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        array = { 1, 2, 3}\n"
"        print(#array)"

#: ../doc/1.7/book/app_server/cookbook.rst:289
msgid "count_array_with_nils.lua"
msgstr "count_array_with_nils.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:291
msgid "Missing elements in arrays, which Lua treats as \"nil\"s, cause the simple \"#\" operator to deliver improper results. The \"print(#t)\" instruction will print \"4\"; the \"print(counter)\" instruction will print \"3\"; the \"print(max)\" instruction will print \"10\". Other table functions, such as table.sort(), will also misbehave when \"nils\" are present."
msgstr "Отсутствующие элементы в массивах, которые Lua рассматривает как nil, заставляют простой оператор '#' выдавать неправильные результаты. Команда \"print(#t)\" выведет \"4\", команда \"print(counter)\" выведет \"3\", а команда \"print(max)\" -- \"10\". Другие табличные функции, такие как table.sort(), также сработают неправильно при наличии значений nils."

#: ../doc/1.7/book/app_server/cookbook.rst:299
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local t = {}\n"
"        t[1] = 1\n"
"        t[4] = 4\n"
"        t[10] = 10\n"
"        print(#t)\n"
"        local counter = 0\n"
"        for k,v in pairs(t) do counter = counter + 1 end\n"
"        print(counter)\n"
"        local max = 0\n"
"        for k,v in pairs(t) do if k > max then max = k end end\n"
"        print(max)"

#: ../doc/1.7/book/app_server/cookbook.rst:319
msgid "count_array_with_nulls.lua"
msgstr "count_array_with_nulls.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:321
msgid "Use explicit ``NULL`` values to avoid the problems caused by Lua's nil == missing value behavior. Although :code:`json.NULL == nil` is :code:`true`, all the print instructions in this program will print the correct value: 10."
msgstr "Используйте явные значения``NULL``, чтобы избежать проблем, вызванных  nil в Lua == поведение с пропущенными значениями. Хотя :code:`json.NULL == nil` является :code:`true`, все команды вывода в данной программе выведут правильное значение: 10."

#: ../doc/1.7/book/app_server/cookbook.rst:326
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local json = require('json')\n"
"        local t = {}\n"
"        t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"        t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"        t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"        t[9] = json.NULL\n"
"        t[10] = 10\n"
"        print(#t)\n"
"        local counter = 0\n"
"        for k,v in pairs(t) do counter = counter + 1 end\n"
"        print(counter)\n"
"        local max = 0\n"
"        for k,v in pairs(t) do if k > max then max = k end end\n"
"        print(max)"

#: ../doc/1.7/book/app_server/cookbook.rst:349
msgid "count_map.lua"
msgstr "count_map.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:351
msgid "Get the number of elements in a map-like table."
msgstr "Программа используется для получения количества элементов в таблице типа ассоциативного массива."

#: ../doc/1.7/book/app_server/cookbook.rst:353
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local map = { a = 10, b = 15, c = 20 }\n"
"        local size = 0\n"
"        for _ in pairs(map) do size = size + 1; end\n"
"        print(size)"

#: ../doc/1.7/book/app_server/cookbook.rst:366
msgid "swap.lua"
msgstr "swap.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:368
msgid "Use a Lua peculiarity to swap two variables without needing a third variable."
msgstr "Программа использует особенность Lua менять местами две переменные без необходимости использования третьей переменной."

#: ../doc/1.7/book/app_server/cookbook.rst:370
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local x = 1\n"
"        local y = 2\n"
"        x, y = y, x\n"
"        print(x, y)"

#: ../doc/1.7/book/app_server/cookbook.rst:383
msgid "class.lua"
msgstr "class.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:385
msgid "Create a class, create a metatable for the class, create an instance of the class. Another illustration is at `http://lua-users.org/wiki/LuaClassesWithMetatable <http://lua-users.org/wiki/LuaClassesWithMetatable>`_."
msgstr "Используется для создания класса, метатаблицы для класса, экземпляра класса. Другой пример можно найти в `http://lua-users.org/wiki/LuaClassesWithMetatable <http://lua- users.org/wiki/LuaClassesWithMetatable>`_."

#: ../doc/1.7/book/app_server/cookbook.rst:389
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        -- определить объекты класса\n"
"        local myclass_somemethod = function(self)\n"
"            print('test 1', self.data)\n"
"        end\n"
"        \n"
"        local myclass_someothermethod = function(self)\n"
"            print('test 2', self.data)\n"
"        end\n"
"        \n"
"        local myclass_tostring = function(self)\n"
"            return 'MyClass <'..self.data..'>'\n"
"        end\n"
"        \n"
"        local myclass_mt = {\n"
"            __tostring = myclass_tostring;\n"
"            __index = {\n"
"                somemethod = myclass_somemethod;\n"
"                someothermethod = myclass_someothermethod;\n"
"            }\n"
"        }\n"
"        \n"
"        -- создать новый объект своего класса myclass\n"
"        local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"        print(object:somemethod())\n"
"        print(object.data)"

#: ../doc/1.7/book/app_server/cookbook.rst:423
msgid "garbage.lua"
msgstr "garbage.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:425
msgid "Force Lua `garbage collection <https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the `collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr "Принудительно запустите ` сборку мусора <https://www.lua.org/manual/5.1/manual.html#2.10>`_ в Lua с `функцией collectgarbage <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."

#: ../doc/1.7/book/app_server/cookbook.rst:428
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        collectgarbage('collect')"

#: ../doc/1.7/book/app_server/cookbook.rst:438
msgid "fiber_producer_and_consumer.lua"
msgstr "fiber_producer_and_consumer.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:440
msgid "Start one fiber for producer and one fiber for consumer. Use :ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and synchronize. One can tweak the channel size (:code:`ch_size` in the program code) to control the number of simultaneous tasks waiting for processing."
msgstr "Запустите один файбер для производителя и один файбер для потребителя. Используйте :ref:`fiber.channel() <fiber_ipc-channel>` для обмена данных и синхронизации. Можно настроить ширину канала (:code:`ch_size` в программном коде) для управления количеством одновременных задач к обработке."

#: ../doc/1.7/book/app_server/cookbook.rst:445
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local fiber = require('fiber')\n"
"        local function consumer_loop(ch, i)\n"
"            -- инициализировать потребитель синхронно или выдать ошибку()\n"
"            fiber.sleep(0) -- позволить fiber.create() продолжать\n"
"            while true do\n"
"                local data = ch:get()\n"
"                if data == nil then\n"
"                    break\n"
"                end\n"
"                print('consumed', i, data)\n"
"                fiber.sleep(math.random()) -- моделировать работу\n"
"            end\n"
"        end\n"
"        \n"
"        local function producer_loop(ch, i)\n"
"            -- инициализировать потребитель синхронно или выдать ошибку()\n"
"            fiber.sleep(0) -- позволить fiber.create() продолжать\n"
"            while true do\n"
"                local data = math.random()\n"
"                ch:put(data)\n"
"                print('produced', i, data)\n"
"            end\n"
"        end\n"
"        \n"
"        local function start()\n"
"            local consumer_n = 5\n"
"            local producer_n = 3\n"
"        \n"
"            — создать канал\n"
"            local ch_size = math.max(consumer_n, producer_n)\n"
"            local ch = fiber.channel(ch_size)\n"
"        \n"
"            -- запустить потребители\n"
"            for i=1, consumer_n,1 do\n"
"                fiber.create(consumer_loop, ch, i)\n"
"            end\n"
"        \n"
"            -- запустить производители\n"
"            for i=1, producer_n,1 do\n"
"                fiber.create(producer_loop, ch, i)\n"
"            end\n"
"        end\n"
"        \n"
"        start()\n"
"        print('started')"

#: ../doc/1.7/book/app_server/cookbook.rst:499
msgid "socket_tcpconnect.lua"
msgstr "socket_tcpconnect.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:501
msgid "Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a remote host via TCP. Display the connection details and the result of a GET request."
msgstr "Используйте :ref:`socket.tcp_connect() <socket-tcp_connect>` для подключения к удаленному серверу по TCP. Можно отобразить информацию о подключении и результат запроса GET."

#: ../doc/1.7/book/app_server/cookbook.rst:505
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local s = require('socket').tcp_connect('google.com', 80)\n"
"        print(s:peer().host)\n"
"        print(s:peer().family)\n"
"        print(s:peer().type)\n"
"        print(s:peer().protocol)\n"
"        print(s:peer().port)\n"
"        print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"        print(s:read('\\r\\n'))\n"
"        print(s:read('\\r\\n'))"

#: ../doc/1.7/book/app_server/cookbook.rst:523
msgid "socket_tcp_echo.lua"
msgstr "socket_tcp_echo.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:525
msgid "Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple TCP server, by creating a function that handles requests and echos them, and passing the function to :ref:`socket.tcp_server() <socket-tcp_server>`. This program has been used to test with 100,000 clients, with each client getting a separate fiber."
msgstr "Используйте :ref:`socket.tcp_connect() <socket-tcp_connect>` для настройки простого TCP-сервера путем создания функции, которая обрабатывает запросы и отражает их, а затем передачи функции на :ref:`socket.tcp_server() <socket-tcp_server>`. Данная программа была протестирована на 100 000 клиентов, каждый из которых получил отдельный файбер."

#: ../doc/1.7/book/app_server/cookbook.rst:533
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, handler)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local function handler(s, peer)\n"
"            s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"            while true do\n"
"                local line = s:read('\\n')\n"
"                if line == nil then\n"
"                    break -- ошибка или eof\n"
"                end\n"
"                if not s:write(\"pong: \"..line) then\n"
"                    break -- ошибка или eof\n"
"                end\n"
"            end\n"
"        end\n"
"        \n"
"        local server, addr = require('socket').tcp_server('localhost', 3311, handler)"

#: ../doc/1.7/book/app_server/cookbook.rst:556
msgid "getaddrinfo.lua"
msgstr "getaddrinfo.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:558
msgid "Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-blocking DNS resolution, getting both the AF_INET6 and AF_INET information for 'google.com'. This technique is not always necessary for tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` performs `socket.getaddrinfo` under the hood, before trying to connect to the first available address."
msgstr "Используйте :ref:`socket.getaddrinfo() <socket-getaddrinfo>`, чтобы провести неблокирующее разрешение имен DNS, получая как AF_INET6, так и AF_INET информацию для 'google.com'. Данная техника не всегда необходима для TCP-соединений, поскольку :ref:`socket.tcp_connect() <socket-tcp_connect>` выполняет `socket.getaddrinfo` с точки зрения внутреннего устройства до попытки соединения с первым доступным адресом."

#: ../doc/1.7/book/app_server/cookbook.rst:566
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = 'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local s = require('socket').getaddrinfo('google.com', 'http', { type = 'SOCK_STREAM' })\n"
"        print('host=',s[1].host)\n"
"        print('family=',s[1].family)\n"
"        print('type=',s[1].type)\n"
"        print('protocol=',s[1].protocol)\n"
"        print('port=',s[1].port)\n"
"        print('host=',s[2].host)\n"
"        print('family=',s[2].family)\n"
"        print('type=',s[2].type)\n"
"        print('protocol=',s[2].protocol)\n"
"        print('port=',s[2].port)"

#: ../doc/1.7/book/app_server/cookbook.rst:586
msgid "socket_udp_echo.lua"
msgstr "socket_udp_echo.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:588
msgid "Tarantool does not currently have a `udp_server` function, therefore socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can be implemented with sockets and fibers."
msgstr "В данный момент в Tarantool нет функции `udp_server`, поэтому socket_udp_echo.lua - более сложная программа, чем socket_tcp_echo.lua. Ее можно имплементировать с сокетами и файберами."

#: ../doc/1.7/book/app_server/cookbook.rst:593
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background fiber\n"
"    return s\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local socket = require('socket')\n"
"        local errno = require('errno')\n"
"        local fiber = require('fiber')\n"
"        \n"
"        local function udp_server_loop(s, handler)\n"
"            fiber.name(\"udp_server\")\n"
"            while true do\n"
"                -- попытка прочитать сначала датаграмму\n"
"                local msg, peer = s:recvfrom()\n"
"                if msg == \"\" then\n"
"                    -- сокет был закрыт с помощью s:close()\n"
"                    break\n"
"                elseif msg ~= nil then\n"
"                    -- получена новая датаграмма\n"
"                    handler(s, peer, msg)\n"
"                else\n"
"                    if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then \n"
"                        -- сокет не готов\n"
"                        s:readable() -- возврат, epoll сообщит, когда будут новые данные\n"
"                    else\n"
"                        -- ошибка сокета\n"
"                        local msg = s:error()\n"
"                        s:close() -- сохранить ресурсы и не ждать сборку мусора\n"
"                        error(\"Socket error: \" .. msg)\n"
"                    end\n"
"                end\n"
"            end\n"
"        end\n"
"        \n"
"        local function udp_server(host, port, handler)\n"
"            local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"            if not s then\n"
"                return nil -- проверить номер ошибки errno:strerror()\n"
"            end\n"
"            if not s:bind(host, port) then\n"
"                local e = s:errno() -- сохранить номер ошибки errno\n"
"                s:close()\n"
"                errno(e) -- восстановить номер ошибки errno\n"
"                return nil -- проверить номер ошибки errno:strerror()\n"
"            end\n"
"        \n"
"            fiber.create(udp_server_loop, s, handler) -- запустить новый файбер в фоновом режиме\n"
"            return s\n"
"        end"

#: ../doc/1.7/book/app_server/cookbook.rst:642
msgid "A function for a client that connects to this server could look something like this ..."
msgstr "Функция для клиента, который подключается к этому серверу, может выглядеть следующим образом:"

#: ../doc/1.7/book/app_server/cookbook.rst:645
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""
"local function handler(s, peer, msg)\n"
"            -- Необязательно ждать, пока сокет будет готов отправлять UDP\n"
"            -- s:writable()\n"
"            s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"        end\n"
"        \n"
"        local server = udp_server('127.0.0.1', 3548, handler)\n"
"        if not server then\n"
"            error('Failed to bind: ' .. errno.strerror())\n"
"        end\n"
"        \n"
"        print('Started')\n"
"        \n"
"        require('console').start()"

#: ../doc/1.7/book/app_server/cookbook.rst:666
msgid "http_get.lua"
msgstr "http_get.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:668
msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr "Используйте :ref:`Модуль HTTP <http-module>` для получения данных по HTTP."

#: ../doc/1.7/book/app_server/cookbook.rst:671
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local http_client = require('http.client')\n"
"        local json = require('json')\n"
"        local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us') \n"
"        if r.status ~= 200 then\n"
"            print('Failed to get weather forecast ', r.reason)\n"
"            return\n"
"        end\n"
"        local data = json.decode(r.body)\n"
"        print('Oakland wind speed: ', data.wind.speed)"

#: ../doc/1.7/book/app_server/cookbook.rst:689
msgid "http_send.lua"
msgstr "http_send.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:691
msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr "Используйте :ref:`Модуль HTTP <http-module>` для отправки данных по HTTP."

#: ../doc/1.7/book/app_server/cookbook.rst:694
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local http_client = require('http.client')\n"
"        local json = require('json')\n"
"        local data = json.encode({ Key = 'Value'})\n"
"        local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"        local r = http_client.post('http://localhost:8081', data, { headers = headers})\n"
"        if r.status == 200 then\n"
"            print 'Success'\n"
"        end"

#: ../doc/1.7/book/app_server/cookbook.rst:711
msgid "http_server.lua"
msgstr "http_server.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:713
msgid "Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool into a web server."
msgstr "Используйте `сторонний модуль`_ `http`_  (который необходимо предварительно установить), чтобы превратить Tarantool в веб-сервер."

#: ../doc/1.7/book/app_server/cookbook.rst:716
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local function handler(self)\n"
"            return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"        end\n"
"        \n"
"        local server = require('http.server').new(nil, 8080) -- анализировать связь с *:8080\n"
"        server:route({ path = '/' }, handler)\n"
"        server:start()\n"
"        -- подключиться к localhost:8080 и читать JSON"

#: ../doc/1.7/book/app_server/cookbook.rst:733
msgid "http_generate_html.lua"
msgstr "http_generate_html.lua"

#: ../doc/1.7/book/app_server/cookbook.rst:735
msgid "Use the `http`_ `rock` (which must first be installed) to generate HTML pages from templates. The `http`_ `rock`_ has a fairly simple template engine which allows execution of regular Lua code inside text blocks (like PHP). Therefore there is no need to learn new languages in order to write templates."
msgstr "Используйте `сторонний модуль`_ `http`_ (который необходимо предварительно установить) для создания HTML-страниц из шаблонов. В `модуле http`_ достаточно простой движок шаблонов, который позволяет выполнять регулярный код на Lua в текстовых блоках (как в PHP). Таким образом, нет необходимости в изучении новых языков, чтобы написать шаблоны."

#: ../doc/1.7/book/app_server/cookbook.rst:741
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        \n"
"        local function handler(self)\n"
"        local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"            return self:render{ fruits = fruits }\n"
"        end\n"
"        \n"
"        local server = require('http.server').new(nil, 8080) -- nil означает '*'\n"
"        server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"        server:start()"

#: ../doc/1.7/book/app_server/cookbook.rst:754
msgid "An \"HTML\" file for this server, including Lua, could look like this (it would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr "HTML-файл для этого сервера, включая Lua, может выглядеть следующим образом (он выведет \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."

#: ../doc/1.7/book/app_server/cookbook.rst:757
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""
"<html>\n"
"        <body>\n"
"            <table border=\"1\">\n"
"                % for i,v in pairs(fruits) do\n"
"                <tr>\n"
"                    <td><%= i %></td>\n"
"                    <td><%= v %></td>\n"
"                </tr>\n"
"                % end\n"
"            </table>\n"
"        </body>\n"
"        </html>"

#: ../doc/1.7/book/app_server/creating_app.rst:5
msgid "Creating an application"
msgstr "Создание приложения"

#: ../doc/1.7/book/app_server/creating_app.rst:7
msgid "Further we walk you through key programming practices that will give you a good start in writing Lua applications for Tarantool. For an adventure, this is a story of implementing... a real microservice based on Tarantool! We implement a backend for a simplified version of `Pokémon Go <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a location-based augmented reality game released in mid-2016. In this game, players use a mobile device's GPS capability to locate, capture, battle and train virtual monsters called \"pokémon\", who appear on the screen as if they were in the same real-world location as the player."
msgstr "Далее мы пошагово разберем ключевые методики программирования, что послужит хорошим началом для написания Lua-приложений для Tarantool'а. Для интереса возьмем историю имплементирования ... настоящего микросервиса на основе Tarantool'а! Мы имплементируем бэкенд для упрощенной версии `Pokémon Go  <https://ru.wikipedia.org/wiki/Pok%C3%A9mon_Go>`_, игры на основе определения местоположения дополненной реальности, выпущенной в середине 2016 года. В этой игре игроки используют GPS-возможности мобильных устройств, чтобы находить, захватывать, сражаться и тренировать виртуальных существ, или покемонов, которые появляются на экране, как если бы они находились в том же реальном месте, как и игрок."

#: ../doc/1.7/book/app_server/creating_app.rst:17
msgid "To stay within the walk-through format, let's narrow the original gameplay as follows. We have a map with pokémon spawn locations. Next, we have multiple players who can send catch-a-pokémon requests to the server (which runs our Tarantool microservice). The server replies whether the pokémon is caught or not, increases the player's pokémon counter if yes, and triggers the respawn-a-pokémon method that spawns a new pokémon at the same location in a while."
msgstr "Чтобы не выходить за рамки пошагового примера, ограничим оригинальный сюжет игры. У нас есть карта с местами появления покемонов. Далее у нас есть несколько игроков, которые могут отправлять запросы на поимку покемона на сервер (где работает микросервис Tarantool'а). Сервер отвечает, пойман ли покемон, увеличивает счетчик покемонов, если пойман, и вызывает метод респауна покемона, который через некоторое время создает нового покемона на том же самом месте."

#: ../doc/1.7/book/app_server/creating_app.rst:25
msgid "We leave client-side applications outside the scope of this story. Yet we promise a mini-demo in the end to simulate real users and give us some fun. :-)"
msgstr "Мы вынесем клиентские приложения за рамки рассказа. Но в конце обещаем небольшую демонстрацию с моделированием настоящих пользователей, чтобы немного поразвлечься. :-)"

#: ../doc/1.7/book/app_server/creating_app.rst:31
msgid "First, what would be the best way to deliver our microservice?"
msgstr "Для начала как лучше всего предоставить микросервис?"

#: ../doc/1.7/book/app_server/creating_app.rst:37
msgid "Modules, rocks and applications"
msgstr "Модули и приложения"

#: ../doc/1.7/book/app_server/creating_app.rst:39
msgid "To make our game logic available to other developers and Lua applications, let's put it into a Lua module."
msgstr "Чтобы наша логическая схема игры была доступна другим разработчикам и Lua-приложениям, поместим ее в Lua-модуль."

#: ../doc/1.7/book/app_server/creating_app.rst:42
msgid "A **module** (called \"rock\" in Lua) is an optional library which enhances Tarantool functionality. So, we can install our logic as a module in Tarantool and use it from any Tarantool application or module. Like applications, modules in Tarantool can be written in Lua (rocks), C or C++."
msgstr "**Модуль** (который называется \"rock\" в Lua) - это дополнительная библиотека, которая расширяет функции Tarantool'а. Поэтому можно установить нашу логическую схему в виде модуля в Tarantool и использовать ее из любого Tarantool-приложения или модуля. Как и приложения, модули в Tarantool'е могут быть написаны на Lua (rocks), C или C++."

#: ../doc/1.7/book/app_server/creating_app.rst:47
msgid "Modules are good for two things:"
msgstr "Модули хороши для двух целей:"

#: ../doc/1.7/book/app_server/creating_app.rst:49
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr "облегченное **управление кодом** (переиспользование, подготовка к развертыванию, версионирование) и"

#: ../doc/1.7/book/app_server/creating_app.rst:50
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr "горячая **перезагрузка кода** без перезапуска экземпляра Tarantool'а."

#: ../doc/1.7/book/app_server/creating_app.rst:52
msgid "Technically, a module is a file with source code that exports its functions in an API. For example, here is a Lua module named ``mymodule.lua`` that exports one function named ``myfun``:"
msgstr "В техническом смысле, модуль - это файл с исходным кодом, который экспортирует свои функции в API. Например, вот Lua-модуль под названием ``mymodule.lua``, который экспортирует одну функцию под названием ``myfun``:"

#: ../doc/1.7/book/app_server/creating_app.rst:56
msgid ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"local exports = {}\n"
"        exports.myfun = function(input_string)\n"
"           print('Hello', input_string)\n"
"        end\n"
"        return exports"

#: ../doc/1.7/book/app_server/creating_app.rst:64
msgid "To launch the function ``myfun()`` -- from another module, from a Lua application, or from Tarantool itself, -- we need to save this module as a file, then load this module with the ``require()`` directive and call the exported function."
msgstr "Чтобы запустить функцию ``myfun()`` — из другого модуля, из Lua-приложения или из самого Tarantool'а — необходимо сохранить этот модуль в виде файла, а затем загрузить этот модуль с директивой ``require()`` и вызвать экспортированную функцию."

#: ../doc/1.7/book/app_server/creating_app.rst:68
msgid "For example, here's a Lua application that uses ``myfun()`` function from ``mymodule.lua`` module:"
msgstr "Например, вот Lua-приложение, которое использует функцию ``myfun()`` из модуля ``mymodule.lua``:"

#: ../doc/1.7/book/app_server/creating_app.rst:71
msgid ""
"-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""
"-- загрузка модуля\n"
"        local mymodule = require('mymodule')\n"
"        \n"
"        -- вызов myfun() из функции test()\n"
"        local test = function()\n"
"          mymodule.myfun()\n"
"        end"

#: ../doc/1.7/book/app_server/creating_app.rst:81
msgid "A thing to remember here is that the ``require()`` directive takes load paths to Lua modules from the ``package.path`` variable. This is a semicolon-separated string, where a question mark is used to interpolate the module name. By default, this variable contains system-wide Lua paths and the working directory. But if we put our modules inside a specific folder (e.g. ``scripts/``), we need to add this folder to ``package.path`` before any calls to ``require()``:"
msgstr "Здесь важно запомнить, что директива ``require()`` берет пути загрузки к Lua-модулям из переменной ``package.path``. Она представляет собой строку с разделителями в виде точки с запятой, где знак вопроса используется для вставки имени модуля. По умолчанию, эта переменная содержит пути в системе и рабочую директорию. Но если мы поместим наши модули в особую папку (например, ``scripts/``), необходимо будет добавить эту папку в ``package.path`` до вызова ``require()``:"

#: ../doc/1.7/book/app_server/creating_app.rst:88
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr "package.path = 'scripts/?.lua;' .. package.path"

#: ../doc/1.7/book/app_server/creating_app.rst:92
msgid "For our microservice, a simple and convenient solution would be to put all methods in a Lua module (say ``pokemon.lua``) and to write a Lua application (say ``game.lua``) that initializes the gaming environment and starts the game loop."
msgstr "Для нашего микросервиса простым и удобным решением будет разместить все методы в Lua-модуле (скажем, ``pokemon.lua``) и написать Lua-приложение (скажем, ``game.lua``), которое запустит игровое окружение и цикл игры."

#: ../doc/1.7/book/app_server/creating_app.rst:100
msgid "Now let's get down to implementation details. In our game, we need three entities:"
msgstr "Теперь приступим к деталям реализации. В игре нам необходимы три сущности:"

#: ../doc/1.7/book/app_server/creating_app.rst:102
msgid "**map**, which is an array of pokémons with coordinates of respawn locations; in this version of the game, let a location be a rectangle identified with two points, upper-left and lower-right;"
msgstr "**карта**, которая представляет собой массив покемонов с координатами мест респауна; в данной версии игры пусть местом будет прямоугольник, установленный по двум точкам, верхней левой и нижней правой;"

#: ../doc/1.7/book/app_server/creating_app.rst:105
msgid "**player**, which has an ID, a name, and coordinates of the player's location point;"
msgstr "**игрок**, у которого есть ID, имя и координаты местонахождения игрока;"

#: ../doc/1.7/book/app_server/creating_app.rst:107
msgid "**pokémon**, which has the same fields as the player, plus a status (active/inactive, that is present on the map or not) and a catch probability (well, let's give our pokémons a chance to escape :-) )"
msgstr "**покемон**, у которого такие же поля, как и у игрока, плюс статус (активный/неактивный, то есть находится ли на карте) и возможность поимки (давайте уж дадим нашим покемонам шанс сбежать :-) )"

#: ../doc/1.7/book/app_server/creating_app.rst:111
msgid "We'll store these entities as tuples in Tarantool spaces. But to deliver our backend application as a microservice, the good practice would be to send/receive our data in the universal JSON format, thus using Tarantool as a document storage."
msgstr "Эти данные будем хранить как кортежи в спейсах Tarantool'а. Но Но чтобы бэкенд-приложение работало как микросервис, правильно будет отправлять/получать данные в универсальном формате JSON, используя Tarantool в качестве системы хранения документов."

#: ../doc/1.7/book/app_server/creating_app.rst:119
msgid "Avro schemas"
msgstr "Avro-схемы"

#: ../doc/1.7/book/app_server/creating_app.rst:121
msgid "To store JSON data as tuples, we will apply a savvy practice which reduces data footprint and ensures all stored documents are valid. We will use Tarantool module `avro-schema <https://github.com/tarantool/avro-schema>`_ which checks the schema of a JSON document and converts it to a Tarantool tuple. The tuple will contain only field values, and thus take a lot less space than the original document. In avro-schema terms, converting JSON documents to tuples is \"flattening\", and restoring the original documents is \"unflattening\". The usage is quite straightforward:"
msgstr "Чтобы хранить JSON-данные в виде кортежей, используем продвинутую методику, которая уменьшит отпечаток данных и обеспечит пригодность всех сохраняемых документов. Будем использовать Tarantool-модуль `avro-schema <https://github.com/tarantool /avro-schema>`_, который проверяет схему JSON-документа и конвертирует его в кортеж Tarantool'а. Кортеж будет содержать только значения полей, таким образом, занимая меньше места, чем оригинальный документ. С точки зрения avro-схемы, конвертация JSON-документов в кортежи - \"flattening\" (конвертация в плоские файлы), а восстановление оригинальных документов - \"unflattening\" (конвертация из плоских файлов). Использовать модуль достаточно просто:"

#: ../doc/1.7/book/app_server/creating_app.rst:130
msgid "For each entity, we need to define a schema in `Apache Avro schema <https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the entity's fields with their names and `Avro data types <http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."
msgstr "Для каждой сущности необходимо определить схему в синтаксисе `схемы Apache Avro <https://en.wikipedia.org/wiki/Apache_Avro>`_, где мы перечисляем поля сущности с их наименованиями и `типами данных по Avro <http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."

#: ../doc/1.7/book/app_server/creating_app.rst:134
msgid "At initialization, we call ``avro-schema.create()`` that creates objects in memory for all schema entities, and ``compile()`` that generates flatten/unflatten methods for each entity."
msgstr "При инициализации мы вызываем функцию ``avro-schema.create()``, которая создает объекты в памяти для всех сущностей схемы, а также функцию ``compile()``, которая создает методы flatten/unflatten (конвертация в плоские файлы и обратно) для каждой сущности."

#: ../doc/1.7/book/app_server/creating_app.rst:137
msgid "Further on, we just call flatten/unflatten methods for a respective entity on receiving/sending the entity's data."
msgstr "Далее мы просто вызываем методы flatten/unflatten для соответствующей сущности при получении/отправке данных об этой сущности."

#: ../doc/1.7/book/app_server/creating_app.rst:140
msgid "Here's what our schema definitions for the player and pokémon entities look like:"
msgstr "Вот как будут выглядеть определения схемы для сущностей игрока и покемона:"

#: ../doc/1.7/book/app_server/creating_app.rst:142
msgid ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"local schema = {\n"
"            player = {\n"
"                type=\"record\",\n"
"                name=\"player_schema\",\n"
"                fields={\n"
"                    {name=\"id\", type=\"long\"},\n"
"                    {name=\"name\", type=\"string\"},\n"
"                    {\n"
"                        name=\"location\",\n"
"                        type= {\n"
"                            type=\"record\",\n"
"                            name=\"player_location\",\n"
"                            fields={\n"
"                                {name=\"x\", type=\"double\"},\n"
"                                {name=\"y\", type=\"double\"}\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"            },\n"
"            pokemon = {\n"
"                type=\"record\",\n"
"                name=\"pokemon_schema\",\n"
"                fields={\n"
"                    {name=\"id\", type=\"long\"},\n"
"                    {name=\"status\", type=\"string\"},\n"
"                    {name=\"name\", type=\"string\"},\n"
"                    {name=\"chance\", type=\"double\"},\n"
"                    {\n"
"                        name=\"location\",\n"
"                        type= {\n"
"                            type=\"record\",\n"
"                            name=\"pokemon_location\",\n"
"                            fields={\n"
"                                {name=\"x\", type=\"double\"},\n"
"                                {name=\"y\", type=\"double\"}\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"            }\n"
"        }"

#: ../doc/1.7/book/app_server/creating_app.rst:187
msgid "And here's how we create and compile our entities at initialization:"
msgstr "А вот как мы создадим и скомпилируем наши сущности при инициализации:"

#: ../doc/1.7/book/app_server/creating_app.rst:189
msgid ""
"-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""
"-- загрузить модуль avro-schema с директивой require()\n"
"        local avro = require('avro_schema')\n"
"        \n"
"        -- создать модели\n"
"        local ok_m, pokemon = avro.create(schema.pokemon)\n"
"        local ok_p, player = avro.create(schema.player)\n"
"        if ok_m and ok_p then\n"
"            -- скомпилировать модели\n"
"            local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"            local ok_cp, compiled_player = avro.compile(player)\n"
"            if ok_cm and ok_cp then\n"
"                -- начать игру\n"
"                <...>\n"
"            else\n"
"                log.error('Schema compilation failed')\n"
"            end\n"
"        else\n"
"            log.info('Schema creation failed')\n"
"        end\n"
"        return false"

#: ../doc/1.7/book/app_server/creating_app.rst:212
msgid "As for the map entity, it would be an overkill to introduce a schema for it, because we have only one map in the game, it has very few fields, and -- which is most important -- we use the map only inside our logic, never exposing it to external users."
msgstr "Что касается сущности карты, вводить для нее схему будет перебор, потому что в игре всего одна карта, у нее мало полей, и — что самое главное — мы используем карту только внутри нашей логики, не показывая ее внешним пользователям."

#: ../doc/1.7/book/app_server/creating_app.rst:220
msgid "Next, we need methods to implement the game logic. To simulate object-oriented programming in our Lua code, let's store all Lua functions and shared variables in a single local variable (let's name it as ``game``). This will allow us to address functions or variables from within our module as ``self.func_name`` or ``self.var_name``. Like this:"
msgstr "Далее нам нужны методы для имплементации игровой логики. Чтобы смоделировать объектно-ориентированное программирование в нашем Lua-коде, будем хранить все Lua-функции и общие переменные в одной внутренней переменной (назовем ее ``game``). Это позволит нам обращаться к функциям или переменным из нашего модуля с помощью ``self.func_name`` или ``self.var_name`` следующим образом:"

#: ../doc/1.7/book/app_server/creating_app.rst:226
msgid ""
"local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""
"local game = {\n"
"            -- локальная переменная\n"
"            num_players = 0,\n"
"        \n"
"            -- метод, который выводит локальную переменную\n"
"            hello = function(self)\n"
"              print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"            end,\n"
"        \n"
"            -- метод, который вызывает другой метод и возвращает локальную переменную\n"
"            sign_in = function(self)\n"
"              self.num_players = self.num_players + 1\n"
"              self:hello()\n"
"              return self.num_players\n"
"            end\n"
"        }"

#: ../doc/1.7/book/app_server/creating_app.rst:245
msgid "In OOP terms, we can now regard local variables inside ``game`` as object fields, and local functions as object methods."
msgstr "В терминах ООП сейчас мы можем рассматривать внутренние переменные внутри переменной ``game`` как поля объекта, а внутренние функции — как методы объекта."

#: ../doc/1.7/book/app_server/creating_app.rst:250
msgid "In this manual, Lua examples use **local** variables. Use **global** variables with caution, since the module’s users may be unaware of them."
msgstr "Обратите внимание, что в текущей документации в примерах Lua-кода используются *локальные* переменные. Используйте *глобальные* переменные аккуратно, поскольку пользователи ваших модулей могут не знать об этих переменных."

#: ../doc/1.7/book/app_server/creating_app.rst:253
msgid "To enable/disable the use of undeclared global variables in your Lua code, use Tarantool's :ref:`strict <strict-module>` module."
msgstr "Чтобы включить/отключить использование необъявленных глобальных переменных в вашем коде на языке Lua, используйте модуль Tarantool'а :ref:`strict <strict-module>`."

#: ../doc/1.7/book/app_server/creating_app.rst:256
msgid "So, our game module will have the following methods:"
msgstr "Таким образом, в модуле игры будут следующие методы:"

#: ../doc/1.7/book/app_server/creating_app.rst:258
msgid "``catch()`` to calculate whether the pokémon was caught (besides the coordinates of both the player and pokémon, this method will apply a probability factor, so not every pokémon within the player's reach will be caught);"
msgstr "``catch()`` (поймать) для расчета, когда был пойман покемон (помимо координат как игрока, так и покемона, этот метод будет использовать коэффициент вероятности, чтобы в пределах досягаемости игрока можно было поймать не каждого покемона);"

#: ../doc/1.7/book/app_server/creating_app.rst:262
msgid "``respawn()`` to add missing pokémons to the map, say, every 60 seconds (we assume that a frightened pokémon runs away, so we remove a pokémon from the map on any catch attempt and add it back to the map in a while);"
msgstr "``respawn()`` (респаун) для добавления отсутствующих покемонов на карту, скажем, каждые 60 секунд (предположим, что испуганный покемон убегает, поэтому мы убираем покемона с карты при любой попытке поймать его и через некоторое время добавляем обратно на карту);"

#: ../doc/1.7/book/app_server/creating_app.rst:265
msgid "``notify()`` to log information about caught pokémons (like \"Player 1 caught pokémon A\");"
msgstr "``notify()`` (уведомить) для записи информации о пойманных покемонах (например, \"Игрок 1 поймал покемона A\");"

#: ../doc/1.7/book/app_server/creating_app.rst:267
msgid "``start()`` to initialize the game (it will create database spaces, create and compile avro schemas, and launch ``respawn()``)."
msgstr "``start()`` (начать) для инициализации игры (метод создаст спейсы в базе данных, создаст и скомпилирует avro-схемы, а также запустит метод ``respawn()``)."

#: ../doc/1.7/book/app_server/creating_app.rst:270
msgid "Besides, it would be convenient to have methods for working with Tarantool storage. For example:"
msgstr "Кроме того, было бы удобно завести методы для работы с хранилищем Tarantool'а. Например:"

#: ../doc/1.7/book/app_server/creating_app.rst:273
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr "``add_pokemon()`` (добавить покемона) для добавления покемона в базу данных и"

#: ../doc/1.7/book/app_server/creating_app.rst:274
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr "``map()`` (карта) для заполнения карты всеми покемонами, которые хранятся в Tarantool'е."

#: ../doc/1.7/book/app_server/creating_app.rst:276
msgid "We'll need these two methods primarily when initializing our game, but we can also call them later, for example to test our code."
msgstr "Эти два метода будут главным образом образом использоваться во время инициализации нашей игры, но их также можно вызывать позднее, например для тестирования кода."

#: ../doc/1.7/book/app_server/creating_app.rst:283
msgid "Bootstrapping a database"
msgstr "Настройка базы данных"

#: ../doc/1.7/book/app_server/creating_app.rst:285
msgid "Let's discuss game initialization. In ``start()`` method, we need to populate Tarantool spaces with pokémon data. Why not keep all game data in memory? Why use a database? The answer is: :ref:`persistence <index-box_persistence>`. Without a database, we risk losing data on power outage, for example. But if we store our data in an in-memory database, Tarantool takes care to persist it on disk whenever it's changed. This gives us one more benefit: quick startup in case of failure. Tarantool has a :ref:`smart algorithm <internals-recovery_process>` that quickly loads all data from disk into memory on startup, so the warm-up takes little time."
msgstr "Обсудим инициализацию игры. В методе ``start()`` нам нужно заполнить спейсы Tarantool'а данными о покемонах. Почему бы не хранить все игровые данные в памяти? Зачем нужна база данных? Ответ на это: :ref:`персистентность <index-box_persistence>`. Без базы данных мы рискуем потерять данные при отключении электроэнергии, например. Но если мы храним данные в in-memory базе данных, Tarantool позаботится о том, чтобы обеспечить постоянное хранение данных при их изменении. Это дает дополнительное преимущество: быстрая загрузка в случае отказа. :ref:`Умный алгоритм <internals-recovery_process>` Tarantool'а быстро загружает все данные с диска в память при начале работы, так что подготовка к работе не займет много времени."

#: ../doc/1.7/book/app_server/creating_app.rst:295
msgid "We'll be using functions from Tarantool built-in :ref:`box <box-module>` module:"
msgstr "Мы будем использовать функции из встроенного модуля Tarantool'а :ref:`box <box-module>`:"

#: ../doc/1.7/book/app_server/creating_app.rst:297
msgid "``box.schema.create_space('pokemons')`` to create a space named ``pokemon`` for storing information about pokémons (we don't create a similar space for players, because we intend to only send/receive player information via API calls, so we needn't store it);"
msgstr "``box.schema.create_space('pokemons')`` для создания спейса под названием ``pokemon`` (покемон), чтобы хранить информацию о покемонах (мы не создаем аналогичный спейс по игрокам, потому что планируем только отправлять и получать информацию об игроках с помощью вызовов API, так что нет необходимости хранить ее);"

#: ../doc/1.7/book/app_server/creating_app.rst:301
msgid "``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr "``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})`` для создания первичного HASH-индекса по ID покемона;"

#: ../doc/1.7/book/app_server/creating_app.rst:303
msgid "``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, 'str'}})`` to create a secondary TREE index by pokémon status."
msgstr "``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, 'str'}})`` для создания вторичного TREE-индекса по статусу покемона."

#: ../doc/1.7/book/app_server/creating_app.rst:306
msgid "Notice the ``parts =`` argument in the index specification. The pokémon ID is the first field in a Tarantool tuple since it’s the first member of the respective Avro type. So does the pokémon status. The actual JSON document may have ID or status fields at any position of the JSON map."
msgstr "Обратите внимание на аргумент ``parts =`` в спецификации индекса. ID покемона — это первое поле в кортеже Tarantool'а, потому что это первый элемент соответствующего типа Avro. То же относится к статусу покемона. В самом JSON-файле поля ID или статуса могут быть в любом положении на JSON-карте."

#: ../doc/1.7/book/app_server/creating_app.rst:311
msgid "The implementation of ``start()`` method looks like this:"
msgstr "Имплементация метода ``start()`` выглядит следующим образом:"

#: ../doc/1.7/book/app_server/creating_app.rst:313
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""
"-- создать игровой объект\n"
"        start = function(self)\n"
"            -- создать спейсы и индексы\n"
"            box.once('init', function()\n"
"                box.schema.create_space('pokemons')\n"
"                box.space.pokemons:create_index(\n"
"                    \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"                )\n"
"                box.space.pokemons:create_index(\n"
"                    \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"                )\n"
"            end)\n"
"        \n"
"            -- создать модели\n"
"            local ok_m, pokemon = avro.create(schema.pokemon)\n"
"            local ok_p, player = avro.create(schema.player)\n"
"            if ok_m and ok_p then\n"
"                -- скомпилировать модели\n"
"                local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"                local ok_cp, compiled_player = avro.compile(player)\n"
"                if ok_cm and ok_cp then\n"
"                    -- начать игру\n"
"                    <...>\n"
"                else\n"
"                    log.error('Schema compilation failed')\n"
"                end\n"
"            else\n"
"                log.info('Schema creation failed')\n"
"            end\n"
"            return false\n"
"        end"

#: ../doc/1.7/book/app_server/creating_app.rst:351
msgid "GIS"
msgstr "ГИС"

#: ../doc/1.7/book/app_server/creating_app.rst:353
msgid "Now let's discuss ``catch()``, which is the main method in our gaming logic."
msgstr "Теперь обсудим метод ``catch()``, который является основным в логике нашей игры."

#: ../doc/1.7/book/app_server/creating_app.rst:355
msgid "Here we receive the player's coordinates and the target pokémon's ID number, and we need to answer whether the player has actually caught the pokémon or not (remember that each pokémon has a chance to escape)."
msgstr "Здесь мы получаем координаты игрока и номер ID искомого покемона, а нужен нам ответ на вопрос, поймали ли игрок покемона (помните, что у каждого покемона есть шанс убежать)."

#: ../doc/1.7/book/app_server/creating_app.rst:359
msgid "First thing, we validate the received player data against its :ref:`Avro schema <app_server-avro_schemas>`. And we check whether such a pokémon exists in our database and is displayed on the map (the pokémon must have the active status):"
msgstr "Для начала проверим полученные данные об игроке по :ref:`Avro-схеме <app_server-avro_schemas>`. Также проверим, есть ли такой покемон в базе данных, и отображается ли он на карте (у покемона должен быть активный статус):"

#: ../doc/1.7/book/app_server/creating_app.rst:364
msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""
"catch = function(self, pokemon_id, player)\n"
"            -- проверить данные игрока\n"
"            local ok, tuple = self.player_model.flatten(player)\n"
"            if not ok then\n"
"                return false\n"
"            end\n"
"            -- получить данные покемона\n"
"            local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"            if p_tuple == nil then\n"
"                return false\n"
"            end\n"
"            local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"            if not ok then\n"
"                return false\n"
"            end\n"
"            if pokemon.status ~= self.state.ACTIVE then\n"
"                return false\n"
"            end\n"
"            -- логика поимки будет дополняться\n"
"            <...>\n"
"        end"

#: ../doc/1.7/book/app_server/creating_app.rst:388
msgid "Next, we calculate the answer: caught or not."
msgstr "Далее вычисляем ответ: пойман или нет."

#: ../doc/1.7/book/app_server/creating_app.rst:390
msgid "To work with geographical coordinates, we use Tarantool `gis <https://github.com/tarantool/gis>`_ module."
msgstr "Чтобы работать с географическими координатами, используем модуль Tarantool'а `gis <https://github.com/tarantool/gis>`_."

#: ../doc/1.7/book/app_server/creating_app.rst:393
msgid "To keep things simple, we don't load any specific map, assuming that we deal with a world map. And we do not validate incoming coordinates, assuming again that all received locations are within the planet Earth."
msgstr "Чтобы не усложнять, не будем загружать какую-то особую карту, допуская, что рассматриваем карту мира. Также не будет проверять поступающие координаты, снова допуская, что все места находятся на планете Земля."

#: ../doc/1.7/book/app_server/creating_app.rst:397
msgid "We use two geo-specific variables:"
msgstr "Используем две географические переменные:"

#: ../doc/1.7/book/app_server/creating_app.rst:399
msgid "``wgs84``, which stands for the latest revision of the World Geodetic System standard, `WGS84 <https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically, it comprises a standard coordinate system for the Earth and represents the Earth as an ellipsoid."
msgstr "``wgs84``, что означает последнюю редакцию стандарта Мировой геодезической системы координат, `WGS84 <https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. В целом, она представляет собой стандартную систему координат Земли и изображает Землю как эллипсоид."

#: ../doc/1.7/book/app_server/creating_app.rst:403
msgid "``nationalmap``, which stands for the `US National Atlas Equal Area <https://epsg.io/2163>`_. This is a projected coordinates system based on WGS84. It gives us a zero base for location projection and allows positioning our players and pokémons in meters."
msgstr "``nationalmap``, что означает `Государственный атлас США в равновеликой проекции (US National Atlas Equal Area) <https://epsg.io/2163>`_. Это система спроецированных координат на основании WGS84. Она дает основу для проецирования мест и позволяет определить местоположение наших игроков и покемонов в метрах."

#: ../doc/1.7/book/app_server/creating_app.rst:408
msgid "Both these systems are listed in the EPSG Geodetic Parameter Registry, where each system has a unique number. In our code, we assign these listing numbers to respective variables:"
msgstr "Обе системы указаны в Реестре геодезических параметров EPSG, где каждой системе присвоен уникальный номер. Мы назначим эти числа соответствующим переменным в нашем коде:"

#: ../doc/1.7/book/app_server/creating_app.rst:412
msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""
"wgs84 = 4326,\n"
"        nationalmap = 2163,"

#: ../doc/1.7/book/app_server/creating_app.rst:417
msgid "For our game logic, we need one more variable, ``catch_distance``, which defines how close a player must get to a pokémon before trying to catch it. Let's set the distance to 100 meters."
msgstr "Для игровой логики необходима еще одна переменная ``catch_distance``, которая определяет, насколько близко игрок должен подойти к покемону, чтобы попытаться поймать его. Определим это расстояние в 100 метров."

#: ../doc/1.7/book/app_server/creating_app.rst:421
msgid "catch_distance = 100,"
msgstr "catch_distance = 100,"

#: ../doc/1.7/book/app_server/creating_app.rst:425
msgid "Now we're ready to calculate the answer. We need to project the current location of both player (``p_pos``) and pokémon (``m_pos``) on the map, check whether the player is close enough to the pokémon (using ``catch_distance``), and calculate whether the player has caught the pokémon (here we generate some random value and let the pokémon escape if the random value happens to be less than 100 minus pokémon's chance value):"
msgstr "Теперь можно рассчитать ответ. Необходимо спроецировать текущее местоположение как игрока (``p_pos``), так и покемона (``m_pos``) на карте, проверить, достаточно ли близко к покемону находится игрок (с помощью ``catch_distance``), и рассчитать, поймал ли игрок покемона (здесь мы генерируем случайное значение, и покемон убегает, если случайное значение оказывается меньше, чем 100 минус случайная величина покемона):"

#: ../doc/1.7/book/app_server/creating_app.rst:432
msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""
"-- спроецировать местоположение\n"
"        local m_pos = gis.Point(\n"
"            {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"        ):transform(self.nationalmap)\n"
"        local p_pos = gis.Point(\n"
"            {player.location.x, player.location.y}, self.wgs84\n"
"        ):transform(self.nationalmap)\n"
"        \n"
"        -- проверить условие близости игрока\n"
"        if p_pos:distance(m_pos) > self.catch_distance then\n"
"            return false\n"
"        end\n"
"        -- попытаться поймать покемона\n"
"        local caught = math.random(100) >= 100 - pokemon.chance\n"
"        if caught then\n"
"            -- обновить и сообщить об успехе\n"
"            box.space.pokemons:update(\n"
"                pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"            )\n"
"            self:notify(player, pokemon)\n"
"        end\n"
"        return caught"

#: ../doc/1.7/book/app_server/creating_app.rst:461
msgid "Index iterators"
msgstr "Итератор с индексом"

#: ../doc/1.7/book/app_server/creating_app.rst:463
msgid "By our gameplay, all caught pokémons are returned back to the map. We do this for all pokémons on the map every 60 seconds using ``respawn()`` method. We iterate through pokémons by status using Tarantool index iterator function :ref:`index:pairs <box_index-index_pairs>` and reset the statuses of all \"caught\" pokémons back to \"active\" using ``box.space.pokemons:update()``."
msgstr "По сюжету игры все пойманные покемоны возвращаются на карту. Метод ``respawn()`` обеспечивает это для всех покемонов на карте каждые 60 секунд. Мы выполняем перебор покемонов по статусу с помощью функции Tarantool'а итератора с индексом :ref:`index:pairs <box_index-index_pairs>` и сбрасываем статусы всех \"пойманных\" покемонов обратно на \"активный\" с помощью ``box.space.pokemons:update()``."

#: ../doc/1.7/book/app_server/creating_app.rst:469
msgid ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""
"respawn = function(self)\n"
"            fiber.name('Respawn fiber')\n"
"            for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                   self.state.CAUGHT) do\n"
"                box.space.pokemons:update(\n"
"                    tuple[self.ID],\n"
"                    {{'=', self.STATUS, self.state.ACTIVE}}\n"
"                )\n"
"            end\n"
"         end"

#: ../doc/1.7/book/app_server/creating_app.rst:482
msgid "For readability, we introduce named fields:"
msgstr "Для удобства введем именованные поля:"

#: ../doc/1.7/book/app_server/creating_app.rst:484
msgid "ID = 1, STATUS = 2,"
msgstr "ID = 1, STATUS = 2,"

#: ../doc/1.7/book/app_server/creating_app.rst:487
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr "Имплементация метода ``start()`` полностью теперь выглядит так:"

#: ../doc/1.7/book/app_server/creating_app.rst:489
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""
"-- создать игровой объект\n"
"        start = function(self)\n"
"            -- создать спейсы и индексы\n"
"            box.once('init', function()\n"
"               box.schema.create_space('pokemons')\n"
"               box.space.pokemons:create_index(\n"
"                   \"primary\", {type = 'hash', parts = {1, 'unsigned'}}}n        )\n"
"               box.space.pokemons:create_index(\n"
"                   \"status\", {type = \"tree\", parts = {2, 'str'}}}n        )\n"
"            end)\n"
"        \n"
"            -- создать модели\n"
"            local ok_m, pokemon = avro.create(schema.pokemon)\n"
"            local ok_p, player = avro.create(schema.player)\n"
"            if ok_m and ok_p then\n"
"                -- скомпилировать модели\n"
"                local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"                local ok_cp, compiled_player = avro.compile(player)\n"
"                if ok_cm and ok_cp then\n"
"                    -- начать игру\n"
"                    self.pokemon_model = compiled_pokemon\n"
"                    self.player_model = compiled_player\n"
"                    self.respawn()\n"
"                    log.info('Started')\n"
"                    return true\n"
"                 else\n"
"                    log.error('Schema compilation failed')\n"
"                 end\n"
"            else\n"
"                log.info('Schema creation failed')\n"
"            end\n"
"            return false\n"
"        end"

#: ../doc/1.7/book/app_server/creating_app.rst:529
#: ../doc/1.7/reference/reference_lua/fiber.rst:132
msgid "Fibers"
msgstr "Файберы"

#: ../doc/1.7/book/app_server/creating_app.rst:531
msgid "But wait! If we launch it as shown above -- ``self.respawn()`` -- the function will be executed only once, just like all the other methods. But we need to execute ``respawn()`` every 60 seconds. Creating a :ref:`fiber <fiber-module>` is the Tarantool way of making application logic work in the background at all times."
msgstr "Но подождите! Если мы запустим функцию ``self.respawn()``, как показано выше, то она запустится только один раз, как и остальные методы. А нам необходимо запускать ``respawn()`` каждые 60 секунд. Tarantool заставляет логику приложения непрерывно работать в фоновом режиме с помощью :ref:`файбера <fiber-module>`."

#: ../doc/1.7/book/app_server/creating_app.rst:537
msgid "A **fiber** exists for executing instruction sequences but it is not a thread. The key difference is that threads use preemptive multitasking, while fibers use cooperative multitasking. This gives fibers the following two advantages over threads:"
msgstr "**Файбер** предназначен для выполнения последовательностей команд, но это не поток. Ключевое отличие в том, что потоки используют многозадачность с реализацией приоритетов, тогда как файберы используют кооперативную многозадачность. Это дает файберам два преимущества над потоками:"

#: ../doc/1.7/book/app_server/creating_app.rst:542
msgid "Better controllability. Threads often depend on the kernel's thread scheduler to preempt a busy thread and resume another thread, so preemption may occur unpredictably. Fibers yield themselves to run another fiber while executing, so yields are controlled by application logic."
msgstr "Улучшенная управляемость. Потоки часто зависят от планировщика потока ядра в вопросе вытеснения занятого потока и возобновления другого потока, поэтому вытеснение может быть непредвиденным. Файберы передают управление самостоятельно другому файберу во время работы, поэтому управление файберами осуществляется логикой приложения."

#: ../doc/1.7/book/app_server/creating_app.rst:546
msgid "Higher performance. Threads require more resources to preempt as they need to address the system kernel. Fibers are lighter and faster as they don't need to address the kernel to yield."
msgstr "Повышенная производительность. Потокам необходимо больше ресурсов для вытеснения, поскольку они обращаются к ядру системы. Файберы легче и быстрее, поскольку для передачи управления им не нужно обращаться к ядру."

#: ../doc/1.7/book/app_server/creating_app.rst:550
msgid "Yet fibers have some limitations as compared with threads, the main limitation being no multi-core mode. All fibers in an application belong to a single thread, so they all use the same CPU core as the parent thread. Meanwhile, this limitation is not really serious for Tarantool applications, because a typical bottleneck for Tarantool is the HDD, not the CPU."
msgstr "Однако у файберов есть определенные ограничения, по сравнению с потоками, основное из которых — отсутствие режима работы с многоядерной системой. Все файберы в приложении относятся к одному потоку, поэтому они используют то же ядро процессора, что и родительский поток. В то же время, это ограничение незначительно для приложений Tarantool'а, поскольку узкое место Tarantool'а — жесткий диск, а не ЦП."

#: ../doc/1.7/book/app_server/creating_app.rst:556
msgid "A fiber has all the features of a Lua `coroutine <http://www.lua.org/pil/contents.html#9>`_ and all programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr "У файбера есть все возможности `сопрограммы <http://www.lua.org/pil/contents.html#9>`_ на языке Lua, и все принципы программирования, которые применяются к сопрограммам на Lua, применимы и к файберам. Однако Tarantool расширил возможности файберов для внутреннего использования. Поэтому, несмотря на возможность и поддержку использования сопрограмм, рекомендуется использовать файберы."

#: ../doc/1.7/book/app_server/creating_app.rst:563
msgid "Well, performance or controllability are of little importance in our case. We'll launch ``respawn()`` in a fiber to make it work in the background all the time. To do so, we'll need to amend ``respawn()``:"
msgstr "Производительность или управляемость не слишком важны в нашем случае. Запустим ``respawn()`` в файбере для непрерывной работы в фоновом режиме. Для этого необходимо изменить ``respawn()``:"

#: ../doc/1.7/book/app_server/creating_app.rst:567
msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""
"respawn = function(self)\n"
"            -- назовем наш файбер;\n"
"            -- это выполнит чистый вывод в fiber.info()\n"
"            fiber.name('Respawn fiber')\n"
"            while true do\n"
"                for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                        self.state.CAUGHT) do\n"
"                    box.space.pokemons:update(\n"
"                        tuple[self.ID],\n"
"                        {{'=', self.STATUS, self.state.ACTIVE}}\n"
"                    )\n"
"                end\n"
"                fiber.sleep(self.respawn_time)\n"
"            end\n"
"        end"

#: ../doc/1.7/book/app_server/creating_app.rst:585
msgid "and call it as a fiber in ``start()``:"
msgstr "и назвать его файбером в ``start()``:"

#: ../doc/1.7/book/app_server/creating_app.rst:587
msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""
"start = function(self)\n"
"            -- создать спейсы и индексы\n"
"                <...>\n"
"            -- создать модели\n"
"                <...>\n"
"            -- скомпилировать модели\n"
"                <...>\n"
"            -- начать игру\n"
"               self.pokemon_model = compiled_pokemon\n"
"               self.player_model = compiled_player\n"
"               fiber.create(self.respawn, self)\n"
"               log.info('Started')\n"
"            -- ошибки, если создание схемы или компиляция не работает\n"
"               <...>\n"
"        end"

#: ../doc/1.7/book/app_server/creating_app.rst:607
#: ../doc/1.7/reference/configuration/index.rst:235
msgid "Logging"
msgstr "Запись в журнал"

#: ../doc/1.7/book/app_server/creating_app.rst:609
msgid "One more helpful function that we used in ``start()`` was ``log.infо()`` from Tarantool :ref:`log <log-module>` module. We also need this function in ``notify()`` to add a record to the log file on every successful catch:"
msgstr "В  ``start()`` мы использовали еще одну полезную функцию — ``log.infо()`` из :ref:`модуля log <log-module>` Tarantool'а . Эта функция также понадобится в ``notify()`` для добавления записи в файл журнала при каждой успешной поимке:"

#: ../doc/1.7/book/app_server/creating_app.rst:613
#, python-format
msgid ""
"-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""
"-- уведомление о событии\n"
"        notify = function(self, player, pokemon)\n"
"            log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"        end"

#: ../doc/1.7/book/app_server/creating_app.rst:620
msgid "We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see the log output in console when we launch our application in script mode."
msgstr "Мы используем стандартные :ref:`настройки журнала <cfg_logging>` Tarantool'а, поэтому увидим вывод записей журнала в консоли, когда запустим приложение в режиме скрипта."

#: ../doc/1.7/book/app_server/creating_app.rst:626
msgid "Great! We've discussed all programming practices used in our Lua module (see `pokemon.lua <https://github.com/tarantool/pokemon/blob/master/src/pokemon.lua>`_)."
msgstr "Отлично! Мы обсудили все методики программирования, используемые в нашем  Lua-модуле (см. `pokemon.lua <https://github.com/tarantool/pokemon/blob/master/src/pokemon.lua>`_)."

#: ../doc/1.7/book/app_server/creating_app.rst:629
msgid "Now let's prepare the test environment. As planned, we write a Lua application (see `game.lua <https://github.com/tarantool/pokemon/blob/master/game.lua>`_) to initialize Tarantool's database module, initialize our game, call the game loop and simulate a couple of player requests."
msgstr "Теперь подготовим среду тестирования. Как и планировалось, напишем приложение на языке Lua (см. `game.lua <https://github.com/tarantool/pokemon/blob/master/game.lua>`_), чтобы инициализировать модуль базы данных Tarantool'а, инициализировать нашу игру, вызвать цикл игры и смоделировать пару запросов от игроков."

#: ../doc/1.7/book/app_server/creating_app.rst:634
msgid "To launch our microservice, we put both ``pokemon.lua`` module and ``game.lua`` application in the current directory, install all external modules, and launch the Tarantool instance running our ``game.lua`` application (this example is for Ubuntu):"
msgstr "Чтобы запустить микросервис, поместим модуль ``pokemon.lua`` и приложение  ``game.lua`` в текущую директорию, установим все внешние модули и запустим экземпляр Tarantool'а с работают приложением ``game.lua`` (это пример для Ubuntu):"

#: ../doc/1.7/book/app_server/creating_app.rst:639
msgid ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""
"$ ls\n"
"        game.lua  pokemon.lua\n"
"        $ sudo apt-get install tarantool-gis\n"
"        $ sudo apt-get install tarantool-avro-schema\n"
"        $ tarantool game.lua"

#: ../doc/1.7/book/app_server/creating_app.rst:647
msgid "Tarantool starts and initializes the database. Then Tarantool executes the demo logic from ``game.lua``: adds a pokémon named Pikachu (its chance to be caught is very high, 99.1), displays the current map (it contains one active pokémon, Pikachu) and processes catch requests from two players. Player1 is located just near the lonely Pikachu pokémon and Player2 is located far away from it. As expected, the catch results in this output are \"true\" for Player1 and \"false\" for Player2. Finally, Tarantool displays the current map which is empty, because Pikachu is caught and temporarily inactive:"
msgstr "Tarantool запускает и инициализирует базу данных. Затем Tarantool выполняет демо-логику из ``game.lua``: добавляет покемона под названием Пикачу (Pikachu) (шанс его поимки очень высок - 99,1), отображает текущую карту (на ней расположен один активный покемон, Пикачу) и обрабатывает запросы поимки от двух игроков. Player1 (Игрок 1) находится очень близко к одинокому покемону Пикачу, а Player2 (Игрок 2) находится очень далеко от него. Как предполагается, результаты поимки в таком выводе будут \"true\" для Player1 и \"false\" для Player2. Наконец, Tarantool отображает текущую карту, которая пуста, потому что Пикачу пойман и временно неактивен:"

#: ../doc/1.7/book/app_server/creating_app.rst:656
msgid ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version 1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': 'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""
"$ tarantool game.lua\n"
"        2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version 1.7.3-43-gf5fa1e1\n"
"        2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"        2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 bytes for tuple arena...\n"
"        2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty  data directory\n"
"        2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"        2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"        2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept requests\n"
"        2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"        ---\n"
"        - {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': 'Pikachu', 'chance': 99.1}\n"
"        ...\n"
"        \n"
"        2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' caught 'Pikachu'\n"
"        true\n"
"        false\n"
"        --- []\n"
"        ...\n"
"        \n"
"        2017-01-09 20:19:24.789 [6282] main C> entering the event loop"

#: ../doc/1.7/book/app_server/creating_app.rst:681
msgid "nginx"
msgstr "nginx"

#: ../doc/1.7/book/app_server/creating_app.rst:683
msgid "In the real life, this microservice would work over HTTP. Let's add `nginx <https://nginx.org/en/>`_ web server to our environment and make a similar demo. But how do we make Tarantool methods callable via REST API? We use nginx with `Tarantool nginx upstream <https://github.com/tarantool/nginx_upstream_module>`_ module and create one more Lua script (`app.lua <https://github.com/tarantool/pokemon/blob/master/src/app.lua>`_) that exports three of our game methods -- ``add_pokemon()``, ``map()`` and ``catch()`` -- as REST endpoints of the nginx upstream module:"
msgstr "В реальной жизни такой микросервис работал бы по HTTP. Добавим веб-сервер `nginx <https://nginx.org/en/>`_ в нашу среду и сделаем аналогичный пример. Но как вызывать методы Tarantool'а с помощью REST API? Мы используем nginx с модулем `Tarantool nginx upstream <https://github.com/tarantool/nginx_upstream_module>`_ и создадим еще один скрипт на Lua (`app.lua <https://github.com/tarantool/pokemon/blob/master/src/app.lua>`_), который экспортирует три наших игровых метода — ``add_pokemon()``, ``map()`` и ``catch()`` — в качестве конечных точек обработки запросов REST модуля nginx upstream:"

#: ../doc/1.7/book/app_server/creating_app.rst:692
msgid ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""
"local game = require('pokemon')\n"
"        box.cfg{listen=3301}\n"
"        game:start()\n"
"        \n"
"        -- функции add, map и catch по REST API\n"
"        function add(request, pokemon)\n"
"            return {\n"
"                result=game:add_pokemon(pokemon)\n"
"            }\n"
"        end\n"
"        \n"
"        function map(request)\n"
"            return {\n"
"                map=game:map()\n"
"            }\n"
"        end\n"
"        \n"
"        function catch(request, pid, player)\n"
"            local id = tonumber(pid)\n"
"            if id == nil then\n"
"                return {result=false}\n"
"            end\n"
"            return {\n"
"                result=game:catch(id, player)\n"
"            }\n"
"        end"

#: ../doc/1.7/book/app_server/creating_app.rst:721
msgid "An easy way to configure and launch nginx would be to create a Docker container based on a `Docker image <https://hub.docker.com/r/tarantool/tarantool-nginx/>`_ with nginx and the upstream module already installed (see `http/Dockerfile <https://github.com/tarantool/pokemon/blob/master/http/Dockerfile>`_). We take a standard `nginx.conf <https://github.com/tarantool/pokemon/blob/master/http/nginx.conf>`_, where we define an upstream with our Tarantool backend running (this is another Docker container, see details below):"
msgstr "Чтобы с легкостью настроить и запустить nginx, необходимо создать Docker-контейнер на основе `Docker-образа <https://hub.docker.com/r/tarantool /tarantool-nginx/>`_ с уже установленными nginx и модулем upstream (см. `http/Dockerfile <https://github.com/tarantool/pokemon/blob/master/http/Dockerfile>`_). Берем стандартный `nginx.conf <https://github.com/tarantool/pokemon/blob/master/http/nginx.conf>`_, где определяем upstream с работающим бэкендом Tarantool'а (это еще один Docker-контейнер, см. нижеприведенную информацию):"

#: ../doc/1.7/book/app_server/creating_app.rst:730
msgid ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""
"upstream tnt {\n"
"              server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"              keepalive 250000;\n"
"        }"

#: ../doc/1.7/book/app_server/creating_app.rst:737
msgid "and add some Tarantool-specific parameters (see descriptions in the upstream module's `README <https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
msgstr "и добавляем специальные параметры для Tarantool'а (см. описание в файле `README <https://github.com/tarantool/nginx_upstream_module#directives>`_ модуля upstream):"

#: ../doc/1.7/book/app_server/creating_app.rst:741
msgid ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""
"server {\n"
"          server_name tnt_test;\n"
"        \n"
"          listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"        \n"
"          location = / {\n"
"              root /usr/local/nginx/html;\n"
"          }\n"
"        \n"
"          location /api {\n"
"            # ответы проверяют бесконечное время ожидания\n"
"            tnt_read_timeout 60m;\n"
"            if ( $request_method = GET ) {\n"
"               tnt_method \"map\";\n"
"            }\n"
"            tnt_http_rest_methods get;\n"
"            tnt_http_methods all;\n"
"            tnt_multireturn_skip_count 2;\n"
"            tnt_pure_result on;\n"
"            tnt_pass_http_request on parse_args;\n"
"            tnt_pass tnt;\n"
"          }\n"
"        }"

#: ../doc/1.7/book/app_server/creating_app.rst:767
msgid "Likewise, we put Tarantool server and all our game logic in a second Docker container based on the `official Tarantool 1.7 image <https://github.com/tarantool/docker>`_ (see `src/Dockerfile <https://github.com/tarantool/pokemon/blob/master/src/Dockerfile>`_) and set the container's default command to ``tarantool app.lua``. This is the backend."
msgstr "Аналогичным образом, поместим Tarantool-сервер и всю игровую логику в другой Docker-контейнер на основе `официального образа Tarantool'а 1.7 <https://github.com/tarantool/docker>`_ (см. `src/Dockerfile <https://github.com/tarantool/pokemon/blob/master/src/Dockerfile>`_) и установим ``tarantool app.lua`` в качестве стандартной команды для контейнера. Это бэкенд."

#: ../doc/1.7/book/app_server/creating_app.rst:776
msgid "Non-blocking IO"
msgstr "Неблокирующий ввод-вывод"

#: ../doc/1.7/book/app_server/creating_app.rst:778
msgid "To test the REST API, we create a new script (`client.lua <https://github.com/tarantool/pokemon/blob/master/client/client.lua>`_), which is similar to our ``game.lua`` application, but makes HTTP POST and GET requests rather than calling Lua functions:"
msgstr "Чтобы протестировать REST API, создадим новый скрипт (`client.lua <https://github.com/tarantool/pokemon/blob/master/client/client.lua>`_), который похож на наше приложение ``game.lua``, но отправляет запросы HTTP POST и GET, а не вызывает Lua-функции:"

#: ../doc/1.7/book/app_server/creating_app.rst:783
#, python-format
msgid ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""
"local http = require('curl').http()\n"
"        local json = require('json')\n"
"        local URI = os.getenv('SERVER_URI')\n"
"        local fiber = require('fiber')\n"
"        \n"
"        local player1 = {\n"
"            name=\"Player1\",\n"
"            id=1,\n"
"            location = {\n"
"                x=1.0001,\n"
"                y=2.0003\n"
"            }\n"
"        }\n"
"        local player2 = {\n"
"            name=\"Player2\",\n"
"            id=2,\n"
"            location = {\n"
"                x=30.123,\n"
"                y=40.456\n"
"            }\n"
"        }\n"
"        \n"
"        local pokemon = {\n"
"            name=\"Pikachu\",\n"
"            chance=99.1,\n"
"            id=1,\n"
"            status=\"active\",\n"
"            location = {\n"
"                x=1,\n"
"                y=2\n"
"            }\n"
"        }\n"
"        \n"
"        function request(method, body, id)\n"
"            local resp = http:request(\n"
"                method, URI, body\n"
"            )\n"
"            if id ~= nil then\n"
"                print(string.format('Player %d result: %s',\n"
"                    id, resp.body))\n"
"            else\n"
"                print(resp.body)\n"
"            end\n"
"        end\n"
"        \n"
"        local players = {}\n"
"        function catch(player)\n"
"            fiber.sleep(math.random(5))\n"
"            print('Catch pokemon by player ' .. tostring(player.id))\n"
"            request(\n"
"                'POST', '{\"method\": \"catch\",\n"
"                \"params\": [1, '..json.encode(player)..']}',\n"
"                tostring(player.id)\n"
"            )\n"
"            table.insert(players, player.id)\n"
"        end\n"
"        \n"
"        print('Create pokemon')\n"
"        request('POST', '{\"method\": \"add\",\n"
"            \"params\": ['..json.encode(pokemon)..']}')\n"
"        request('GET', '')\n"
"        \n"
"        fiber.create(catch, player1)\n"
"        fiber.create(catch, player2)\n"
"        \n"
"        -- подождать игроков\n"
"        while #players ~= 2 do\n"
"            fiber.sleep(0.001)\n"
"        end\n"
"        \n"
"        request('GET', '')\n"
"        os.exit()"

#: ../doc/1.7/book/app_server/creating_app.rst:858
msgid "When you run this script, you’ll notice that both players have equal chances to make the first attempt at catching the pokémon. In a classical Lua script, a networked call blocks the script until it’s finished, so the first catch attempt can only be done by the player who entered the game first. In Tarantool, both players play concurrently, since all modules are integrated with Tarantool :ref:`cooperative multitasking <atomic-cooperative_multitasking>` and use non-blocking I/O."
msgstr "При запуска этого скрипта вы заметите, что у обоих игроков одинаковые шансы сделать первую попытку поимки покемона. В классическом Lua-скрипте сетевой вызов блокирует скрипт, пока он не будет выполнен, поэтому первым попытаться поймать может тот игрок, который раньше зашел в игру. В Tarantool'е оба игрока играют одновременно, поскольку все модули объединены в :ref:`кооперативной многозадачности <atomic-cooperative_multitasking>` и используют неблокирующий ввод-вывод."

#: ../doc/1.7/book/app_server/creating_app.rst:866
msgid "Indeed, when Player1 makes its first REST call, the script doesn’t block. The fiber running ``catch()`` function on behalf of Player1 issues a non-blocking call to the operating system and yields control to the next fiber, which happens to be the fiber of Player2. Player2’s fiber does the same. When the network response is received, Player1's fiber is activated by Tarantool cooperative scheduler, and resumes its work. All Tarantool :ref:`modules <built_in_modules>` use non-blocking I/O and are integrated with Tarantool cooperative scheduler. For module developers, Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr "Действительно, когда Player1 посылает первый REST-вызов, скрипт не блокируется. Файбер, выполняющий функцию ``catch()`` от Player1, посылает неблокирующий вызов в операционную систему и передает управление на следующий файбер, которым оказывается файбер от Player2. Файбер от Player2 делает то же самое. Когда получен сетевой ответ, файбер от Player1 активируется  с помощью кооперативного планировщика Tarantool'а и возобновляет работу. Все :ref:`модули <built_in_modules>` Tarantool'а используют неблокирующий ввод-вывод и интегрированы с кооперативным планировщиком Tarantool'а. Разработчикам модулей Tarantool предоставляет :ref:`API <index-c_api_reference>`."

#: ../doc/1.7/book/app_server/creating_app.rst:875
msgid "For our HTTP test, we create a third container based on the `official Tarantool 1.7 image <https://github.com/tarantool/docker>`_ (see `client/Dockerfile <https://github.com/tarantool/pokemon/blob/master/client/Dockerfile>`_) and set the container's default command to ``tarantool client.lua``."
msgstr "Для HTTP-теста создадим третий контейнер на основе `официального образа Tarantool'а 1.7 <https://github.com/tarantool/docker>`_ (см. `client/Dockerfile <https://github.com/tarantool/pokemon/blob/master/client/Dockerfile>`_)  установим ``tarantool client.lua`` в качестве стандартной команды для контейнера."

#: ../doc/1.7/book/app_server/creating_app.rst:883
msgid "To run this test locally, download our `pokemon <https://github.com/tarantool/pokemon>`_ project from GitHub and say:"
msgstr "Чтобы запустить тест локально, скачайте наш проект `покемон <https://github.com/tarantool/pokemon>`_ из GitHub и вызовите:"

#: ../doc/1.7/book/app_server/creating_app.rst:886
msgid ""
"$ docker-compose build\n"
"$ docker-compose up"
msgstr ""
"$ docker-compose build\n"
"        $ docker-compose up"

#: ../doc/1.7/book/app_server/creating_app.rst:891
msgid "Docker Compose builds and runs all the three containers: ``pserver`` (Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You can see log messages from all these containers in the console, pclient saying that it made an HTTP request to create a pokémon, made two catch requests, requested the map (empty since the pokémon is caught and temporarily inactive) and exited:"
msgstr "Docker Compose собирает и запускает все три контейнера: ``pserver`` (бэкенд Tarantool'а), ``phttp`` (nginx) и``pclient`` (демо-клиент). ВЫ можете увидеть все сообщения журнала из всех этих контейнеров в консоли. pclient выведет, что сделал HTTP-запрос на создание покемона, два запроса на поимку покемона, запросил карту (пустая, поскольку покемон пойман и временно неактивен) и завершил работу:"

#: ../doc/1.7/book/app_server/creating_app.rst:897
msgid ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | {\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""
"pclient_1  | Create pokemon\n"
"        <...>\n"
"        pclient_1  | {\"result\":true}\n"
"        pclient_1  | {\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]} \n"
"        pclient_1  | Catch pokemon by player 2\n"
"        pclient_1  | Catch pokemon by player 1\n"
"        pclient_1  | Player 1 result: {\"result\":true}\n"
"        pclient_1  | Player 2 result: {\"result\":false}\n"
"        pclient_1  | {\"map\":[]}\n"
"        pokemon_pclient_1 exited with code 0"

#: ../doc/1.7/book/app_server/creating_app.rst:910
msgid "Congratulations! Here's the end point of our walk-through. As further reading, see more about :ref:`installing <app_server-installing_module>` and :ref:`contributing <app_server-contributing_module>` a module."
msgstr "Поздравляем! Вот мы и закончили наш пошаговый пример. Для дальнейшего изучения рекомендуем :ref:`установку <app_server-installing_module>` и :ref:`добавление <app_server-contributing_module>` модуля."

#: ../doc/1.7/book/app_server/creating_app.rst:914
msgid "See also reference on :ref:`Tarantool modules <built_in_modules>` and :ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua cookbook recipes <cookbook>`."
msgstr "См. также справочник по :ref:`модулям Tarantool'а <built_in_modules>` и :ref:`C API <index-c_api_reference>` и не пропустите нашу :ref:`книгу рецептов на Lua <cookbook>`."

#: ../doc/1.7/book/app_server/index.rst:5
msgid "Application server"
msgstr "Сервер приложений"

#: ../doc/1.7/book/app_server/index.rst:7
msgid "In this chapter, we introduce the basics of working with Tarantool as a Lua application server."
msgstr "В данной главе мы рассмотрим основы работы с Tarantool'ом в качестве сервера приложений на языке Lua."

#: ../doc/1.7/book/app_server/index.rst:10 ../doc/1.7/book/box/index.rst:10
#: ../doc/1.7/book/getting_started/index.rst:10
msgid "This chapter contains the following sections:"
msgstr "Эта глава состоит из следующих разделов:"

#: ../doc/1.7/book/app_server/installing_module.rst:5
msgid "Installing a module"
msgstr "Установка модуля"

#: ../doc/1.7/book/app_server/installing_module.rst:7
msgid "Modules in Lua and C that come from Tarantool developers and community contributors are available in the following locations:"
msgstr "Модули на Lua и C от разработчиков Tarantool'а и сторонних разработчиков доступны здесь:"

#: ../doc/1.7/book/app_server/installing_module.rst:10
msgid "Tarantool modules repository, and"
msgstr "Репозиторий модулей Tarantool'а и"

#: ../doc/1.7/book/app_server/installing_module.rst:11
msgid "Tarantool deb/rpm repositories."
msgstr "Репозитории deb/rpm Tarantool'а."

#: ../doc/1.7/book/app_server/installing_module.rst:17
msgid "Installing a module from a repository"
msgstr "Установка модуля из репозитория"

#: ../doc/1.7/book/app_server/installing_module.rst:19
msgid "See `README in tarantool/rocks repository <https://github.com/tarantool/rocks#managing-modules-with-tarantool-174>`_ for detailed instructions."
msgstr "Для получения подробной информации см. `README в репозитории tarantool/rocks <https://github.com/tarantool/rocks#managing-modules-with-tarantool-174>`_."

#: ../doc/1.7/book/app_server/installing_module.rst:27
msgid "Installing a module from deb/rpm"
msgstr "Установка модуля из deb/rpm"

#: ../doc/1.7/book/app_server/installing_module.rst:29
msgid "Follow these steps:"
msgstr "Выполните следующие действия:"

#: ../doc/1.7/book/app_server/installing_module.rst:31
msgid "Install Tarantool as recommended on the `download page <http://tarantool.org/download.html>`_."
msgstr "Установите Tarantool в соответствии с рекомендациями на `странице загрузки <http://tarantool.org/download.html>`_."

#: ../doc/1.7/book/app_server/installing_module.rst:34
msgid "Install the module you need. Look up the module's name on `Tarantool rocks page <http://tarantool.org/rocks.html>`_ and put the prefix \"tarantool-\" before the module name to avoid ambiguity:"
msgstr "Установите необходимый модуль. Найдите имя модуля на `странице со сторонними библиотеками Tarantool'а <http://tarantool.org/rocks.html>`_  и введите префикс \"tarantool-\" перед названием модуля во избежание неоднозначности:"

#: ../doc/1.7/book/app_server/installing_module.rst:38
msgid ""
"$ # for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"$ # for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""
"$ # для Ubuntu/Debian:\n"
"        $ sudo apt-get install tarantool-<module-name>\n"
"        \n"
"        $ # для RHEL/CentOS/Amazon:\n"
"        $ sudo yum install tarantool-<module-name>"

#: ../doc/1.7/book/app_server/installing_module.rst:46
msgid "For example, to install the module `shard <http://github.com/tarantool/shard>`_ on Ubuntu, say:"
msgstr "Например, чтобы установить модуль `shard <http://github.com/tarantool/shard>`_ на Ubuntu, введите:"

#: ../doc/1.7/book/app_server/installing_module.rst:49
#: ../doc/1.7/reference/reference_rock/shard.rst:86
msgid "$ sudo apt-get install tarantool-shard"
msgstr "$ sudo apt-get install tarantool-shard"

#: ../doc/1.7/book/app_server/installing_module.rst:53
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../doc/1.7/book/app_server/installing_module.rst:55
msgid "load any module with"
msgstr "загружать любой модуль с помощью"

#: ../doc/1.7/book/app_server/installing_module.rst:57
msgid "tarantool> name = require('module-name')"
msgstr "tarantool> name = require('module-name')"

#: ../doc/1.7/book/app_server/installing_module.rst:61
msgid "for example:"
msgstr "например:"

#: ../doc/1.7/book/app_server/installing_module.rst:63
msgid "tarantool> shard = require('shard')"
msgstr "tarantool> shard = require('shard')"

#: ../doc/1.7/book/app_server/installing_module.rst:67
msgid "search locally for installed modules using ``package.path`` (Lua) or ``package.cpath`` (C):"
msgstr "локально находить установленные модули с помощью ``package.path`` (Lua) или ``package.cpath`` (C):"

#: ../doc/1.7/book/app_server/installing_module.rst:70
msgid ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; /usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""
"tarantool> package.path\n"
"        ---\n"
"        - ./?.lua;./?/init.lua; /usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"        tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini \n"
"        t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/ \n"
"        usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"        ...\n"
"        \n"
"        tarantool> package.cpath\n"
"        ---\n"
"        - ./?.so;/usr/local/lib/x86_64-linux- gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"        nux- gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"        -linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux- gnu/lua/5.1/?.so;/usr/local/\n"
"        lib/lua/5.1/?.so;\n"
"        ..."

#: ../doc/1.7/book/app_server/installing_module.rst:90
msgid "Question-marks stand for the module name that was specified earlier when saying ``require('module-name')``."
msgstr "Знаки вопроса стоят вместо имени модуля, которое было указано ранее при вызове ``require('module-name')``."

#: ../doc/1.7/book/app_server/launching_app.rst:5
msgid "Launching an application"
msgstr "Запуск приложения"

#: ../doc/1.7/book/app_server/launching_app.rst:7
msgid "Using Tarantool as an application server, you can write your own applications. Tarantool’s native language for writing applications is `Lua <http://www.lua.org/about.html>`_, so a typical application would be a file that contains your Lua script. But you can also write applications in C or C++."
msgstr "Используя Tarantool в качестве сервера приложений, вы можете написать собственные приложения. Собственный язык Tarantool’а для приложений — `Lua <http://www.lua.org/about.html>`_, поэтому типовое приложение представляет собой файл, который содержит Lua-скрипт. Однако вы также можете писать приложения на C или C++."

#: ../doc/1.7/book/app_server/launching_app.rst:15
msgid "If you're new to Lua, we recommend going over the interactive Tarantool tutorial before proceeding with this chapter. To launch the tutorial, say ``tutorial()`` in Tarantool console:"
msgstr "Если вы только осваиваете Lua, рекомендуем выполнить практическое задание по Tarantool'у до работы с данной главой. Для запуска практического задания, выполните команду ``tutorial()`` в консоли Tarantool'а:"

#: ../doc/1.7/book/app_server/launching_app.rst:19
msgid ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""
"tarantool> tutorial()\n"
"        ---\n"
"        - |\n"
"         Tutorial — Screen #1 — Hello, Moon\n"
"         ====================================\n"
"        \n"
"         Welcome to the Tarantool tutorial.\n"
"         It will introduce you to Tarantool’s Lua application server\n"
"         and database server, which is what’s running what you’re seeing.\n"
"         This is INTERACTIVE — you’re expected to enter requests\n"
"         based on the suggestions or examples in the screen’s text.\n"
"         <...>"

#: ../doc/1.7/book/app_server/launching_app.rst:34
msgid "Let's create and launch our first Lua application for Tarantool. Here's a simplest Lua application, the good old \"Hello, world!\":"
msgstr "Создадим и запустим первое приложение на языке Lua для Tarantool'а — самое простое приложение, старую добрую программу \"Hello, world!\":"

#: ../doc/1.7/book/app_server/launching_app.rst:37
msgid ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        print('Hello, world!')"

#: ../doc/1.7/book/app_server/launching_app.rst:42
msgid "We save it in a file. Let it be ``myapp.lua`` in the current directory."
msgstr "Сохраним приложение в файле. Пусть это будет ``myapp.lua`` в текущей директории."

#: ../doc/1.7/book/app_server/launching_app.rst:44
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr "Теперь рассмотрим, как можно запустить наше приложение с Tarantool'ом."

#: ../doc/1.7/book/app_server/launching_app.rst:50
msgid "Launching in Docker"
msgstr "Запуск в Docker"

#: ../doc/1.7/book/app_server/launching_app.rst:52
msgid "If we run Tarantool in a :ref:`Docker container <getting_started-using_docker>`, the following command will start Tarantool without any application:"
msgstr "Если мы запустим Tarantool в :ref:`Docker-контейнере <getting_started-using_docker>`, Tarantool начнет работу без какого-либо приложения после следующей команды:"

#: ../doc/1.7/book/app_server/launching_app.rst:55
msgid ""
"$ # create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool"
msgstr ""
"$ # создать временный контейнер и запустить его в интерактивном режиме\n"
"        $ docker run --rm -t -i tarantool/tarantool"

#: ../doc/1.7/book/app_server/launching_app.rst:60
msgid "To run Tarantool with our application, we can say:"
msgstr "Чтобы запустить Tarantool с нашим приложением, можно выполнить команду:"

#: ../doc/1.7/book/app_server/launching_app.rst:62
msgid ""
"$ # create a temporary container and\n"
"$ # launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool tarantool /opt/tarantool/myapp.lua"
msgstr ""
"$ # создать временный контейнер и\n"
"        $ # запустить Tarantool с нашим приложением\n"
"        $ docker run --rm -t -i \\\n"
"                     -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"                     -v /data/dir/on/host:/var/lib/tarantool \\\n"
"                     tarantool/tarantool tarantool /opt/tarantool/myapp.lua"

#: ../doc/1.7/book/app_server/launching_app.rst:71
msgid "Here two resources on the host get mounted in the container:"
msgstr "Здесь два ресурса подключаются к серверу в контейнере:"

#: ../doc/1.7/book/app_server/launching_app.rst:73
msgid "our application file (``\\`pwd\\`/myapp.lua``) and"
msgstr "наш файл с приложением (``\\`pwd\\`/myapp.lua``) и"

#: ../doc/1.7/book/app_server/launching_app.rst:74
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr "каталог данных  Tarantool'а (``/data/dir/on/host``)."

#: ../doc/1.7/book/app_server/launching_app.rst:76
msgid "By convention, the directory for Tarantool application code inside a container is ``/opt/tarantool``, and the directory for data is ``/var/lib/tarantool``."
msgstr "Традиционно в контейнере директория ``/opt/tarantool`` используется для кода приложения  Tarantool'а, а директория ``/var/lib/tarantool`` используется для данных."

#: ../doc/1.7/book/app_server/launching_app.rst:83
msgid "Launching a binary program"
msgstr "Запуск бинарной программы"

#: ../doc/1.7/book/app_server/launching_app.rst:85
msgid "If we run Tarantool from a :ref:`binary package <getting_started-using_binary>` or from a :ref:`source build <building_from_source>`, we can launch our application:"
msgstr "При запуске Tarantool'а из :ref:`бинарного пакета <getting_started-using_binary>` или :ref:`сборке из исходников <building_from_source>`, можно запустить наше приложение:"

#: ../doc/1.7/book/app_server/launching_app.rst:89
msgid "in the script mode,"
msgstr "в режиме скрипта,"

#: ../doc/1.7/book/app_server/launching_app.rst:90
msgid "as a server application, or"
msgstr "как серверное приложение или"

#: ../doc/1.7/book/app_server/launching_app.rst:91
msgid "as a daemon service."
msgstr "как демон службы."

#: ../doc/1.7/book/app_server/launching_app.rst:93
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr "Самый простой способ — передать имя файла в Tarantool при запуске:"

#: ../doc/1.7/book/app_server/launching_app.rst:95
#: ../doc/1.7/book/app_server/launching_app.rst:186
msgid ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"$"
msgstr ""
"$ tarantool myapp.lua\n"
"        Hello, world!\n"
"        $"

#: ../doc/1.7/book/app_server/launching_app.rst:101
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr "Tarantool запускается, выполняет наш скрипт в **режиме скрипта** и завершает работу."

#: ../doc/1.7/book/app_server/launching_app.rst:103
msgid "Now let’s turn this script into a **server application**. We use :ref:`box.cfg <box_introspection-box_cfg>` from Tarantool’s built-in Lua module to:"
msgstr "Теперь превратим этот скрипт в **серверное приложение**. Используем :ref:`box.cfg <box_introspection-box_cfg>` из встроенного в Tarantool Lua-модуля, чтобы:"

#: ../doc/1.7/book/app_server/launching_app.rst:107
msgid "launch the database (a database has a persistent on-disk state, which needs to be restored after we start an application) and"
msgstr "запустить базу данных (данные в базе находятся в персистентном состоянии на диске, которое следует восстановить после запуска приложения) и"

#: ../doc/1.7/book/app_server/launching_app.rst:109
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr "настроить Tarantool как сервер, который принимает запросы по TCP-порту."

#: ../doc/1.7/book/app_server/launching_app.rst:111
msgid "We also add some simple database logic, using :ref:`space.create() <box_schema-space_create>` and :ref:`create_index() <box_space-create_index>` to create a space with a primary index. We use the function :ref:`box.once() <box-once>` to make sure that our logic will be executed only once when the database is initialized for the first time, so we don't try to create an existing space or index on each invocation of the script:"
msgstr "Также добавим простую логику для базы данных, используя :ref:`space.create() <box_schema-space_create>` и :ref:`create_index() <box_space-create_index>` для создания спейса с первичным индексом. Используем функцию :ref:`box.once() <box-once>`, чтобы обеспечить единовременное выполнение логики после первоначальной инициализации базы данных, поскольку мы не хотим создавать уже существующий спейс или индекс при каждом обращении к скрипту:"

#: ../doc/1.7/book/app_server/launching_app.rst:119
msgid ""
"#!/usr/bin/env tarantool\n"
"-- Configure database\n"
"box.cfg {\n"
"   listen = 3301\n"
"}\n"
"box.once(\"bootstrap\", function()\n"
"   box.schema.space.create('tweedledum')\n"
"   box.space.tweedledum:create_index('primary',\n"
"       { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        -- настроить базу данных\n"
"        box.cfg {\n"
"           listen = 3301\n"
"        }\n"
"        box.once(\"bootstrap\", function()\n"
"           box.schema.space.create('tweedledum')\n"
"           box.space.tweedledum:create_index('primary',\n"
"               { type = 'TREE', parts = {1, 'unsigned'}})\n"
"        end)"

#: ../doc/1.7/book/app_server/launching_app.rst:132
msgid "Now we launch our application in the same manner as before:"
msgstr "Далее запустим наше приложение, как делали ранее:"

#: ../doc/1.7/book/app_server/launching_app.rst:134
msgid ""
"$ tarantool myapp.lua\n"
"Hello, world!\n"
"2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> version 1.7.2-146-g021d36b\n"
"2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
"2016-12-19 16:07:14.251 [41436] main/101/myapp.lua I> mapping 1073741824 bytes for tuple arena...\n"
"2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
"2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovering from `./00000000000000000000.snap'\n"
"2016-12-19 16:07:14.271 [41436] main/101/myapp.lua I> recover from `./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.271 [41436] main/101/myapp.lua I> done `./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.272 [41436] main/102/hot_standby I> recover from `./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
"2016-12-19 16:07:14.275 [41436] iproto/102/iproto I> binary: bound to [::]:3301\n"
"2016-12-19 16:07:14.275 [41436] main/101/myapp.lua I> done `./00000000000000000000.xlog'\n"
"2016-12-19 16:07:14.278 [41436] main/101/myapp.lua I> ready to accept requests"
msgstr ""
"$ tarantool myapp.lua\n"
"        Hello, world!\n"
"        2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> version 1.7.2-146-g021d36b\n"
"        2016-12-19 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
"        2016-12-19 16:07:14.251 [41436] main/101/myapp.lua I> mapping 1073741824 bytes for tuple arena...\n"
"        2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
"        2016-12-19 16:07:14.255 [41436] main/101/myapp.lua I> recovering from `./00000000000000000000.snap'\n"
"        2016-12-19 16:07:14.271 [41436] main/101/myapp.lua I> recover from `./00000000000000000000.xlog'\n"
"        2016-12-19 16:07:14.271 [41436] main/101/myapp.lua I> done `./00000000000000000000.xlog'\n"
"        2016-12-19 16:07:14.272 [41436] main/102/hot_standby I> recover from `./00000000000000000000.xlog'\n"
"        2016-12-19 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
"        2016-12-19 16:07:14.275 [41436] iproto/102/iproto I> binary: bound to [::]:3301\n"
"        2016-12-19 16:07:14.275 [41436] main/101/myapp.lua I> done `./00000000000000000000.xlog'\n"
"        2016-12-19 16:07:14.278 [41436] main/101/myapp.lua I> ready to accept requests"

#: ../doc/1.7/book/app_server/launching_app.rst:151
msgid "This time, Tarantool executes our script and keeps working as a server, accepting TCP requests on port 3301. We can see Tarantool in the current session’s process list:"
msgstr "На этот раз Tarantool выполняет скрипт и продолжает работать в качестве сервера, принимая TCP-запросы на порт 3301. Можно увидеть Tarantool в списке процессов текущей сессии:"

#: ../doc/1.7/book/app_server/launching_app.rst:155
msgid ""
"$ ps | grep \"tarantool\"\n"
"  PID TTY           TIME CMD\n"
"41608 ttys001       0:00.47 tarantool myapp.lua <running>"
msgstr ""
"$ ps | grep \"tarantool\"\n"
"          PID TTY           TIME CMD\n"
"        41608 ttys001       0:00.47 tarantool myapp.lua <running>"

#: ../doc/1.7/book/app_server/launching_app.rst:161
msgid "But the Tarantool instance will stop if we close the current terminal window. To detach Tarantool and our application from the terminal window, we can launch it in the **daemon mode**. To do so, we add some parameters to ``box.cfg{}``:"
msgstr "Однако экземпляр Tarantool'а завершит работу, если мы закроем окно командной строки. Чтобы отделить Tarantool и приложение от окна командной строки, можно запустить **режим демона**. Для этого добавим некоторые параметры в ``box.cfg{}``:"

#: ../doc/1.7/book/app_server/launching_app.rst:165
msgid ":ref:`background <cfg_basic-background>` = ``true`` that actually tells Tarantool to work as a daemon service,"
msgstr ":ref:`background <cfg_basic-background>` = ``true``, который собственно заставит Tarantool работать в качестве демона,"

#: ../doc/1.7/book/app_server/launching_app.rst:167
msgid ":ref:`log <cfg_logging-log>` = ``'dir-name'`` that tells the Tarantool daemon where to store its log file (other log settings are available in Tarantool :ref:`log <log-module>` module), and"
msgstr ":ref:`log <cfg_logging-log>` = ``'dir-name'``, который укажет, где демон Tarantool'а будет сохранять файл журнала (другие настройки журнала находятся в модуле Tarantool'а :ref:`log <log-module>` module), а также"

#: ../doc/1.7/book/app_server/launching_app.rst:170
msgid ":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the Tarantool daemon where to store its pid file."
msgstr ":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'``, который укажет, где демон Tarantool'а будет сохранять файл журнала pid-файл."

#: ../doc/1.7/book/app_server/launching_app.rst:173
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:49
#: ../doc/1.7/reference/reference_lua/box_error.rst:67
#: ../doc/1.7/reference/reference_lua/digest.rst:247
#: ../doc/1.7/reference/reference_rock/dbms.rst:82
#: ../doc/1.7/reference/reference_rock/dbms.rst:435
msgid "For example:"
msgstr "Например:"

#: ../doc/1.7/book/app_server/launching_app.rst:175
msgid ""
"box.cfg {\n"
"   listen = 3301\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""
"box.cfg {\n"
"         listen = 3301\n"
"         background = true,\n"
"         log = '1.log',\n"
"         pid_file = '1.pid'\n"
"      }"

#: ../doc/1.7/book/app_server/launching_app.rst:184
msgid "We launch our application in the same manner as before:"
msgstr "Запустим наше приложение, как делали ранее:"

#: ../doc/1.7/book/app_server/launching_app.rst:192
msgid "Tarantool executes our script, gets detached from the current shell session (you won't see it with ``ps | grep \"tarantool\"``) and continues working in the background as a daemon attached to the global session (with SID = 0):"
msgstr "Tarantool выполняет наш скрипт, отделяется от текущей сессии (он не отображается при вводе ``ps | grep \"tarantool\"``) и продолжает работать в фоновом режиме в качестве демона, прикрепленного к общей сессии (с SID = 0):"

#: ../doc/1.7/book/app_server/launching_app.rst:196
msgid ""
"$ ps -ef | grep \"tarantool\"\n"
"  PID SID     TIME  CMD\n"
"42178   0  0:00.72 tarantool myapp.lua <running>"
msgstr ""
"$ ps -ef | grep \"tarantool\"\n"
"          PID SID     TIME  CMD\n"
"        42178   0  0:00.72 tarantool myapp.lua <running>"

#: ../doc/1.7/book/app_server/launching_app.rst:202
msgid "Now that we have discussed how to create and launch a Lua application for Tarantool, let's dive deeper into programming practices."
msgstr "Рассмотрев создание и запуск Lua-приложения для Tarantool'а, перейдем к углубленному изложению методик программирования."

#: ../doc/1.7/book/app_server/reloading_module.rst:5
msgid "Reloading a module"
msgstr "Перезагрузка модуля"

#: ../doc/1.7/book/app_server/reloading_module.rst:7
msgid "You can reload any Tarantool application or module with zero downtime."
msgstr "Любое приложение или модуль Tarantool'а можно перезагрузить с нулевым временем простоя."

#: ../doc/1.7/book/app_server/reloading_module.rst:13
msgid "Reloading a module in Lua"
msgstr "Перезагрузка модуля на Lua"

#: ../doc/1.7/book/app_server/reloading_module.rst:15
msgid "Here's an example that illustrates the most typical case -- \"update and reload\"."
msgstr "Ниже представлен пример, который иллюстрирует наиболее типичный случай - \"обновление и перезагрузка\"."

#: ../doc/1.7/book/app_server/reloading_module.rst:19
msgid "In this example, we use recommended :ref:`administration practices <admin>` based on :ref:`instance files <admin-instance_file>` and :ref:`tarantoolctl <tarantoolctl>` utility."
msgstr "В этом примере используются рекомендованные :ref:`методики администрирования <admin>` на основании :ref:`файлов экземпляров <admin-instance_file>` и утилиты :ref:`tarantoolctl <tarantoolctl>`."

#: ../doc/1.7/book/app_server/reloading_module.rst:23
msgid "Update the application file."
msgstr "Обновите файлы приложения."

#: ../doc/1.7/book/app_server/reloading_module.rst:25
msgid "For example, a module in ``/usr/share/tarantool/app.lua``:"
msgstr "Например, модуль в ``/usr/share/tarantool/app.lua``:"

#: ../doc/1.7/book/app_server/reloading_module.rst:27
msgid ""
"local function start()\n"
"  -- initial version\n"
"  box.once(\"myapp:v1.0\", function()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:v1.1\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:v1.2\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    box.space.somedata:insert(...)\n"
"    ...\n"
"  end)\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and clean up resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start,\n"
"  stop = stop,\n"
"  api_for_call = api_for_call\n"
"}"
msgstr ""
"local function start()\n"
"          -- начальная версия\n"
"          box.once(\"myapp:v1.0\", function()\n"
"            box.schema.space.create(\"somedata\")\n"
"            box.space.somedata:create_index(\"primary\")\n"
"            ...\n"
"          end)\n"
"        \n"
"          -- код миграции с 1.0 на 1.1\n"
"          box.once(\"myapp:v1.1\", function()\n"
"            box.space.somedata.index.primary:alter(...)\n"
"            ...\n"
"          end)\n"
"        \n"
"          -- код миграции с 1.1 на 1.2\n"
"          box.once(\"myapp:v1.2\", function()\n"
"            box.space.somedata.index.primary:alter(...)\n"
"            box.space.somedata:insert(...)\n"
"            ...\n"
"          end)\n"
"        end\n"
"        \n"
"        -- запустить файберы в фоновом режиме, если необходимо\n"
"        \n"
"        local function stop()\n"
"          -- остановить все файберы, работающие в фоновом режиме, и очистить ресурсы\n"
"        end\n"
"        \n"
"        local function api_for_call(xxx)\n"
"          -- пройти бизнес-процесс\n"
"        end\n"
"        \n"
"        return {\n"
"          start = start,\n"
"          stop = stop,\n"
"          api_for_call = api_for_call\n"
"        }"

#: ../doc/1.7/book/app_server/reloading_module.rst:67
msgid "Update the :ref:`instance file <admin-instance_file>`."
msgstr "Обновить :ref:`файл экземпляра <admin-instance_file>`."

#: ../doc/1.7/book/app_server/reloading_module.rst:69
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua``:"
msgstr "Например, ``/etc/tarantool/instances.enabled/my_app.lua``:"

#: ../doc/1.7/book/app_server/reloading_module.rst:71
msgid ""
"#!/usr/bin/env tarantool\n"
"--\n"
"-- hot code reload example\n"
"--\n"
"\n"
"box.cfg({listen = 3302})\n"
"\n"
"-- ATTENTION: unload it all properly!\n"
"local app = package.loaded['app']\n"
"if app ~= nil then\n"
"  -- stop the old application version\n"
"  app.stop()\n"
"  -- unload the application\n"
"  package.loaded['app'] = nil\n"
"  -- unload all dependencies\n"
"  package.loaded['somedep'] = nil\n"
"end\n"
"\n"
"-- load the application\n"
"log.info('require app')\n"
"app = require('app')\n"
"\n"
"-- start the application\n"
"app.start({some app options controlled by sysadmins})"
msgstr ""
"#!/usr/bin/env tarantool\n"
"        --\n"
"        -- hot code reload example\n"
"        --\n"
"        \n"
"        box.cfg{listen = 3302}})\n"
"        \n"
"        -- ATTENTION: unload it all properly!\n"
"        local app = package.loaded['app']\n"
"        if app ~= nil then\n"
"          -- stop the old application version\n"
"          app.stop()\n"
"          -- unload the application\n"
"          package.loaded['app'] = nil\n"
"          -- unload all dependencies\n"
"          package.loaded['somedep'] = nil\n"
"        end\n"
"        \n"
"        -- load the application\n"
"        log.info('require app')\n"
"        app = require('app')\n"
"        \n"
"        -- start the application\n"
"        app.s{some app options controlled by sysadmins}mins})"

#: ../doc/1.7/book/app_server/reloading_module.rst:98
msgid "The important thing here is to properly unload the application and its dependencies."
msgstr "Самое главное — правильно разгрузить приложение и его зависимости."

#: ../doc/1.7/book/app_server/reloading_module.rst:101
msgid "Manually reload the application file."
msgstr "Вручную перезагрузите файл приложения."

#: ../doc/1.7/book/app_server/reloading_module.rst:103
msgid "For example, using ``tarantoolctl``:"
msgstr "Например, используя ``tarantoolctl``:"

#: ../doc/1.7/book/app_server/reloading_module.rst:105
msgid "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"
msgstr "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"

#: ../doc/1.7/book/app_server/reloading_module.rst:113
msgid "Reloading a module in C"
msgstr "Перезагрузка модуля на С"

#: ../doc/1.7/book/app_server/reloading_module.rst:115
msgid "After you compiled a new version of a C module (``*.so`` shared library), call :ref:`box.schema.func.reload('module-name') <box_schema-func_reload>` from your Lua script to reload the module."
msgstr "После компиляции новой версии модуля на C (библиотека общего пользования ``*.so``),  вызовите функцию :ref:`box.schema.func.reload('module-name') <box_schema-func_reload>` из Lua-скрипта для перезагрузки модуля."

#: ../doc/1.7/book/app_server/using_ide.rst:5
msgid "Developing with an IDE"
msgstr "Разработка с IDE"

#: ../doc/1.7/book/app_server/using_ide.rst:7
msgid "You can use IntelliJ IDEA as an IDE to develop and debug Lua applications for Tarantool."
msgstr "Для разработки и отладки Lua-приложений для Tarantool'а можно использовать IntelliJ IDEA в качестве интегрированной среды разработки (IDE)."

#: ../doc/1.7/book/app_server/using_ide.rst:10
msgid "Download and install the IDE from the `official web-site <https://www.jetbrains.com/idea/>`_."
msgstr "Загрузите и установите IDE с `официального сайта <https://www.jetbrains.com/idea/>`_."

#: ../doc/1.7/book/app_server/using_ide.rst:13
msgid "JetBrains provides specialized editions for particular languages: IntelliJ IDEA (Java), PHPStorm (PHP), PyCharm (Python), RubyMine (Ruby), CLion (C/C++), WebStorm (Web) and others. So, download a version that suits your primary programming language."
msgstr "JetBrains предоставляет специализированные версии для разных языков программирования: IntelliJ IDEA (Java), PHPStorm (PHP), PyCharm (Python), RubyMine (Ruby), CLion (C/C++), WebStorm (Web) и другие. Поэтому загрузите версию, которая подходит предпочитаемому языку."

#: ../doc/1.7/book/app_server/using_ide.rst:18
msgid "Tarantool integration is supported for all editions."
msgstr "Для всех версий поддерживается интеграция с Tarantool'ом."

#: ../doc/1.7/book/app_server/using_ide.rst:20
msgid "Configure the IDE:"
msgstr "Настройте IDE:"

#: ../doc/1.7/book/app_server/using_ide.rst:22
msgid "Start IntelliJ IDEA."
msgstr "Запустите IntelliJ IDEA."

#: ../doc/1.7/book/app_server/using_ide.rst:23
msgid "Click ``Configure`` button and select ``Plugins``."
msgstr "Нажмите кнопку ``Configure`` и выберите ``Plugins``."

#: ../doc/1.7/book/app_server/using_ide.rst:30
msgid "Click ``Browse repositories``."
msgstr "Нажмите ``Browse repositories``."

#: ../doc/1.7/book/app_server/using_ide.rst:37
msgid "Install ``EmmyLua`` plugin."
msgstr "Установите плагин ``EmmyLua``."

#: ../doc/1.7/book/app_server/using_ide.rst:41
msgid "Please don’t be confused with ``Lua`` plugin, which is less powerful than ``EmmyLua``."
msgstr "Не путайте с плагином ``Lua``, у которого меньше возможностей, чем у ``EmmyLua``."

#: ../doc/1.7/book/app_server/using_ide.rst:49
msgid "Restart IntelliJ IDEA."
msgstr "Перезапустите IntelliJ IDEA."

#: ../doc/1.7/book/app_server/using_ide.rst:50
msgid "Click ``Configure``, select ``Project Defaults`` and then ``Run Configurations``."
msgstr "Нажмите ``Configure``, выберите ``Project Defaults``, а затем ``Run Configurations``."

#: ../doc/1.7/book/app_server/using_ide.rst:58
msgid "Find ``Lua Application`` in the sidebar at the left."
msgstr "Найдите ``Lua Application`` в боковой панели слева."

#: ../doc/1.7/book/app_server/using_ide.rst:60
msgid "In ``Program``, type a path to an installed ``tarantool`` binary."
msgstr "В ``Program`` введите путь к установленному бинарному файлу ``tarantool``."

#: ../doc/1.7/book/app_server/using_ide.rst:62
msgid "By default, this is ``tarantool`` or ``/usr/bin/tarantool`` on most platforms."
msgstr "По умолчанию, это ``tarantool`` или ``/usr/bin/tarantool`` на большинстве платформ."

#: ../doc/1.7/book/app_server/using_ide.rst:65
msgid "If you installed ``tarantool`` from sources to a custom directory, please specify the proper path here."
msgstr "Если вы установили ``tarantool`` из источников в другую директорию, укажите здесь правильный путь."

#: ../doc/1.7/book/app_server/using_ide.rst:73
msgid "Now IntelliJ IDEA is ready to use with Tarantool."
msgstr "Теперь IntelliJ IDEA можно использовать с Tarantool'ом."

#: ../doc/1.7/book/app_server/using_ide.rst:75
msgid "Create a new Lua project."
msgstr "Создайте новый проект на Lua."

#: ../doc/1.7/book/app_server/using_ide.rst:82
msgid "Add a new Lua file, for example ``init.lua``."
msgstr "Добавьте новый Lua-файл, например, ``init.lua``."

#: ../doc/1.7/book/app_server/using_ide.rst:89
msgid "Write your code, save the file."
msgstr "Разработайте код, сохраните файл."

#: ../doc/1.7/book/app_server/using_ide.rst:91
msgid "To run you application, click ``Run -> Run`` in the main menu and select your source file in the list."
msgstr "Чтобы запустить приложение, нажмите ``Run -> Run`` в основном меню и выберите исходный файл из списка."

#: ../doc/1.7/book/app_server/using_ide.rst:99
msgid "Or click ``Run -> Debug`` to start debugging."
msgstr "Или нажмите ``Run -> Debug`` для начала отладки."

#: ../doc/1.7/book/app_server/using_ide.rst:103
msgid "To use Lua debugger, please upgrade Tarantool to version 1.7.5-29-gbb6170e4b or later."
msgstr "Чтобы использовать Lua-отладчик, обновите Tarantool до версии 1.7.5-29-gbb6170e4b или более поздней версии."

#: ../doc/1.7/book/box/atomic.rst:5
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../doc/1.7/book/box/atomic.rst:7
msgid "Transactions in Tarantool occur in **fibers** on a single **thread**. That is why Tarantool has a guarantee of execution atomicity. That requires emphasis."
msgstr "Транзакции в Tarantool'е происходят в **файберах** в одном **потоке**. Вот почему Tarantool дает гарантию атомарности выполнения. На этом следует сделать акцент."

#: ../doc/1.7/book/box/atomic.rst:15
msgid "Threads, fibers and yields"
msgstr "Потоки, файберы и передача управления"

#: ../doc/1.7/book/box/atomic.rst:17
msgid "How does Tarantool process a basic operation? As an example, let's take this query:"
msgstr "Как Tarantool выполняет основные операции? Для примера возьмем такой запрос:"

#: ../doc/1.7/book/box/atomic.rst:20
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/box/atomic.rst:24
msgid "This is equivalent to an SQL statement like:"
msgstr "Это аналогично следующему выражению на языке SQL:"

#: ../doc/1.7/book/box/atomic.rst:26
msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"
msgstr "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"

#: ../doc/1.7/book/box/atomic.rst:30
msgid "This query will be processed with three operating system **threads**:"
msgstr "Этот запрос будет обработан тремя **потоками** операционной системы:"

#: ../doc/1.7/book/box/atomic.rst:32
msgid "If we issue the query on a remote client, then the **network thread** on the server side receives the query, parses the statement and changes it to a server executable message which has already been checked, and which the server instance can understand without parsing everything again."
msgstr "Если мы передадим запрос на удаленный клиент, **сетевой поток** на стороне сервера получит запрос, разберет выражение и преобразует его в выполняемое сообщение сервера, которое уже проверено. Такое сообщение экземпляр сервера может понимать без повторного разбора."

#: ../doc/1.7/book/box/atomic.rst:37
msgid "The network thread ships this message to the instance's **\"transaction processor\" thread** using a lock-free message bus. Lua programs execute directly in the transaction processor thread, and do not require parsing and preparation."
msgstr "Сетевой поток отправляет это сообщение в **поток \"обработки транзакций\"** с помощью шины передачи сообщений без блокировок. Lua-программы выполняются непосредственно в потоке обработки транзакций и не требуют разбора и подготовки."

#: ../doc/1.7/book/box/atomic.rst:42
msgid "The instance's transaction processor thread uses the primary-key index on field[1] to find the location of the tuple. It determines that the tuple can be updated (not much can go wrong when you're merely changing an unindexed field value to something shorter)."
msgstr "Поток обработки транзакций экземпляра использует индекс на поле первичного ключа field[1], чтобы найти нужный кортеж. Он проверяет, что данный кортеж можно обновить (мы хотим лишь изменить значение не индексированного поля на более короткое, и вряд ли что-то пойдет не так)."

#: ../doc/1.7/book/box/atomic.rst:47
msgid "The transaction processor thread sends a message to the :ref:`write-ahead logging (WAL) thread <internals-wal>` to commit the transaction. When done, the WAL thread replies with a COMMIT or ROLLBACK result, which is returned to the client."
msgstr "Поток обработки транзакций отправляет сообщение в :ref:`поток упреждающей записи в журнал (WAL) <internals-wal>` для коммита транзакции. По завершении поток WAL отправляет ответ с результатом COMMIT (коммит) или ROLLBACK (откат) на клиент."

#: ../doc/1.7/book/box/atomic.rst:52
msgid "Notice that there is only one transaction processor thread in Tarantool. Some people are used to the idea that there can be multiple threads operating on the database, with (say) thread #1 reading row #x, while thread #2 writes row #y. With Tarantool, no such thing ever happens. Only the transaction processor thread can access the database, and there is only one transaction processor thread for each Tarantool instance."
msgstr "Обратите внимание, что в Tarantool'е есть только один поток обработки транзакций. Некоторые уже привыкли к мысли, что потоков для обработки данных в базе данных может быть много (например, поток №1 читает данные из строки №x, в то время как поток №2 записывает данные в столбец №y). В случае с Tarantool'ом такого не происходит. Доступ к базе есть только у потока обработки транзакций, и на  каждый экземпляр Tarantool'а есть только один такой поток."

#: ../doc/1.7/book/box/atomic.rst:59
msgid "Like any other Tarantool thread, the transaction processor thread can handle many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer instructions that may contain \"**yield**\" signals. The transaction processor thread will execute all computer instructions until a yield, then switch to execute the instructions of a different fiber. Thus (say) the thread reads row #x for the sake of fiber #1, then writes row #y for the sake of fiber #2."
msgstr "Как и любой другой поток Tarantool'а, поток обработки транзакций может управлять множеством :ref:`файберов <fiber-fibers>`. Файбер — это набор команд, среди которых могут быть и сигналы \"**передачи управления**\". Поток обработки транзакций выполняет все команды, пока не увидит такой сигнал, и тогда он переключается на выполнение команд из другого файбера. Например, таким образом поток обработки транзакций сначала выполняет чтение данных из строки №x для файбера №1, а затем выполняет запись в строку №y для файбера №2."

#: ../doc/1.7/book/box/atomic.rst:66
msgid "Yields must happen, otherwise the transaction processor thread would stick permanently on the same fiber. There are two types of yields:"
msgstr "Передача управления необходима, в противном случае, поток обработки транзакции заклинит на одном файбере. Есть два типа передачи управления:"

#: ../doc/1.7/book/box/atomic.rst:69
msgid ":ref:`implicit yields <atomic-implicit-yields>`: every data-change operation or network-access causes an implicit yield, and every statement that goes through the Tarantool client causes an implicit yield."
msgstr ":ref:`неявная передача управления <atomic-implicit-yields>`: каждая операция по изменению данных или доступ к сети вызывают неявную передачу управления, а также каждое выражение, которое проходит через клиент Tarantool'а, вызывает неявную передачу управления."

#: ../doc/1.7/book/box/atomic.rst:73
msgid "explicit yields: in a Lua function, you can (and should) add :ref:`\"yield\" <fiber-yield>` statements to prevent hogging. This is called **cooperative multitasking**."
msgstr "явная передача управления: в Lua-функции можно (и нужно) добавить выражения :ref:`\"передачи управления\" <fiber-yield>` для предотвращения захвата ЦП. Это называется **кооперативной многозадачностью**."

#: ../doc/1.7/book/box/atomic.rst:81
msgid "Cooperative multitasking"
msgstr "Кооперативная многозадачность"

#: ../doc/1.7/book/box/atomic.rst:83
msgid "Cooperative multitasking means: unless a running fiber deliberately yields control, it is not preempted by some other fiber. But a running fiber will deliberately yield when it encounters a “yield point”: a transaction commit, an operating system call, or an explicit :ref:`\"yield\" <fiber-yield>` request. Any system call which can block will be performed asynchronously, and any running fiber which must wait for a system call will be preempted, so that another ready-to-run fiber takes its place and becomes the new running fiber."
msgstr "Кооперативная многозадачность означает, что если запущенный файбер намеренно не передаст управление, он не вытесняется каким-либо другим файбером. Но запущенный файбер намеренно передает управление, когда обнаруживает “точку передачи управления”: коммит транзакции, вызов операционной системы или запрос явной :ref:`\"передачи управления\" <fiber-yield>`. Любой вызов системы, который может блокировать файбер, будет производиться асинхронно, а запущенный файбер, который должен ожидать системного вызова, будет вытеснен так, что другой готовый к работе файбер занимает его место и становится запущенным файбером."

#: ../doc/1.7/book/box/atomic.rst:91
msgid "This model makes all programmatic locks unnecessary: cooperative multitasking ensures that there will be no concurrency around a resource, no race conditions, and no memory consistency issues."
msgstr "Эта модель исключает необходимость любых программных блокировок — кооперативная многозадачность обеспечивает отсутствие многопоточности вокруг ресурса, состояния гонки и проблем с согласованностью данных."

#: ../doc/1.7/book/box/atomic.rst:95
msgid "When requests are small, for example simple UPDATE or INSERT or DELETE or SELECT, fiber scheduling is fair: it takes only a little time to process the request, schedule a disk write, and yield to a fiber serving the next client."
msgstr "При небольших запросах, таких как простые UPDATE, INSERT, DELETE или SELECT, происходит справедливое планирование файберов: немного времени требуется на обработку запроса, планирование записи на диск и передачу управления на файбер, обслуживающий следующего клиента."

#: ../doc/1.7/book/box/atomic.rst:99
msgid "However, a function might perform complex computations or might be written in such a way that yields do not occur for a long time. This can lead to unfair scheduling, when a single client throttles the rest of the system, or to apparent stalls in request processing. Avoiding this situation is the responsibility of the function’s author."
msgstr "Однако функция может выполнять сложные расчеты  или может быть написана так, что управление не передается в течение длительного времени. Это может привести к несправедливому планированию, когда отдельный клиент перекрывает работу остальной системы, или к явным задержкам в обработке запросов. Автору функции следует не допускать таких ситуаций."

#: ../doc/1.7/book/box/atomic.rst:109
msgid "Transactions"
msgstr "Транзакции"

#: ../doc/1.7/book/box/atomic.rst:111
msgid "In the absence of transactions, any function that contains yield points may see changes in the database state caused by fibers that preempt. Multi-statement transactions exist to provide **isolation**: each transaction sees a consistent database state and commits all its changes atomically. At :ref:`commit <box-commit>` time, a yield happens and all transaction changes are written to the :ref:`write ahead log <internals-wal>` in a single batch. Or, if needed, transaction changes can be rolled back -- :ref:`completely <box-rollback>` or to a specific :ref:`savepoint <box-rollback_to_savepoint>`."
msgstr "В отсутствие транзакций любая функция, в которой есть точки передачи управления, может видеть изменения в состоянии базы данных, вызванные вытесняющими файберами. Составные транзакции предназначены для **изоляции**: каждая транзакция видит постоянное состояние базы данных и делает атомарные коммиты изменений. Во время :ref:`коммита <box-commit>` происходит передача управления, а все транзакционные изменения записываются в :ref:`журнал упреждающей записи <internals-wal>` в отдельный пакет. Или, при необходимости, можно откатить изменения — :ref:`полностью <box-rollback>` или на определенную :ref:`точку сохранения <box-rollback_to_savepoint>`."

#: ../doc/1.7/book/box/atomic.rst:121
msgid "To implement isolation, Tarantool uses a simple optimistic scheduler: the first transaction to commit wins. If a concurrent active transaction has read a value modified by a committed transaction, it is aborted."
msgstr "Чтобы осуществить изоляцию, Tarantool использует простой планировщик с оптимистичным управлением: транзакция подтверждена первой — выигрывает. Если параллельная активная транзакция читает значение, измененное подтвержденной транзакцией, она прерывается."

#: ../doc/1.7/book/box/atomic.rst:125
msgid "The cooperative scheduler ensures that, in absence of yields, a multi-statement transaction is not preempted and hence is never aborted. Therefore, understanding yields is essential to writing abort-free code."
msgstr "Кооперативный планировщик обеспечивает, что в отсутствие передачи управления составная транзакция не вытесняется, поэтому никогда не прерывается. Таким образом, понимание передачи управления необходимо для написания кода без прерываний."

#: ../doc/1.7/book/box/atomic.rst:131
msgid "You can’t mix storage engines in a transaction today."
msgstr "На сегодняшний день нельзя смешивать движки базы данных в транзакции."

#: ../doc/1.7/book/box/atomic.rst:137
msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

#: ../doc/1.7/book/box/atomic.rst:139
msgid "The only explicit yield requests in Tarantool are :ref:`fiber.sleep() <fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other requests \"imply\" yields because Tarantool is designed to avoid blocking."
msgstr "Единственные запросы явной передачи данных в Tarantool'е отправляют :ref:`fiber.sleep() <fiber-sleep>` и :ref:`fiber.yield() <fiber-yield>`, но многие другие запросы \"неявно\" подразумевают передачу управления, поскольку цель Tarantool'а — избежать блокировок."

#: ../doc/1.7/book/box/atomic.rst:143
msgid "Database operations usually do not yield, but it depends on the engine:"
msgstr "Операции по изменению базы данных обычно не передают управление, но это зависит от движка:"

#: ../doc/1.7/book/box/atomic.rst:145
msgid "In memtx, reads or writes do not require I/O and do not yield."
msgstr "В memtx'е чтение и запись не требуют ввода-вывода и не передают управление."

#: ../doc/1.7/book/box/atomic.rst:147
msgid "In vinyl, not all data is in memory, and SELECT often incurs a disc I/O, and therefore yields, while a write may stall waiting for memory to free up, thus also causing a yield."
msgstr "В vinyl'е не все данные находятся в оперативной памяти, и запрос SELECT часто подразумевает дисковый ввод-вывод и, следовательно, передачу управления, пока запись ожидает освобождения памяти, что также вызывает передачу управления."

#: ../doc/1.7/book/box/atomic.rst:151
msgid "In the \"autocommit\" mode, all data change operations are followed by an automatic commit, which yields. So does an explicit commit of a multi-statement transaction, :ref:`box.commit() <box-commit>`."
msgstr "В режиме \"автокоммита\" все операции по изменению данных сопровождаются автоматическим коммитом, который передает управление. Также передает управление явный коммит составной транзакции :ref:`box.commit() <box-commit>`."

#: ../doc/1.7/book/box/atomic.rst:155
msgid "Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box <net_box-module>`, :ref:`console <console-module>` and :ref:`socket <socket-module>` (the \"os\" and \"network\" requests) yield."
msgstr "Многие функции в модулях :ref:`fio <fio-section>`, :ref:`net_box <net_box-module>`, :ref:`console <console-module>` и :ref:`socket <socket-module>` (запросы \"ОС\" и \"сети\") передают управление."

#: ../doc/1.7/book/box/atomic.rst:159
#: ../doc/1.7/book/box/authentication.rst:158
#: ../doc/1.7/book/box/box_session.rst:336
msgid "**Example #1**"
msgstr "**Пример №1**"

#: ../doc/1.7/book/box/atomic.rst:161
msgid "*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of insertion, caused by implicit commit; ``select()`` has nothing to write to the WAL and so does not yield."
msgstr "*Движок = memtx* |br| В ``select() insert()`` управление передается один раз в конце вставки, что вызвано неявным коммитом; ``select()`` ничего не записывает в WAL-файл, поэтому не передает управление."

#: ../doc/1.7/book/box/atomic.rst:166
msgid "*Engine = vinyl* |br| ``select() insert()`` has between one and three yields, since ``select()`` may yield if the data is not in cache, ``insert()`` may yield waiting for available memory, and there is an implicit yield at commit."
msgstr "*Движок = vinyl* |br| В ``select() insert()`` управление передается от одного до трех раз, поскольку ``select()`` может передавать управление, если данные не находятся в кэше, ``insert()`` может передавать управление в ожидании свободной памяти, а при коммите управление передается неявно."

#: ../doc/1.7/book/box/atomic.rst:171
msgid "The sequence ``begin() insert() insert() commit()`` yields only at commit if the engine is memtx, and can yield up to 3 times if the engine is vinyl."
msgstr "Последовательность ``begin() insert() insert() commit()`` передает управление только при коммите, если движок — memtx, и может передавать управление до 3 раз, если движок — vinyl."

#: ../doc/1.7/book/box/atomic.rst:174
#: ../doc/1.7/book/box/authentication.rst:166
#: ../doc/1.7/book/box/box_session.rst:345
msgid "**Example #2**"
msgstr "**Пример №2**"

#: ../doc/1.7/book/box/atomic.rst:176
msgid "Assume that in space ‘tester’ there are tuples in which the third field represents a positive dollar amount. Let's start a transaction, withdraw from tuple#1, deposit in tuple#2, and end the transaction, making its effects permanent."
msgstr "Предположим, что в спейсе ‘tester’ существуют кортежи, третье поле которых представляет собой положительную сумму в долларах. Начнем транзакцию, снимем сумму из кортежа №1, внесем ее в кортеж №2 и завершим транзакцию, подтверждая изменения."

#: ../doc/1.7/book/box/atomic.rst:181
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"                 >   box.begin()\n"
"                 >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"                 >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"                 >   box.commit()\n"
"                 >   return \"ok\"\n"
"                 > end\n"
"        ---\n"
"        ...\n"
"        tarantool> txn_example({999}, {1000}, 1.00)\n"
"        ---\n"
"        - \"ok\"\n"
"        ..."

#: ../doc/1.7/book/box/atomic.rst:197
msgid "If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then implicit yielding at commit time does not take place, because there are no writes to the WAL."
msgstr "Если :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, то при коммите управление не передается неявно, потому что не идет запись в WAL-файл."

#: ../doc/1.7/book/box/atomic.rst:201
msgid "If a task is interactive -- sending requests to the server and receiving responses -- then it involves network IO, and therefore there is an implicit yield, even if the request that is sent to the server is not itself an implicit yield request. Therefore, the sequence:"
msgstr "Если задача интерактивная — отправка запроса на сервер и получение ответа — то она включает в себя сетевой ввод-вывод, поэтому наблюдается неявная передача управления, даже если отправляемый на сервер запрос не представляет собой запрос с неявной передачей управления. Таким образом, последовательность:"

#: ../doc/1.7/book/box/atomic.rst:243
msgid ""
"select\n"
"select\n"
"select"
msgstr ""
"select\n"
"        select\n"
"        select"

#: ../doc/1.7/book/box/atomic.rst:213
msgid "causes blocking (in memtx), if it is inside a function or Lua program being executed on the server instance, but causes yielding (in both memtx and vinyl) if it is done as a series of transmissions from a client, including a client which operates via telnet, via one of the connectors, or via the :ref:`MySQL and PostgreSQL rocks <dbms_modules>`, or via the interactive mode when :ref:`using Tarantool as a client <admin-using_tarantool_as_a_client>`."
msgstr "приводит к блокировке (в memtx'е), если находится внутри функции или Lua-программы, которая выполняется на экземпляре сервера. Однако она вызывает передачу управления (и в memtx, и в vinyl), если выполняется как серия передач от клиента, включая клиентов, работающих по telnet, по одному из коннекторов или :ref:`модулей MySQL и PostgreSQL <dbms_modules>` или в интерактивном режиме при :ref:`использовании Tarantool'а как клиента <admin-using_tarantool_as_a_client>`."

#: ../doc/1.7/book/box/atomic.rst:220
msgid "After a fiber has yielded and then has regained control, it immediately issues :ref:`testcancel <fiber-testcancel>`."
msgstr "После того, как файбер передал управление, а затем вернул его, он незамедлительно вызывает :ref:`testcancel <fiber-testcancel>`."

#: ../doc/1.7/book/box/authentication.rst:5
msgid "Access control"
msgstr "Управление доступом"

#: ../doc/1.7/book/box/authentication.rst:7
msgid "Understanding security details is primarily an issue for administrators. Meanwhile, ordinary users should at least skim this section to get an idea of how Tarantool makes it possible for administrators to prevent unauthorized access to the database and to certain functions."
msgstr "В основном администраторы занимаются вопросами настроек безопасности. Однако обычные пользователи должны хотя бы бегло прочитать этот раздел, чтобы понять, как Tarantool позволяет администраторам не допустить неавторизованный доступ к базе данных и некоторым функциям."

#: ../doc/1.7/book/box/authentication.rst:12
msgid "In a nutshell:"
msgstr "Общая информация:"

#: ../doc/1.7/book/box/authentication.rst:14
msgid "There is a method to guarantee with password checks that users really are who they say they are (“authentication”)."
msgstr "Существует метод, который с помощью паролей проверяет, что пользователи являются теми, за кого себя выдают (“аутентификация”)."

#: ../doc/1.7/book/box/authentication.rst:17
msgid "There is a :ref:`_user <box_space-user>` system space, where usernames and password-hashes are stored."
msgstr "Существует системный спейс :ref:`_user <box_space-user>`, где хранятся имена пользователей и хеши паролей."

#: ../doc/1.7/book/box/authentication.rst:20
msgid "There are functions for saying that certain users are allowed to do certain things (“privileges”)."
msgstr "Существуют функции, чтобы дать определенным пользователям права совершать определенные действия (“привилегии”)."

#: ../doc/1.7/book/box/authentication.rst:23
msgid "There is a :ref:`_priv <box_space-priv>` system space, where privileges are stored. Whenever a user tries to do an operation, there is a check whether the user has the privilege to do the operation (“access control”)."
msgstr "Существует системный спейс :ref:`_priv <box_space-priv>`, где хранятся привилегии. Когда пользователь пытается выполнить операцию, проводится проверка на наличие у него привилегии на выполнение такой операции (“управление доступом”)."

#: ../doc/1.7/book/box/authentication.rst:27
msgid "Further on, we explain all of this in more detail."
msgstr "Далее рассмотрим эти пункты более подробно."

#: ../doc/1.7/book/box/authentication.rst:33
msgid "Users"
msgstr "Пользователи"

#: ../doc/1.7/book/box/authentication.rst:35
msgid "There is a **current user** for any program working with Tarantool, local or remote. If a remote connection is using a :ref:`binary port <admin-security>`, the current user, by default, is '**guest**'. If the connection is using an :ref:`admin-console port <admin-security>`, the current user is '**admin**'. When executing a :ref:`Lua initialization script <index-init_label>`, the current user is also ‘admin’."
msgstr "Для любой локальной или удаленной программы, работающей с Tarantool'ом, есть **текущий пользователь**. Если удаленное соединение использует :ref:`бинарный порт <admin-security>`, то текущим пользователем, по умолчанию, будет '**guest**' (гость). Если соединение использует :ref:`порт для административной консоли <admin-security>`, текущим пользователем будет '**admin**' (администратор). При выполнении :ref:`скрипта инициализации на Lua <index-init_label>`, текущим пользователем также будет ‘admin’."

#: ../doc/1.7/book/box/authentication.rst:44
msgid "The current user name can be found with :ref:`box.session.user() <box_session-user>`."
msgstr "Имя текущего пользователя можно узнать с помощью :ref:`box.session.user() <box_session-user>`."

#: ../doc/1.7/book/box/authentication.rst:46
msgid "The current user can be changed:"
msgstr "Текущего пользователя можно изменить:"

#: ../doc/1.7/book/box/authentication.rst:48
msgid "For a binary port connection -- with AUTH protocol command, supported by most clients;"
msgstr "Для соединения по бинарному порту — с помощью команды протокола AUTH, которая поддерживается большинством клиентов;"

#: ../doc/1.7/book/box/authentication.rst:51
msgid "For an admin-console connection and in a Lua initialization script -- with :ref:`box.session.su <box_session-su>`;"
msgstr "Для соединения по порту для административной консоли и при выполнении скрипта инициализации на Lua — с помощью :ref:`box.session.su <box_session-su>`;"

#: ../doc/1.7/book/box/authentication.rst:54
msgid "For a stored function invoked with CALL command over a binary port -- with :ref:`SETUID <box_schema-func_create>` property enabled for the function, which makes Tarantool temporarily replace the current user with the function’s creator, with all creator's privileges, during function execution."
msgstr "Для хранимой функции, вызываемой с помощью команды CALL по бинарному порту —  включена настройка :ref:`SETUID <box_schema-func_create>` для функции, что заставляет Tarantool временно заменять текущего пользователя на создателя функции со всеми привилегиями создателя во время выполнения функции."

#: ../doc/1.7/book/box/authentication.rst:63
msgid "Passwords"
msgstr "Пароли"

#: ../doc/1.7/book/box/authentication.rst:65
msgid "Each user (except 'guest') may have a **password**. The password is any alphanumeric string."
msgstr "У каждого пользователя (за исключением гостя 'guest') может быть **пароль**. Паролем является любая буквенно-цифровая строка."

#: ../doc/1.7/book/box/authentication.rst:67
#, python-format
msgid "Tarantool passwords are stored in the :ref:`_user <box_space-user>` system space with a `cryptographic hash function <https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ so that, if the password is ‘x’, the stored hash-password is a long string like ‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client connects to a Tarantool instance, the instance sends a random `salt value <https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the client must mix with the hashed-password before sending to the instance. Thus the original value ‘x’ is never stored anywhere except in the user’s head, and the hashed value is never passed down a network wire except when mixed with a random salt."
msgstr "Пароли Tarantool'а хранятся в системном спейсе :ref:`_user <box_space-user>` с `криптографической хеш-функцией <https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F>`_, так что если паролем является ‘x’, хранится хеш-пароль в виде длинной строки, например ‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. Когда клиент подключается к экземпляру Tarantool'а, экземпляр отправляет случайное `значение соль <https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BB%D1%8C_(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F)>`_, которое клиент должен сложить вместе с хеш-паролем перед отправкой на экземпляр. Таким образом, изначальное значение ‘x’ никогда не хранится нигде, кроме как в голове самого пользователя, а хешированное значение никогда не передается по сети, кроме как в смешанном с солью виде."

#: ../doc/1.7/book/box/authentication.rst:81
msgid "For more details of the password hashing algorithm (e.g. for the purpose of writing a new client application), read the `scramble.h <https://github.com/tarantool/tarantool/blob/1.7/src/scramble.h>`_ header file."
msgstr "Для получения дополнительной информации об алгоритме хеширования паролей (например. для написания нового клиентского приложения), прочтите файл заголовка `scramble.h <https://github.com/tarantool/tarantool/blob/1.7/src/scramble.h>`_."

#: ../doc/1.7/book/box/authentication.rst:86
msgid "This system prevents malicious onlookers from finding passwords by snooping in the log files or snooping on the wire. It is the same system that `MySQL introduced several years ago <http://dev.mysql.com/doc/refman/5.7/en/password-hashing.html>`_, which has proved adequate for medium-security installations. Nevertheless, administrators should warn users that no system is foolproof against determined long-term attacks, so passwords should be guarded and changed occasionally. Administrators should also advise users to choose long unobvious passwords, but it is ultimately up to the users to choose or change their own passwords."
msgstr "Система не дает злоумышленнику определить пароли путем просмотра файлов журнала или слежения за активностью. Это та же система, `несколько лет назад внедренная в MySQL <http://dev.mysql.com/doc/refman/5.7/en/password-hashing.html>`_, которой оказалось достаточно для объектов со средней степенью безопасности. Тем не менее, администраторы должны предупреждать пользователей, что никакая система не защищена полностью от постоянных длительных атак, поэтому пароли следует охранять и периодически изменять. Администраторы также должны рекомендовать пользователям выбирать длинные неочевидные пароли, но сами пользователи выбирают свои пароли и изменяют их."

#: ../doc/1.7/book/box/authentication.rst:96
msgid "There are two functions for managing passwords in Tarantool: :ref:`box.schema.user.password() <box_schema-user_password>` for changing a user's password and :ref:`box.schema.user.passwd() <box_schema-user_passwd>` for getting a hash-password."
msgstr "Для управления паролями в Tarantool'е есть две функции: :ref:`box.schema.user.password() <box_schema-user_password>` для изменения пароля пользователя и :ref:`box.schema.user.passwd() <box_schema-user_passwd>` для получения хеш-пароля."

#: ../doc/1.7/book/box/authentication.rst:105
msgid "Owners and privileges"
msgstr "Владельцы и привилегии"

#: ../doc/1.7/book/box/authentication.rst:107
msgid "In Tarantool, all objects are organized into a hierarchy of ownership. Ordinarily the **owner** of every object is its creator. The creator of the initial database state (we call it ‘universe’) --  including the database itself, the system spaces, the users -- is ‘admin’."
msgstr "В Tarantool'е все объекты распределены по иерархии владения. Как правило, **владельцем** каждого объекта является его создатель. Создатель первоначального состояния базы данных (мы называем его ‘universe’ — вселенная) —  включая саму базу данных, системные спейсы, пользователей — ‘admin’."

#: ../doc/1.7/book/box/authentication.rst:112
msgid "An object's owner can share some rights on the object by **granting privileges** to other users. The following privileges can be granted:"
msgstr "Владелец объекта может поделиться правами на объект, **предоставляя привилегии** другим пользователям. Можно предоставить следующие привилегии:"

#: ../doc/1.7/book/box/authentication.rst:115
msgid "Read, e.g. allow select from a space"
msgstr "Read (чтение), например, разрешить выборку из спейса"

#: ../doc/1.7/book/box/authentication.rst:116
msgid "Write, e.g. allow update on a space"
msgstr "Write (запись), например, разрешить обновление спейса"

#: ../doc/1.7/book/box/authentication.rst:117
msgid "Execute, e.g. allow call of a function"
msgstr "Execute (выполнение), например, разрешить вызов функции"

#: ../doc/1.7/book/box/authentication.rst:118
msgid "Create, e.g. allow :ref:`box.schema.space.create <box_schema-space_create>` (currently this can be granted but has no effect)"
msgstr "Create (создание), например, разрешить :ref:`box.schema.space.create <box_schema-space_create>` (сейчас можно настроить такие привилегии, но они не действуют)"

#: ../doc/1.7/book/box/authentication.rst:121
msgid "Alter, e.g. allow :ref:`box.space.x.index.y:alter <box_index-alter>` (currently this can be granted but has no effect)"
msgstr "Alter (изменение), например, разрешить :ref:`box.space.x.index.y:alter <box_index-alter>` (сейчас можно настроить такие привилегии, но они не действуют)"

#: ../doc/1.7/book/box/authentication.rst:124
msgid "Drop, e.g. allow :ref:`box.sequence.x:drop <box_schema-sequence_drop>` (currently this can be granted but has no effect)"
msgstr "Drop (удаление), например, разрешить :ref:`box.sequence.x:drop <box_schema-sequence_drop>` (сейчас можно настроить такие привилегии, но они не действуют)"

#: ../doc/1.7/book/box/authentication.rst:128
msgid "This is how the privilege system works. To be able to create objects, a user needs to have write access to Tarantool's system spaces. The 'admin' user, who is at the top of the hierarchy and who is the ultimate source of privileges, shares write access to a system space (e.g. :ref:`_space <box_space-space>`) with some users. Now the users can insert data into the system space (e.g. creating new spaces) and themselves become creators/definers of new objects. For the objects they created, the users can in turn share privileges with other users."
msgstr "Так работает система привилегий. Чтобы иметь возможность создавать объекты, пользователю нужно иметь доступ к системным спейсам Tarantool'а. Пользователь 'admin', который находится на вершине иерархии и который является главным источником привилегий, делится доступом с правом записи в системный спейс (например, :ref:`_space <box_space-space>`) с некоторыми пользователями. Теперь пользователи могут вносить данные в системный спейс (например, создавать новые спейсы) и сами могут создавать/определять новые объекты. В свою очередь, пользователи могут поделиться привилегиями на созданные ими объекты."

#: ../doc/1.7/book/box/authentication.rst:137
msgid "This is why only an object's owner can drop the object, but other ordinary users cannot. Meanwhile, 'admin' can drop any object or delete any other user, because 'admin' is the creator and ultimate owner of them all."
msgstr "Вот почему только владелец объекта может удалять объект, а другие пользователи — нет. При этом 'admin' может удалять любой объект или любого пользователя, потому что 'admin' является создателем и конечным владельцем всего."

#: ../doc/1.7/book/box/authentication.rst:141
msgid "The syntax of all :ref:`grant() <box_schema-user_grant>`/:ref:`revoke() <box_schema-user_revoke>` commands in Tarantool follows this basic idea."
msgstr "Синтаксис всех команд :ref:`grant() <box_schema-user_grant>`/:ref:`revoke() <box_schema-user_revoke>` в Tarantool'е подчиняется простым правилам."

#: ../doc/1.7/book/box/authentication.rst:145
msgid "The first argument is the name of the user who gets the privilege or whose privilege is revoked."
msgstr "Первый аргумент — имя пользователя, кому предоставляется или у кого отменяется привилегия."

#: ../doc/1.7/book/box/authentication.rst:148
msgid "The second argument is the type of privilege granted, or a list of privileges."
msgstr "Второй аргумент — тип настраиваемой привилегии или список привилегий."

#: ../doc/1.7/book/box/authentication.rst:150
msgid "The third argument is the object type on which the privilege is granted, or the word 'universe'. Possible object types are 'space', 'function', 'sequence' (not 'user' or 'role')."
msgstr "Третий аргумент — объектный тип, на который предоставляется привилегия, или слово 'universe'. Возможные типы объектов — 'space' (спейс), 'function' (функция), 'sequence' (последовательность). На 'user' (пользователь) или 'role' (роль) не распространяются."

#: ../doc/1.7/book/box/authentication.rst:154
msgid "The fourth argument is the name of the object if the object type was specified ('universe' has no name because there is only one 'universe', but otherwise you must specify the name)."
msgstr "Четвертый аргумент — имя объекта, если был указан объектный тип (у 'universe' имени нет, поскольку она всего одна, но для остальных необходимо указать имя)."

#: ../doc/1.7/book/box/authentication.rst:160
msgid "Here we say that user 'guest' can do common operations on any object."
msgstr "Здесь мы говорим, что пользователь 'guest' может выполнять общий набор операций на любом объекте."

#: ../doc/1.7/book/box/authentication.rst:162
msgid "box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr "box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../doc/1.7/book/box/authentication.rst:168
msgid "Here we create a Lua function that will be executed under the user id of its creator, even if called by another user."
msgstr "Здесь создадим Lua-функциб, которая будет выполняться от ID пользователя, который является ее создателем, даже если она вызывается другим пользователем."

#: ../doc/1.7/book/box/authentication.rst:171
msgid "First, we create two spaces ('u' and 'i') and grant a no-password user ('internal') full access to them. Then we define a function ('read_and_modify') and the no-password user becomes this function's creator. Finally, we grant another user ('public_user') access to execute Lua functions created by the no-password user."
msgstr "Для начала создадим два спейса ('u' и 'i') и дадим полный доступ к ним пользователю без пароля ('internal'). Затем определим функцию ('read_and_modify'), и пользователь без пароля становится создателем функции. Наконец, дадим другому пользователю ('public_user') доступ на выполнение Lua-функций, созданных пользователем без пароля."

#: ../doc/1.7/book/box/authentication.rst:176
msgid ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"           u:put{key, box.session.uid()}\n"
"           i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', 'read_and_modify')"
msgstr ""
"box.schema.space.create('u')\n"
"        box.schema.space.create('i')\n"
"        box.space.u:create_index('pk')\n"
"        box.space.i:create_index('pk')\n"
"        \n"
"        box.schema.user.create('internal')\n"
"        \n"
"        box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"        box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"        box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"        \n"
"        function read_and_modify(key)\n"
"          local u = box.space.u\n"
"          local i = box.space.i\n"
"          local fiber = require('fiber')\n"
"          local t = u:get{key}\n"
"          if t ~= nil then\n"
"                   u:put{key, box.session.uid()}\n"
"                   i:put{key, fiber.time()}\n"
"          end\n"
"        end\n"
"        \n"
"        box.session.su('internal')\n"
"        box.schema.func.create('read_and_modify', {setuid= true})\n"
"        box.session.su('admin')\n"
"        box.schema.user.create('public_user', {password = 'secret'})\n"
"        box.schema.user.grant('public_user', 'execute', 'function', 'read_and_modify')"

#: ../doc/1.7/book/box/authentication.rst:210
msgid "Roles"
msgstr "Роли"

#: ../doc/1.7/book/box/authentication.rst:212
msgid "A **role** is a container for privileges which can be granted to regular users. Instead of granting or revoking individual privileges, you can put all the privileges in a role and then grant or revoke the role."
msgstr "**Роль** представляет собой контейнер для привилегий, которые можно предоставить обычным пользователям. Вместо того, чтобы предоставлять или отменять индивидуальные привилегии, можно поместить все привилегии в роль, а затем назначить или отменить роль."

#: ../doc/1.7/book/box/authentication.rst:216
msgid "Role information is stored in the :ref:`_user <box_space-user>` space, but the third field in the tuple -- the type field -- is ‘role’ rather than ‘user’."
msgstr "Информация о роли хранится в спейсе :ref:`_user <box_space-user>`, но третье поле кортежа — поле типа — это ‘роль’, а не ‘пользователь’."

#: ../doc/1.7/book/box/authentication.rst:219
msgid "An important feature in role management is that roles can be **nested**. For example, role R1 can be granted a privilege \"role R2\", so users with the role R1 will subsequently get all privileges from both roles R1 and R2. In other words, a user gets all the privileges that are granted to a user’s roles, directly or indirectly."
msgstr "В управлении доступом на основе ролей один из главных моментов — это то, что роли могут быть **вложенными**. Например, роли R1 можно предоставить привилегию \"роль R2\", то есть пользователи с ролью R1 тогда получат все привилегии роли R1 и роли R2. Другими словами, пользователь получает все привилегии, которые предоставляются ролям пользователя напрямую и опосредованно."

#: ../doc/1.7/book/box/authentication.rst:227
msgid ""
"-- This example will work for a user with many privileges, such as 'admin'\n"
"-- or a user with the pre-defined 'super' role\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""
"-- Этот пример сработает для пользователя со множеством привилегий, например, 'admin'\n"
"        -- или для пользователя с заданной ролью 'super'\n"
"        -- Создать спейс T с первичным индексом\n"
"        box.schema.space.create('T')\n"
"        box.space.T:create_index('primary', {})\n"
"        -- Создать пользователя U1, чтобы затем можно было заменить текущего пользователя на U1\n"
"        box.schema.user.create('U1')\n"
"        -- Создать две роли, R1 и R2\n"
"        box.schema.role.create('R1')\n"
"        box.schema.role.create('R2')\n"
"        -- Предоставить роль R2 для роли R1, а роль R1 пользователю U1 (порядок не имеет значения)\n"
"        box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"        box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"        -- Предоставить привилегии чтение/запись на спейс T для роли R2\n"
"        -- (но не для роли R1 и не пользователю U1)\n"
"        box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"        -- Изменить текущего пользователя на пользователя U1\n"
"        box.session.su('U1')\n"
"        -- Теперь вставка в спейс T сработает, потому что благодаря вложенным ролям\n"
"        -- у пользователя U1 есть привилегия записи в спейс T\n"
"        box.space.T:insert{1}"

#: ../doc/1.7/book/box/authentication.rst:251
msgid "For details about Tarantool functions related to role management, see reference on :ref:`box.schema <box_schema>` submodule."
msgstr "Для получения подробной информации о функциях Tarantool'а, связанных с управлением доступом на основе ролей, см. справочник по вложенному модулю :ref:`box.schema <box_schema>`."

#: ../doc/1.7/book/box/authentication.rst:258
msgid "Sessions and security"
msgstr "Сессии и безопасность"

#: ../doc/1.7/book/box/authentication.rst:260
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr "**Сессия** — это состояние подключения к Tarantool'у. Она содержит:"

#: ../doc/1.7/book/box/authentication.rst:262
msgid "an integer id identifying the connection,"
msgstr "идентификатор в виде целого числа, определяющий соединение,"

#: ../doc/1.7/book/box/authentication.rst:263
msgid "the :ref:`current user <authentication-users>` associated with the connection,"
msgstr ":ref:`текущий пользователь <authentication-users>`, использующий соединение,"

#: ../doc/1.7/book/box/authentication.rst:264
msgid "text description of the connected peer, and"
msgstr "текстовое описание подключенного узла и"

#: ../doc/1.7/book/box/authentication.rst:265
msgid "session local state, such as Lua variables and functions."
msgstr "локальное состояние сессии, например, переменные и функции на Lua."

#: ../doc/1.7/book/box/authentication.rst:267
msgid "In Tarantool, a single session can execute multiple concurrent transactions. Each transaction is identified by a unique integer id, which can be queried at start of the transaction using :ref:`box.session.sync() <box_session-sync>`."
msgstr "В Tarantool'е отдельная сессия может выполнять несколько транзакций одновременно. Каждая транзакция определяется по уникальному идентификатору в виде целого числа, который можно запросить в начале транзакции с помощью :ref:`box.session.sync() <box_session-sync>`."

#: ../doc/1.7/book/box/authentication.rst:273
msgid "To track all connects and disconnects, you can use :ref:`connection and authentication triggers <triggers>`."
msgstr "Чтобы отследить все подключения и отключения, можно использовать :ref:`триггеры соединений и аутентификации <triggers>`."

#: ../doc/1.7/book/box/box_cfg.rst:5
msgid "Submodule `box.cfg`"
msgstr "Вложенный модуль `box.cfg`"

#: ../doc/1.7/book/box/box_cfg.rst:9
msgid "The ``box.cfg`` submodule is for administrators to specify all the :ref:`server configuration parameters <box_cfg_params>`."
msgstr "Вложенный модуль ``box.cfg`` предназначен для системных администраторов, чтобы указать все :ref:`параметры конфигурации сервера <box_cfg_params>`."

#: ../doc/1.7/book/box/box_cfg.rst:12
msgid "Say ``box.cfg`` without braces to view the current configuration, for example:"
msgstr "Введите команду ``box.cfg`` без фигурных скобок для просмотра текущей конфигурации, например:"

#: ../doc/1.7/book/box/box_cfg.rst:14
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- checkpoint_count: 2\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  memtx_max_tuple_size: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""
"tarantool> box.cfg\n"
"  ---\n"
"  - checkpoint_count: 2\n"
"    too_long_threshold: 0.5\n"
"    slab_alloc_factor: 1.1\n"
"    memtx_max_tuple_size: 1048576\n"
"    background: false\n"
"    <...>\n"
"  ..."

#: ../doc/1.7/book/box/box_cfg.rst:26
msgid "To set the parameters, say ``box.cfg{...}``, for example:"
msgstr "Чтобы установить параметры, введите команду ``box.cfg{...}``, например:"

#: ../doc/1.7/book/box/box_cfg.rst:28
#: ../doc/1.7/book/getting_started/using_binary.rst:62
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.7/book/box/box_cfg.rst:32
msgid "If you say ``box.cfg{}`` with no parameters, Tarantool applies default settings:"
msgstr "Если ввести ``box.cfg{}`` без параметров, Tarantool применит настройки по умолчанию:"

#: ../doc/1.7/book/box/box_cfg.rst:34
msgid ""
"tarantool> box.cfg{}\n"
"tarantool> box.cfg\n"
"---\n"
"- listen               = nil\n"
"  memtx_memory         = 256 * 1024 *1024\n"
"  memtx_min_tuple_size = 16\n"
"  memtx_max_tuple_size = 1024 * 1024\n"
"  slab_alloc_factor    = 1.05\n"
"  work_dir             = nil\n"
"  memtx_dir            = \".\"\n"
"  wal_dir              = \".\"\n"
"\n"
"  vinyl_dir            = '.'\n"
"  vinyl_memory         = 128 * 1024 * 1024\n"
"  vinyl_cache          = 128 * 1024 * 1024\n"
"  vinyl_max_tuple_size = 1024 * 1024\n"
"  vinyl_read_threads   = 1\n"
"  vinyl_write_threads  = 2\n"
"  vinyl_timeout        = 60\n"
"  vinyl_run_count_per_level = 2\n"
"  vinyl_run_size_ratio      = 3.5\n"
"  vinyl_range_size          = 1024 * 1024 * 1024\n"
"  vinyl_page_size           = 8 * 1024\n"
"  vinyl_bloom_fpr           = 0.05\n"
"  log                  = nil\n"
"  log_nonblock         = true\n"
"  log_level            = 5\n"
"  log_format           = \"plain\"\n"
"  io_collect_interval  = nil\n"
"  readahead            = 16320\n"
"  snap_io_rate_limit   = nil\n"
"  too_long_threshold   = 0.5\n"
"  wal_mode             = \"write\"\n"
"  rows_per_wal         = 500000\n"
"  wal_max_size         = 256 * 1024 * 1024\n"
"  wal_dir_rescan_delay = 2\n"
"  force_recovery       = false\n"
"  replication          = nil\n"
"  custom_proc_title    = nil\n"
"  pid_file             = nil\n"
"  background           = false\n"
"  username             = nil\n"
"  coredump             = false\n"
"  read_only            = false\n"
"  hot_standby          = false\n"
"  checkpoint_interval  = 3600\n"
"  checkpoint_count     = 2\n"
"  worker_pool_threads  = 4\n"
"  replication_timeout  = 1\n"
"..."
msgstr ""
"tarantool> box.cfg{}\n"
" tarantool> box.cfg\n"
" ---\n"
" - listen               = nil\n"
"   memtx_memory         = 256 * 1024 *1024\n"
"   memtx_min_tuple_size = 16\n"
"   memtx_max_tuple_size = 1024 * 1024\n"
"   slab_alloc_factor    = 1.05\n"
"   work_dir             = nil\n"
"   memtx_dir            = \".\"\n"
"   wal_dir              = \".\"\n"
" \n"
"   vinyl_dir            = '.'\n"
"   vinyl_memory         = 128 * 1024 * 1024\n"
"   vinyl_cache          = 128 * 1024 * 1024\n"
"   vinyl_max_tuple_size = 1024 * 1024\n"
"   vinyl_read_threads   = 1\n"
"   vinyl_write_threads  = 2\n"
"   vinyl_timeout        = 60\n"
"   vinyl_run_count_per_level = 2\n"
"   vinyl_run_size_ratio      = 3.5\n"
"   vinyl_range_size          = 1024 * 1024 * 1024\n"
"   vinyl_page_size           = 8 * 1024\n"
"   vinyl_bloom_fpr           = 0.05\n"
"   log                  = nil\n"
"   log_nonblock         = true\n"
"   log_level            = 5\n"
"   log_format           = \"plain\"\n"
"   io_collect_interval  = nil\n"
"   readahead            = 16320\n"
"   snap_io_rate_limit   = nil\n"
"   too_long_threshold   = 0.5\n"
"   wal_mode             = \"write\"\n"
"   rows_per_wal         = 500000\n"
"   wal_max_size         = 256 * 1024 * 1024\n"
"   wal_dir_rescan_delay = 2\n"
"   force_recovery       = false\n"
"   replication          = nil\n"
"   custom_proc_title    = nil\n"
"   pid_file             = nil\n"
"   background           = false\n"
"   username             = nil\n"
"   coredump             = false\n"
"   read_only            = false\n"
"   hot_standby          = false\n"
"   checkpoint_interval  = 3600\n"
"   checkpoint_count     = 2\n"
"   worker_pool_threads  = 4\n"
"   replication_timeout  = 1\n"
" ..."

#: ../doc/1.7/book/box/box_cfg.rst:87
msgid "The first call to ``box.cfg{...}`` (with or without parameters) initiates Tarantool's database module :ref:`box <box-module>`. To perform any database operations, you must call ``box.cfg{...}`` first."
msgstr "Первый вызов ``box.cfg{...}`` (с параметрами или без них) запускает модуль базы данных Tarantool'а под названием :ref:`box <box-module>`. Чтобы выполнить любые операции с базой данных, необходимо сначала вызвать ``box.cfg{...}``."

#: ../doc/1.7/book/box/box_cfg.rst:91
msgid "``box.cfg{...}`` is also the command that reloads :ref:`persistent data files <index-box_persistence>` into RAM upon restart once we have data."
msgstr "Команда ``box.cfg{...}`` также перезагружает :ref:`файлы с данными длительного хранения <index-box_persistence>` в оперативную память при перезапуске после получения данных."

#: ../doc/1.7/book/box/box_ctl.rst:5
msgid "Submodule `box.ctl`"
msgstr "Вложенный модуль `box.ctl`"

#: ../doc/1.7/book/box/box_ctl.rst:9
msgid "The ``box.ctl`` submodule contains two functions: ``wait_ro`` (wait until read-only) and ``wait_rw`` (wait until read-write). The functions are useful during initialization of a server."
msgstr "Вложенный модуль ``box.ctl`` включает в себя две функции: ``wait_ro`` (дождаться режима только для чтения) и ``wait_rw`` (дождаться режима чтения и записи). Эти функции используются во время инициализации сервера."

#: ../doc/1.7/book/box/box_ctl.rst:14
msgid "A particular use is for :ref:`box_once() <box-once>`. For example, when a replica is initializing, it may call a ``box.once()`` function while the server is still in read-only mode, and fail to make changes that are necessary only once before the replica is fully initialized. This could cause conflicts between a master and a replica if the master is in read-write mode and the replica is in read-only mode. Waiting until \"read only mode = false\" solves this problem."
msgstr "Для :ref:`box_once() <box-once>` есть особое предназначение. Например, при инициализаци реплика может вызвать функцию ``box.once()``, пока сервер все еще находится в режиме только для чтения, и не сможет применить изменения однократно до окончательной инициализации реплики. Это может привести к конфликту между мастером и репликой, если мастер находится в режиме чтения и записи, а реплика доступна только для чтения. Ожидание условия \"read only mode = false\" (режим только для чтения отключен) решает эту проблему."

#: ../doc/1.7/book/box/box_ctl.rst:24
msgid "To see whether a function is already in read-only or read-write mode, check :ref:`box.info.ro <box_introspection-box_info>`."
msgstr "Чтобы проверить режим функции — только для чтения или чтение и запись, используйте :ref:`box.info.ro <box_introspection-box_info>`."

#: ../doc/1.7/book/box/box_ctl.rst:31
msgid "Wait until ``box.info.ro`` is true."
msgstr "Дождаться, пока не будет выполнено ``box.info.ro``."

#: ../doc/1.7/book/box/box_ctl.rst ../doc/1.7/book/box/box_index.rst
#: ../doc/1.7/book/box/box_schema.rst ../doc/1.7/book/box/box_session.rst
#: ../doc/1.7/book/box/box_space.rst ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/dev_guide/reference_capi/box.rst
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst
#: ../doc/1.7/dev_guide/reference_capi/coio.rst
#: ../doc/1.7/dev_guide/reference_capi/error.rst
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst
#: ../doc/1.7/dev_guide/reference_capi/latch.rst
#: ../doc/1.7/dev_guide/reference_capi/say.rst
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst
#: ../doc/1.7/dev_guide/reference_capi/utils.rst
#: ../doc/1.7/reference/reference_lua/box_error.rst
#: ../doc/1.7/reference/reference_lua/box_once.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/console.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst
#: ../doc/1.7/reference/reference_lua/errno.rst
#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/log.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/osmodule.rst
#: ../doc/1.7/reference/reference_lua/other.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/string.rst
#: ../doc/1.7/reference/reference_lua/table.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "Parameters"
msgstr "Параметры"

#: ../doc/1.7/book/box/box_ctl.rst:33 ../doc/1.7/book/box/box_ctl.rst:56
msgid "maximum number of seconds to wait"
msgstr "максимальное количество секунд ожидания"

#: ../doc/1.7/book/box/box_ctl.rst ../doc/1.7/book/box/box_index.rst
#: ../doc/1.7/book/box/box_info.rst ../doc/1.7/book/box/box_schema.rst
#: ../doc/1.7/book/box/box_session.rst ../doc/1.7/book/box/box_slab.rst
#: ../doc/1.7/book/box/box_space.rst ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/reference/reference_lua/buffer.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/console.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst
#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/log.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/other.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "return"
msgstr "Возврат"

#: ../doc/1.7/book/box/box_ctl.rst:34 ../doc/1.7/book/box/box_ctl.rst:57
msgid "nil, or error (errors may be due to timeout or fiber cancellation)"
msgstr "нулевое значение nil или ошибка (ошибки могут возникать из-за превышения времени ожидания или прерывания работы файбера)"

#: ../doc/1.7/book/box/box_ctl.rst:36 ../doc/1.7/book/box/box_ctl.rst:60
#: ../doc/1.7/book/box/box_index.rst:107 ../doc/1.7/book/box/box_index.rst:521
#: ../doc/1.7/book/box/box_index.rst:661 ../doc/1.7/book/box/box_index.rst:689
#: ../doc/1.7/book/box/box_index.rst:717 ../doc/1.7/book/box/box_index.rst:746
#: ../doc/1.7/book/box/box_index.rst:770 ../doc/1.7/book/box/box_index.rst:845
#: ../doc/1.7/book/box/box_index.rst:875 ../doc/1.7/book/box/box_index.rst:897
#: ../doc/1.7/book/box/box_info.rst:160 ../doc/1.7/book/box/box_schema.rst:271
#: ../doc/1.7/book/box/box_schema.rst:309
#: ../doc/1.7/book/box/box_schema.rst:343
#: ../doc/1.7/book/box/box_schema.rst:382
#: ../doc/1.7/book/box/box_schema.rst:404
#: ../doc/1.7/book/box/box_schema.rst:426
#: ../doc/1.7/book/box/box_schema.rst:449
#: ../doc/1.7/book/box/box_schema.rst:468
#: ../doc/1.7/book/box/box_schema.rst:483
#: ../doc/1.7/book/box/box_schema.rst:514
#: ../doc/1.7/book/box/box_schema.rst:545
#: ../doc/1.7/book/box/box_schema.rst:562
#: ../doc/1.7/book/box/box_schema.rst:599
#: ../doc/1.7/book/box/box_schema.rst:620
#: ../doc/1.7/book/box/box_schema.rst:636
#: ../doc/1.7/book/box/box_schema.rst:809 ../doc/1.7/book/box/box_slab.rst:55
#: ../doc/1.7/book/box/box_slab.rst:114 ../doc/1.7/book/box/box_slab.rst:156
#: ../doc/1.7/book/box/box_space.rst:169 ../doc/1.7/book/box/box_space.rst:195
#: ../doc/1.7/book/box/box_space.rst:224 ../doc/1.7/book/box/box_space.rst:482
#: ../doc/1.7/book/box/box_space.rst:519 ../doc/1.7/book/box/box_space.rst:569
#: ../doc/1.7/book/box/box_space.rst:663 ../doc/1.7/book/box/box_space.rst:705
#: ../doc/1.7/book/box/box_space.rst:732 ../doc/1.7/book/box/box_space.rst:884
#: ../doc/1.7/book/box/box_space.rst:928 ../doc/1.7/book/box/box_space.rst:971
#: ../doc/1.7/book/box/box_space.rst:1007
#: ../doc/1.7/book/box/box_space.rst:1028
#: ../doc/1.7/book/box/box_space.rst:1068
#: ../doc/1.7/book/box/box_space.rst:1145
#: ../doc/1.7/book/box/box_space.rst:1222
#: ../doc/1.7/book/box/box_space.rst:1334
#: ../doc/1.7/book/box/box_space.rst:1369
#: ../doc/1.7/book/box/box_space.rst:1387
#: ../doc/1.7/book/box/box_space.rst:1406
#: ../doc/1.7/book/box/box_space.rst:1459
#: ../doc/1.7/book/box/box_space.rst:1577
#: ../doc/1.7/book/box/box_space.rst:1829 ../doc/1.7/book/box/box_tuple.rst:89
#: ../doc/1.7/book/box/box_txn_management.rst:116
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:211
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:249
#: ../doc/1.7/dev_guide/reference_capi/coio.rst:46
#: ../doc/1.7/dev_guide/reference_capi/say.rst:52
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:240
#: ../doc/1.7/reference/reference_lua/box_error.rst:77
#: ../doc/1.7/reference/reference_lua/box_error.rst:117
#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:45
#: ../doc/1.7/reference/reference_lua/buffer.rst:23
#: ../doc/1.7/reference/reference_lua/clock.rst:78
#: ../doc/1.7/reference/reference_lua/clock.rst:103
#: ../doc/1.7/reference/reference_lua/clock.rst:124
#: ../doc/1.7/reference/reference_lua/clock.rst:145
#: ../doc/1.7/reference/reference_lua/clock.rst:167
#: ../doc/1.7/reference/reference_lua/console.rst:79
#: ../doc/1.7/reference/reference_lua/console.rst:110
#: ../doc/1.7/reference/reference_lua/console.rst:135
#: ../doc/1.7/reference/reference_lua/console.rst:174
#: ../doc/1.7/reference/reference_lua/crypto.rst:68
#: ../doc/1.7/reference/reference_lua/crypto.rst:99
#: ../doc/1.7/reference/reference_lua/csv.rst:77
#: ../doc/1.7/reference/reference_lua/csv.rst:159
#: ../doc/1.7/reference/reference_lua/csv.rst:204
#: ../doc/1.7/reference/reference_lua/errno.rst:60
#: ../doc/1.7/reference/reference_lua/fiber.rst:190
#: ../doc/1.7/reference/reference_lua/fiber.rst:214
#: ../doc/1.7/reference/reference_lua/fiber.rst:234
#: ../doc/1.7/reference/reference_lua/fiber.rst:254
#: ../doc/1.7/reference/reference_lua/fiber.rst:269
#: ../doc/1.7/reference/reference_lua/fiber.rst:286
#: ../doc/1.7/reference/reference_lua/fiber.rst:305
#: ../doc/1.7/reference/reference_lua/fiber.rst:332
#: ../doc/1.7/reference/reference_lua/fiber.rst:349
#: ../doc/1.7/reference/reference_lua/fiber.rst:369
#: ../doc/1.7/reference/reference_lua/fiber.rst:390
#: ../doc/1.7/reference/reference_lua/fiber.rst:415
#: ../doc/1.7/reference/reference_lua/fiber.rst:435
#: ../doc/1.7/reference/reference_lua/fiber.rst:460
#: ../doc/1.7/reference/reference_lua/fiber.rst:480
#: ../doc/1.7/reference/reference_lua/fiber.rst:525
#: ../doc/1.7/reference/reference_lua/fiber.rst:544
#: ../doc/1.7/reference/reference_lua/fio.rst:179
#: ../doc/1.7/reference/reference_lua/fio.rst:201
#: ../doc/1.7/reference/reference_lua/fio.rst:221
#: ../doc/1.7/reference/reference_lua/fio.rst:240
#: ../doc/1.7/reference/reference_lua/fio.rst:316
#: ../doc/1.7/reference/reference_lua/fio.rst:352
#: ../doc/1.7/reference/reference_lua/fio.rst:391
#: ../doc/1.7/reference/reference_lua/fio.rst:411
#: ../doc/1.7/reference/reference_lua/fio.rst:432
#: ../doc/1.7/reference/reference_lua/fio.rst:455
#: ../doc/1.7/reference/reference_lua/fio.rst:472
#: ../doc/1.7/reference/reference_lua/fio.rst:487
#: ../doc/1.7/reference/reference_lua/fio.rst:511
#: ../doc/1.7/reference/reference_lua/fio.rst:533
#: ../doc/1.7/reference/reference_lua/fio.rst:556
#: ../doc/1.7/reference/reference_lua/fio.rst:582
#: ../doc/1.7/reference/reference_lua/fio.rst:608
#: ../doc/1.7/reference/reference_lua/fio.rst:631
#: ../doc/1.7/reference/reference_lua/fio.rst:653
#: ../doc/1.7/reference/reference_lua/fio.rst:679
#: ../doc/1.7/reference/reference_lua/fio.rst:697
#: ../doc/1.7/reference/reference_lua/fio.rst:798
#: ../doc/1.7/reference/reference_lua/fio.rst:829
#: ../doc/1.7/reference/reference_lua/fio.rst:949
#: ../doc/1.7/reference/reference_lua/fio.rst:969
#: ../doc/1.7/reference/reference_lua/fio.rst:994
#: ../doc/1.7/reference/reference_lua/fio.rst:1015
#: ../doc/1.7/reference/reference_lua/fio.rst:1048
#: ../doc/1.7/reference/reference_lua/fio.rst:1070
#: ../doc/1.7/reference/reference_lua/http.rst:52
#: ../doc/1.7/reference/reference_lua/http.rst:159
#: ../doc/1.7/reference/reference_lua/iconv.rst:57
#: ../doc/1.7/reference/reference_lua/iconv.rst:78
#: ../doc/1.7/reference/reference_lua/json.rst:51
#: ../doc/1.7/reference/reference_lua/json.rst:89
#: ../doc/1.7/reference/reference_lua/json.rst:120
#: ../doc/1.7/reference/reference_lua/net_box.rst:224
#: ../doc/1.7/reference/reference_lua/net_box.rst:240
#: ../doc/1.7/reference/reference_lua/net_box.rst:255
#: ../doc/1.7/reference/reference_lua/net_box.rst:296
#: ../doc/1.7/reference/reference_lua/net_box.rst:309
#: ../doc/1.7/reference/reference_lua/net_box.rst:331
#: ../doc/1.7/reference/reference_lua/net_box.rst:344
#: ../doc/1.7/reference/reference_lua/net_box.rst:357
#: ../doc/1.7/reference/reference_lua/net_box.rst:370
#: ../doc/1.7/reference/reference_lua/net_box.rst:419
#: ../doc/1.7/reference/reference_lua/net_box.rst:435
#: ../doc/1.7/reference/reference_lua/osmodule.rst:88
#: ../doc/1.7/reference/reference_lua/osmodule.rst:111
#: ../doc/1.7/reference/reference_lua/osmodule.rst:130
#: ../doc/1.7/reference/reference_lua/osmodule.rst:147
#: ../doc/1.7/reference/reference_lua/osmodule.rst:165
#: ../doc/1.7/reference/reference_lua/osmodule.rst:180
#: ../doc/1.7/reference/reference_lua/osmodule.rst:193
#: ../doc/1.7/reference/reference_lua/osmodule.rst:208
#: ../doc/1.7/reference/reference_lua/osmodule.rst:223
#: ../doc/1.7/reference/reference_lua/osmodule.rst:238
#: ../doc/1.7/reference/reference_lua/osmodule.rst:253
#: ../doc/1.7/reference/reference_lua/osmodule.rst:269
#: ../doc/1.7/reference/reference_lua/osmodule.rst:284
#: ../doc/1.7/reference/reference_lua/other.rst:38
#: ../doc/1.7/reference/reference_lua/other.rst:78
#: ../doc/1.7/reference/reference_lua/pickle.rst:91
#: ../doc/1.7/reference/reference_lua/pickle.rst:138
#: ../doc/1.7/reference/reference_lua/socket.rst:138
#: ../doc/1.7/reference/reference_lua/socket.rst:156
#: ../doc/1.7/reference/reference_lua/socket.rst:175
#: ../doc/1.7/reference/reference_lua/socket.rst:245
#: ../doc/1.7/reference/reference_lua/socket.rst:401
#: ../doc/1.7/reference/reference_lua/strict.rst:18
#: ../doc/1.7/reference/reference_lua/string.rst:68
#: ../doc/1.7/reference/reference_lua/string.rst:93
#: ../doc/1.7/reference/reference_lua/string.rst:116
#: ../doc/1.7/reference/reference_lua/string.rst:146
#: ../doc/1.7/reference/reference_lua/string.rst:176
#: ../doc/1.7/reference/reference_lua/string.rst:203
#: ../doc/1.7/reference/reference_lua/string.rst:227
#: ../doc/1.7/reference/reference_lua/string.rst:250
#: ../doc/1.7/reference/reference_lua/string.rst:273
#: ../doc/1.7/reference/reference_lua/table.rst:50
#: ../doc/1.7/reference/reference_lua/tap.rst:168
#: ../doc/1.7/reference/reference_lua/tap.rst:214
#: ../doc/1.7/reference/reference_lua/tarantool.rst:20
#: ../doc/1.7/reference/reference_lua/uri.rst:65
#: ../doc/1.7/reference/reference_lua/uri.rst:89
#: ../doc/1.7/reference/reference_lua/xlog.rst:27
#: ../doc/1.7/reference/reference_rock/dbms.rst:188
#: ../doc/1.7/reference/reference_rock/dbms.rst:212
#: ../doc/1.7/reference/reference_rock/dbms.rst:236
#: ../doc/1.7/reference/reference_rock/dbms.rst:530
#: ../doc/1.7/reference/reference_rock/dbms.rst:554
#: ../doc/1.7/reference/reference_rock/dbms.rst:577
msgid "**Example:**"
msgstr "**Пример:**"

#: ../doc/1.7/book/box/box_ctl.rst:38
msgid ""
"tarantool> box.info().ro\n"
"---\n"
"- false\n"
"...\n"
"\n"
"tarantool> n = box.ctl.wait_ro(0.1)\n"
"---\n"
"- error: timed out\n"
"..."
msgstr ""
"tarantool> box.info().ro\n"
" ---\n"
" - false\n"
" ...\n"
" \n"
" tarantool> n = box.ctl.wait_ro(0.1)\n"
" ---\n"
" - error: timed out\n"
" ..."

#: ../doc/1.7/book/box/box_ctl.rst:54
msgid "Wait until box.info.ro is false."
msgstr "Дождаться, пока не перестанет соблюдаться box.info.ro."

#: ../doc/1.7/book/box/box_ctl.rst:62
msgid ""
"tarantool> box.ctl.wait_rw(0.1)\n"
"---\n"
"..."
msgstr ""
"tarantool> box.ctl.wait_rw(0.1)\n"
"        ---\n"
"        ..."

#: ../doc/1.7/book/box/box_index.rst:5
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../doc/1.7/book/box/box_index.rst:9 ../doc/1.7/book/box/box_schema.rst:11
#: ../doc/1.7/book/box/box_session.rst:9 ../doc/1.7/book/box/box_slab.rst:11
#: ../doc/1.7/book/box/box_space.rst:9 ../doc/1.7/book/box/box_tuple.rst:11
#: ../doc/1.7/book/box/box_txn_management.rst:9 ../doc/1.7/intro.rst:3
#: ../doc/1.7/reference/reference_lua/box_error.rst:9
#: ../doc/1.7/reference/reference_lua/clock.rst:9
#: ../doc/1.7/reference/reference_lua/console.rst:9
#: ../doc/1.7/reference/reference_lua/crypto.rst:11
#: ../doc/1.7/reference/reference_lua/csv.rst:9
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:9
#: ../doc/1.7/reference/reference_lua/digest.rst:11
#: ../doc/1.7/reference/reference_lua/errno.rst:11
#: ../doc/1.7/reference/reference_lua/fiber.rst:9
#: ../doc/1.7/reference/reference_lua/fio.rst:11
#: ../doc/1.7/reference/reference_lua/http.rst:11
#: ../doc/1.7/reference/reference_lua/iconv.rst:11
#: ../doc/1.7/reference/reference_lua/json.rst:9
#: ../doc/1.7/reference/reference_lua/log.rst:11
#: ../doc/1.7/reference/reference_lua/msgpack.rst:9
#: ../doc/1.7/reference/reference_lua/net_box.rst:9
#: ../doc/1.7/reference/reference_lua/osmodule.rst:11
#: ../doc/1.7/reference/reference_lua/socket.rst:9
#: ../doc/1.7/reference/reference_lua/string.rst:9
#: ../doc/1.7/reference/reference_lua/tap.rst:7
#: ../doc/1.7/reference/reference_lua/uri.rst:7
#: ../doc/1.7/reference/reference_lua/uuid.rst:7
#: ../doc/1.7/reference/reference_lua/yaml.rst:9
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/1.7/book/box/box_index.rst:11
msgid "The ``box.index`` submodule provides read-only access for index definitions and index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array within each space object. They provide an API for ordered iteration over tuples. This API is a direct binding to corresponding methods of index objects of type ``box.index`` in the storage engine."
msgstr "Вложенный модуль ``box.index`` обеспечивает доступ к схемам индекса и ключам индекса в режиме только для чтения. Индексы хранятся в массиве :samp:`box.space.{space-name}.index` в каждом спейсе. Они предоставляют API для упорядоченной итерации по кортежам. Этот API представляет собой прямую привязку к соответствующим методам объектов типа``box.index`` в движке базы данных."

#: ../doc/1.7/book/box/box_index.rst:19 ../doc/1.7/book/box/box_schema.rst:18
#: ../doc/1.7/book/box/box_session.rst:18 ../doc/1.7/book/box/box_slab.rst:19
#: ../doc/1.7/book/box/box_space.rst:19 ../doc/1.7/book/box/box_tuple.rst:20
#: ../doc/1.7/book/box/box_txn_management.rst:41
#: ../doc/1.7/book/box/data_model.rst:66
#: ../doc/1.7/reference/reference_lua/box_error.rst:19
#: ../doc/1.7/reference/reference_lua/clock.rst:18
#: ../doc/1.7/reference/reference_lua/console.rst:17
#: ../doc/1.7/reference/reference_lua/crypto.rst:22
#: ../doc/1.7/reference/reference_lua/csv.rst:41
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:33
#: ../doc/1.7/reference/reference_lua/digest.rst:23
#: ../doc/1.7/reference/reference_lua/errno.rst:19
#: ../doc/1.7/reference/reference_lua/fiber.rst:22
#: ../doc/1.7/reference/reference_lua/fio.rst:27
#: ../doc/1.7/reference/reference_lua/http.rst:19
#: ../doc/1.7/reference/reference_lua/iconv.rst:24
#: ../doc/1.7/reference/reference_lua/json.rst:17
#: ../doc/1.7/reference/reference_lua/log.rst:20
#: ../doc/1.7/reference/reference_lua/msgpack.rst:18
#: ../doc/1.7/reference/reference_lua/net_box.rst:66
#: ../doc/1.7/reference/reference_lua/osmodule.rst:28
#: ../doc/1.7/reference/reference_lua/other.rst:7
#: ../doc/1.7/reference/reference_lua/pickle.rst:7
#: ../doc/1.7/reference/reference_lua/socket.rst:28
#: ../doc/1.7/reference/reference_lua/tap.rst:17
#: ../doc/1.7/reference/reference_lua/uri.rst:35
#: ../doc/1.7/reference/reference_lua/uuid.rst:17
#: ../doc/1.7/reference/reference_lua/yaml.rst:16
msgid "Index"
msgstr "Индекс"

#: ../doc/1.7/book/box/box_index.rst:21
msgid "Below is a list of all ``box.index`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``box.index``."

#: ../doc/1.7/book/box/box_index.rst:29 ../doc/1.7/book/box/box_schema.rst:28
#: ../doc/1.7/book/box/box_schema.rst:129
#: ../doc/1.7/book/box/box_session.rst:28 ../doc/1.7/book/box/box_slab.rst:29
#: ../doc/1.7/book/box/box_space.rst:29 ../doc/1.7/book/box/box_space.rst:265
#: ../doc/1.7/book/box/box_space.rst:1735 ../doc/1.7/book/box/box_tuple.rst:30
#: ../doc/1.7/book/box/box_txn_management.rst:51
#: ../doc/1.7/reference/reference_lua/box_error.rst:29
#: ../doc/1.7/reference/reference_lua/clock.rst:28
#: ../doc/1.7/reference/reference_lua/console.rst:27
#: ../doc/1.7/reference/reference_lua/crypto.rst:32
#: ../doc/1.7/reference/reference_lua/csv.rst:51
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:43
#: ../doc/1.7/reference/reference_lua/digest.rst:33
#: ../doc/1.7/reference/reference_lua/errno.rst:29
#: ../doc/1.7/reference/reference_lua/fiber.rst:32
#: ../doc/1.7/reference/reference_lua/fio.rst:37
#: ../doc/1.7/reference/reference_lua/http.rst:29
#: ../doc/1.7/reference/reference_lua/iconv.rst:34
#: ../doc/1.7/reference/reference_lua/json.rst:27
#: ../doc/1.7/reference/reference_lua/log.rst:30
#: ../doc/1.7/reference/reference_lua/msgpack.rst:28
#: ../doc/1.7/reference/reference_lua/net_box.rst:76
#: ../doc/1.7/reference/reference_lua/osmodule.rst:38
#: ../doc/1.7/reference/reference_lua/other.rst:17
#: ../doc/1.7/reference/reference_lua/pickle.rst:17
#: ../doc/1.7/reference/reference_lua/socket.rst:38
#: ../doc/1.7/reference/reference_lua/string.rst:28
#: ../doc/1.7/reference/reference_lua/tap.rst:27
#: ../doc/1.7/reference/reference_lua/uri.rst:45
#: ../doc/1.7/reference/reference_lua/uuid.rst:27
#: ../doc/1.7/reference/reference_lua/yaml.rst:26
msgid "Name"
msgstr "Имя"

#: ../doc/1.7/book/box/box_index.rst:29 ../doc/1.7/book/box/box_schema.rst:28
#: ../doc/1.7/book/box/box_session.rst:28 ../doc/1.7/book/box/box_slab.rst:29
#: ../doc/1.7/book/box/box_space.rst:29 ../doc/1.7/book/box/box_tuple.rst:30
#: ../doc/1.7/book/box/box_txn_management.rst:51
#: ../doc/1.7/reference/reference_lua/box_error.rst:29
#: ../doc/1.7/reference/reference_lua/clock.rst:28
#: ../doc/1.7/reference/reference_lua/console.rst:27
#: ../doc/1.7/reference/reference_lua/crypto.rst:32
#: ../doc/1.7/reference/reference_lua/csv.rst:51
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:43
#: ../doc/1.7/reference/reference_lua/digest.rst:33
#: ../doc/1.7/reference/reference_lua/errno.rst:29
#: ../doc/1.7/reference/reference_lua/fiber.rst:32
#: ../doc/1.7/reference/reference_lua/fio.rst:37
#: ../doc/1.7/reference/reference_lua/http.rst:29
#: ../doc/1.7/reference/reference_lua/iconv.rst:34
#: ../doc/1.7/reference/reference_lua/json.rst:27
#: ../doc/1.7/reference/reference_lua/log.rst:30
#: ../doc/1.7/reference/reference_lua/msgpack.rst:28
#: ../doc/1.7/reference/reference_lua/net_box.rst:76
#: ../doc/1.7/reference/reference_lua/osmodule.rst:38
#: ../doc/1.7/reference/reference_lua/other.rst:17
#: ../doc/1.7/reference/reference_lua/pickle.rst:17
#: ../doc/1.7/reference/reference_lua/socket.rst:38
#: ../doc/1.7/reference/reference_lua/string.rst:28
#: ../doc/1.7/reference/reference_lua/tap.rst:27
#: ../doc/1.7/reference/reference_lua/uri.rst:45
#: ../doc/1.7/reference/reference_lua/uuid.rst:27
#: ../doc/1.7/reference/reference_lua/yaml.rst:26
msgid "Use"
msgstr "Использование"

#: ../doc/1.7/book/box/box_index.rst:31
msgid ":ref:`index_object.unique <box_index-unique>`"
msgstr ":ref:`index_object.unique <box_index-unique>`"

#: ../doc/1.7/book/box/box_index.rst:31
msgid "Flag, true if an index is unique"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:34
msgid ":ref:`index_object.type <box_index-type>`"
msgstr ":ref:`index_object.type <box_index-type>`"

#: ../doc/1.7/book/box/box_index.rst:34 ../doc/1.7/book/box/data_model.rst:269
#: ../doc/1.7/book/box/data_model.rst:862
msgid "Index type"
msgstr "Тип индекса"

#: ../doc/1.7/book/box/box_index.rst:37
msgid ":ref:`index_object.parts <box_index-parts>`"
msgstr ":ref:`index_object.parts <box_index-parts>`"

#: ../doc/1.7/book/box/box_index.rst:37
msgid "Array of index key fields"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:40
msgid ":ref:`index_object:pairs() <box_index-index_pairs>`"
msgstr ":ref:`index_object:pairs() <box_index-index_pairs>`"

#: ../doc/1.7/book/box/box_index.rst:40 ../doc/1.7/book/box/box_space.rst:69
#: ../doc/1.7/book/box/box_tuple.rst:62
msgid "Prepare for iterating"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:43
msgid ":ref:`index_object:select() <box_index-select>`"
msgstr ":ref:`index_object:select() <box_index-select>`"

#: ../doc/1.7/book/box/box_index.rst:43
msgid "Select one or more tuples via index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:46
msgid ":ref:`index_object:get() <box_index-get>`"
msgstr ":ref:`index_object:get() <box_index-get>`"

#: ../doc/1.7/book/box/box_index.rst:46
msgid "Select a tuple via index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:49
msgid ":ref:`index_object:min() <box_index-min>`"
msgstr ":ref:`index_object:min() <box_index-min>`"

#: ../doc/1.7/book/box/box_index.rst:49
msgid "Find the minimum value in index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:52
msgid ":ref:`index_object:max() <box_index-max>`"
msgstr ":ref:`index_object:max() <box_index-max>`"

#: ../doc/1.7/book/box/box_index.rst:52
msgid "Find the maximum value in index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:55
msgid ":ref:`index_object:random() <box_index-random>`"
msgstr ":ref:`index_object:random() <box_index-random>`"

#: ../doc/1.7/book/box/box_index.rst:55
msgid "Find a random value in index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:58
msgid ":ref:`index_object:count() <box_index-count>`"
msgstr ":ref:`index_object:count() <box_index-count>`"

#: ../doc/1.7/book/box/box_index.rst:58
msgid "Count tuples matching key value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:61
msgid ":ref:`index_object:update() <box_index-update>`"
msgstr ":ref:`index_object:update() <box_index-update>`"

#: ../doc/1.7/book/box/box_index.rst:61 ../doc/1.7/book/box/box_space.rst:90
#: ../doc/1.7/book/box/box_space.rst:93 ../doc/1.7/book/box/box_tuple.rst:65
#: ../doc/1.7/reference/reference_lua/net_box.rst:110
#: ../doc/1.7/reference/reference_lua/net_box.rst:113
msgid "Update a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:64
msgid ":ref:`index_object:delete() <box_index-delete>`"
msgstr ":ref:`index_object:delete() <box_index-delete>`"

#: ../doc/1.7/book/box/box_index.rst:64
msgid "Delete a tuple by key"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:67
msgid ":ref:`index_object:alter() <box_index-alter>`"
msgstr ":ref:`index_object:alter() <box_index-alter>`"

#: ../doc/1.7/book/box/box_index.rst:67
msgid "Alter an index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:70
msgid ":ref:`index_object:drop() <box_index-drop>`"
msgstr ":ref:`index_object:drop() <box_index-drop>`"

#: ../doc/1.7/book/box/box_index.rst:70
msgid "Drop an index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:73
msgid ":ref:`index_object:rename() <box_index-rename>`"
msgstr ":ref:`index_object:rename() <box_index-rename>`"

#: ../doc/1.7/book/box/box_index.rst:73
msgid "Rename an index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:76
msgid ":ref:`index_object:bsize() <box_index-bsize>`"
msgstr ":ref:`index_object:bsize() <box_index-bsize>`"

#: ../doc/1.7/book/box/box_index.rst:76
msgid "Get count of bytes for an index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:88
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_info.rst
#: ../doc/1.7/book/box/box_schema.rst ../doc/1.7/book/box/box_session.rst
#: ../doc/1.7/book/box/box_slab.rst ../doc/1.7/book/box/box_space.rst
#: ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/reference/reference_lua/buffer.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/errno.rst
#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/xlog.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "rtype"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:90 ../doc/1.7/book/box/box_schema.rst:131
#: ../doc/1.7/book/box/box_schema.rst:149 ../doc/1.7/book/box/box_space.rst:275
#: ../doc/1.7/book/box/box_space.rst:277 ../doc/1.7/book/box/data_model.rst:155
#: ../doc/1.7/reference/reference_lua/fiber.rst:668
#: ../doc/1.7/reference/reference_lua/fiber.rst:700
#: ../doc/1.7/reference/reference_lua/fiber.rst:720
#: ../doc/1.7/reference/reference_lua/fiber.rst:730
#: ../doc/1.7/reference/reference_lua/fiber.rst:740
#: ../doc/1.7/reference/reference_lua/fiber.rst:748
#: ../doc/1.7/reference/reference_lua/fiber.rst:860
#: ../doc/1.7/reference/reference_lua/fio.rst:265
#: ../doc/1.7/reference/reference_lua/fio.rst:273
#: ../doc/1.7/reference/reference_lua/fio.rst:281
#: ../doc/1.7/reference/reference_lua/fio.rst:289
#: ../doc/1.7/reference/reference_lua/fio.rst:297
#: ../doc/1.7/reference/reference_lua/fio.rst:389
#: ../doc/1.7/reference/reference_lua/fio.rst:409
#: ../doc/1.7/reference/reference_lua/fio.rst:509
#: ../doc/1.7/reference/reference_lua/fio.rst:531
#: ../doc/1.7/reference/reference_lua/fio.rst:554
#: ../doc/1.7/reference/reference_lua/fio.rst:606
#: ../doc/1.7/reference/reference_lua/fio.rst:629
#: ../doc/1.7/reference/reference_lua/fio.rst:677
#: ../doc/1.7/reference/reference_lua/fio.rst:695
#: ../doc/1.7/reference/reference_lua/fio.rst:796
#: ../doc/1.7/reference/reference_lua/fio.rst:855
#: ../doc/1.7/reference/reference_lua/fio.rst:940
#: ../doc/1.7/reference/reference_lua/fio.rst:967
#: ../doc/1.7/reference/reference_lua/net_box.rst:222
#: ../doc/1.7/reference/reference_lua/net_box.rst:238
#: ../doc/1.7/reference/reference_lua/net_box.rst:253
#: ../doc/1.7/reference/reference_lua/net_box.rst:270
#: ../doc/1.7/reference/reference_lua/socket.rst:243
#: ../doc/1.7/reference/reference_lua/socket.rst:344
#: ../doc/1.7/reference/reference_lua/socket.rst:422
#: ../doc/1.7/reference/reference_lua/socket.rst:433
#: ../doc/1.7/reference/reference_lua/string.rst:141
#: ../doc/1.7/reference/reference_lua/string.rst:171
#: ../doc/1.7/reference/reference_lua/tap.rst:143
#: ../doc/1.7/reference/reference_lua/tap.rst:166
#: ../doc/1.7/reference/reference_lua/tap.rst:200
#: ../doc/1.7/reference/reference_lua/tap.rst:235
#: ../doc/1.7/reference/reference_lua/tap.rst:248
#: ../doc/1.7/reference/reference_lua/tap.rst:258
#: ../doc/1.7/reference/reference_lua/tap.rst:273
#: ../doc/1.7/reference/reference_lua/tap.rst:294
#: ../doc/1.7/reference/reference_lua/tap.rst:313
msgid "boolean"
msgstr "boolean"

#: ../doc/1.7/book/box/box_index.rst:96
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:102
msgid "An array describing the index fields. To learn more about the index field types, refer to :ref:`this table <box_space-index_field_types>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:105 ../doc/1.7/book/box/box_info.rst:158
#: ../doc/1.7/book/box/box_schema.rst:162 ../doc/1.7/book/box/box_slab.rst:53
#: ../doc/1.7/book/box/box_slab.rst:112 ../doc/1.7/book/box/box_slab.rst:154
#: ../doc/1.7/book/box/box_space.rst:1404
#: ../doc/1.7/reference/reference_lua/csv.rst:75
#: ../doc/1.7/reference/reference_lua/fiber.rst:303
#: ../doc/1.7/reference/reference_lua/fio.rst:430
#: ../doc/1.7/reference/reference_lua/fio.rst:451
#: ../doc/1.7/reference/reference_lua/fio.rst:1013
#: ../doc/1.7/reference/reference_lua/http.rst:119
#: ../doc/1.7/reference/reference_lua/json.rst:87
#: ../doc/1.7/reference/reference_lua/pickle.rst:136
#: ../doc/1.7/reference/reference_lua/socket.rst:173
#: ../doc/1.7/reference/reference_lua/socket.rst:545
#: ../doc/1.7/reference/reference_lua/socket.rst:557
#: ../doc/1.7/reference/reference_lua/string.rst:201
#: ../doc/1.7/reference/reference_lua/table.rst:48
#: ../doc/1.7/reference/reference_lua/yaml.rst:58
msgid "table"
msgstr "таблица"

#: ../doc/1.7/book/box/box_index.rst:109
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""
"tarantool> box.space.tester.index.primary\n"
"        ---\n"
"        - unique: true\n"
"          parts:\n"
"          - type: unsigned\n"
"            is_nullable: false\n"
"            fieldno: 1\n"
"          id: 0\n"
"          space_id: 513\n"
"          name: primary\n"
"          type: TREE\n"
"        ..."

#: ../doc/1.7/book/box/box_index.rst:128
msgid "Search for a tuple or a set of tuples via the given index, and allow iterating over one tuple at a time."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:131
msgid "The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:135
msgid ":samp:`{key}` is only used to find the first match. Do not assume all matched tuples will contain the key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:138
msgid "The :samp:`{iterator}` parameter specifies the rule for matching and ordering. Different index types support different iterators. For example, a TREE index maintains a strict order of keys and can return all tuples in ascending or descending order, starting from the specified key. Other index types, however, do not support ordering."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:144
msgid "To understand consistency of tuples returned by an iterator, it's essential to know the principles of the Tarantool transaction processing subsystem. An iterator in Tarantool does not own a consistent read view. Instead, each procedure is granted exclusive access to all tuples and spaces until there is a \"context switch\": which may happen due to :ref:`the implicit yield rules <atomic-implicit-yields>`, or by an explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution flow returns to the yielded procedure, the data set could have changed significantly. Iteration, resumed after a yield point, does not preserve the read view, but continues with the new content of the database. The tutorial :ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and yields can be used together."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:158 ../doc/1.7/book/box/box_index.rst:510
#: ../doc/1.7/book/box/box_index.rst:645 ../doc/1.7/book/box/box_index.rst:676
#: ../doc/1.7/book/box/box_index.rst:704 ../doc/1.7/book/box/box_index.rst:735
#: ../doc/1.7/book/box/box_index.rst:762 ../doc/1.7/book/box/box_index.rst:793
#: ../doc/1.7/book/box/box_index.rst:816 ../doc/1.7/book/box/box_index.rst:832
#: ../doc/1.7/book/box/box_index.rst:864 ../doc/1.7/book/box/box_index.rst:889
#: ../doc/1.7/book/box/box_index.rst:913
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:160 ../doc/1.7/book/box/box_space.rst:907
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:162
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:166 ../doc/1.7/book/box/box_space.rst:912
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a for/end loop or with `totable() <https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:170 ../doc/1.7/book/box/box_index.rst:652
#: ../doc/1.7/book/box/box_index.rst:840 ../doc/1.7/book/box/box_index.rst:869
#: ../doc/1.7/book/box/box_space.rst:164 ../doc/1.7/book/box/box_space.rst:319
#: ../doc/1.7/book/box/box_space.rst:537 ../doc/1.7/book/box/box_space.rst:916
#: ../doc/1.7/book/box/box_space.rst:1061
#: ../doc/1.7/book/box/box_space.rst:1325
msgid "**Possible errors:**"
msgstr "**Возможные ошибки:**"

#: ../doc/1.7/book/box/box_index.rst:172
msgid "no such space; wrong type;"
msgstr "no such space; wrong type;"

#: ../doc/1.7/book/box/box_index.rst:173
msgid "selected iteration type is not supported for the index type;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:174
msgid "key is not supported for the iteration type."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:176
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:179
msgid "A search-key-value can be a number (for example ``1234``), a string (for example ``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). Each part of a key will be compared to each part of an index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:184
msgid "The returned tuples will be in order by index key value, or by the hash of the index key value if index type = 'hash'. If the index is non-unique, then duplicates will be secondarily in order by primary key value. The order will be reversed if the iterator type is 'LT' or 'LE' or 'REQ'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:191
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:200 ../doc/1.7/book/box/box_index.rst:298
#: ../doc/1.7/book/box/box_index.rst:332 ../doc/1.7/book/box/box_index.rst:368
#: ../doc/1.7/book/box/box_schema.rst:129 ../doc/1.7/book/box/box_space.rst:265
#: ../doc/1.7/book/box/box_space.rst:1735
msgid "Type"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:200 ../doc/1.7/book/box/box_index.rst:298
#: ../doc/1.7/book/box/box_index.rst:332 ../doc/1.7/book/box/box_index.rst:368
msgid "Arguments"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:200 ../doc/1.7/book/box/box_index.rst:298
#: ../doc/1.7/book/box/box_index.rst:332 ../doc/1.7/book/box/box_index.rst:368
#: ../doc/1.7/book/box/box_space.rst:1735
msgid "Description"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:202 ../doc/1.7/book/box/box_index.rst:305
#: ../doc/1.7/book/box/box_index.rst:338 ../doc/1.7/book/box/box_index.rst:373
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:202 ../doc/1.7/book/box/box_index.rst:208
#: ../doc/1.7/book/box/box_index.rst:213 ../doc/1.7/book/box/box_index.rst:220
#: ../doc/1.7/book/box/box_index.rst:227 ../doc/1.7/book/box/box_index.rst:231
#: ../doc/1.7/book/box/box_index.rst:237 ../doc/1.7/book/box/box_index.rst:305
#: ../doc/1.7/book/box/box_index.rst:311 ../doc/1.7/book/box/box_index.rst:373
#: ../doc/1.7/book/box/box_index.rst:381 ../doc/1.7/book/box/box_index.rst:386
#: ../doc/1.7/book/box/box_index.rst:391 ../doc/1.7/book/box/box_index.rst:396
#: ../doc/1.7/book/box/box_index.rst:406
msgid "search value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:202
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. Tuples are returned in ascending order by index key. This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:208
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:208
msgid "Matching is the same as for ``box.index.EQ``. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:213 ../doc/1.7/book/box/box_index.rst:311
#: ../doc/1.7/book/box/box_index.rst:381
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:213
msgid "The comparison operator is '>' (greater than). If an index key is greater than a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:220 ../doc/1.7/book/box/box_index.rst:386
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:220
msgid "The comparison operator is '>=' (greater than or equal to). If an index key is greater than or equal to a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:227 ../doc/1.7/book/box/box_index.rst:334
#: ../doc/1.7/book/box/box_index.rst:370
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:227
msgid "Same as box.index.GE."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:231 ../doc/1.7/book/box/box_index.rst:391
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:231
msgid "The comparison operator is '<' (less than). If an index key is less than a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:237 ../doc/1.7/book/box/box_index.rst:396
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:237
msgid "The comparison operator is '<=' (less than or equal to). If an index key is less than or equal to a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:245
msgid "Informally, we can state that searches with TREE indexes are generally what users will find is intuitive, provided that there are no nils and no missing parts. Formally, the logic is as follows. A search key has zero or more parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or more parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain nil (but not msgpack.NULL, which is the wrong type). An index key may not contain nil or msgpack.NULL, although a later version of Tarantool will have different rules --  the behavior of searches with nil is subject to change. Possible iterators are LT, LE, EQ, REQ, GE, GT. A search key is said to \"match\" an index key if the following statements, which are pseudocode for the comparison operation, return TRUE."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:295
msgid ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
"If (number-of-search-key-parts == 0) return TRUE\n"
"for (i = 1; ; ++i)\n"
"{\n"
"  if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (type of search-key-part[i] is not compatible with type of index-key-part[i])\n"
"  {\n"
"    return ERROR\n"
"  }\n"
"  if (search-key-part[i] == index-key-part[i])\n"
"  {\n"
"    if (iterator is LT or GT) return FALSE\n"
"    continue\n"
"  }\n"
"  if (search-key-part[i] > index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"  if (search-key-part[i] < index-key-part[i])\n"
"  {\n"
"    if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"    return TRUE\n"
"  }\n"
"}"
msgstr ""
"If (number-of-search-key-parts > number-of-index-key-parts) return ERROR\n"
" If (number-of-search-key-parts == 0) return TRUE\n"
" for (i = 1; ; ++i)\n"
" {\n"
"   if (i > number-of-search-key-parts) OR (search-key-part[i] is nil)\n"
"   {\n"
"     if (iterator is LT or GT) return FALSE\n"
"     return TRUE\n"
"   }\n"
"   if (type of search-key-part[i] is not compatible with type of index-key-part[i])\n"
"   {\n"
"     return ERROR\n"
"   }\n"
"   if (search-key-part[i] == index-key-part[i])\n"
"   {\n"
"     if (iterator is LT or GT) return FALSE\n"
"     continue\n"
"   }\n"
"   if (search-key-part[i] > index-key-part[i])\n"
"   {\n"
"     if (iterator is EQ or REQ or LE or LT) return FALSE\n"
"     return TRUE\n"
"   }\n"
"   if (search-key-part[i] < index-key-part[i])\n"
"   {\n"
"     if (iterator is EQ or REQ or GE or GT) return FALSE\n"
"     return TRUE\n"
"   }\n"
" }"

#: ../doc/1.7/book/box/box_index.rst:291
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:300
msgid "box.index.ALL"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:300 ../doc/1.7/book/box/box_index.rst:334
#: ../doc/1.7/book/box/box_index.rst:370
msgid "none"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:300
msgid "All index keys match. Tuples are returned in ascending order by hash of index key, which will appear to be random."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:305
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. The number of returned tuples will be 0 or 1. This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:311
msgid "The comparison operator is '>' (greater than). If a hash of an index key is greater than a hash of a search value, it matches. Tuples are returned in ascending order by hash of index key, which will appear to be random. Provided that the space is not being updated, one can retrieve all the tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in each search, and using the last returned value from the previous result as the start search value for the next search."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:325
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:334
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:338 ../doc/1.7/book/box/box_index.rst:343
#: ../doc/1.7/book/box/box_index.rst:348 ../doc/1.7/book/box/box_index.rst:353
msgid "bitset value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:338
msgid "If an index key is equal to a bitset value, it matches. Tuples are returned in their order within the space. This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:343
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:343
msgid "If all of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:348
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:348
msgid "If any of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:353
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:353
msgid "If all of the bits which are 1 in the bitset value are 0 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:361
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:370
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:373
msgid "If all points of the rectangle-or-box defined by the search value are the same as the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-or-box as explained in section about :ref:`RTREE <box_index-rtree>`\". This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:381
msgid "If all points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:386
msgid "If all points of the rectangle-or-box defined by the search value are within, or at the side of, the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:391
msgid "If all points of the rectangle-or-box defined by the index key are within the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:396
msgid "If all points of the rectangle-or-box defined by the index key are within, or at the side of, the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:401
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:401
msgid "search values"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:401
msgid "If some points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:406
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:406
msgid "If some points of the rectangle-or-box defined by the defined by the key are within, or at the side of, defined by the index key, it matches. Tuples are returned in order: nearest neighbor first."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:412
msgid "**First example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:414
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:416
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space17')\n"
" ---\n"
" ...\n"
" tarantool> s:create_index('primary', {\n"
"          >   parts = {1, 'string', 2, 'string'}\n"
"          > })\n"
" ---\n"
" ...\n"
" tarantool> s:insert{'C', 'C'}\n"
" ---\n"
" - ['C', 'C']\n"
" ...\n"
" tarantool> s:insert{'B', 'A'}\n"
" ---\n"
" - ['B', 'A']\n"
" ...\n"
" tarantool> s:insert{'C', '!'}\n"
" ---\n"
" - ['C', '!']\n"
" ...\n"
" tarantool> s:insert{'A', 'C'}\n"
" ---\n"
" - ['A', 'C']\n"
" ...\n"
" tarantool> function example()\n"
"          >   for _, tuple in\n"
"          >     s.index.primary:pairs(nil, {\n"
"          >         iterator = box.index.ALL}) do\n"
"          >       print(tuple)\n"
"          >   end\n"
"          > end\n"
" ---\n"
" ...\n"
" tarantool> example()\n"
" ['A', 'C']\n"
" ['B', 'A']\n"
" ['C', '!']\n"
" ['C', 'C']\n"
" ---\n"
" ...\n"
" tarantool> s:drop()\n"
" ---\n"
" ..."

#: ../doc/1.7/book/box/box_index.rst:462
msgid "**Second example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:464
msgid "This Lua code finds all the tuples whose primary key values begin with 'XY'. The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a string. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 'XY'. The conditional statement within the loop ensures that the looping will stop when the first two letters are not 'XY'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:472
msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
" box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"   if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"   print(tuple)\n"
" end"

#: ../doc/1.7/book/box/box_index.rst:480
msgid "**Third example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:482
msgid "This Lua code finds all the tuples whose primary key values are greater than or equal to 1000, and less than or equal to 1999 (this type of request is sometimes called a \"range search\" or a \"between search\"). The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a :ref:`number <index-box_number>`. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 1000. The conditional statement within the loop ensures that the looping will stop when the first value is greater than 1999."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:492
msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""
"for _, tuple in\n"
" box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"   if (tuple[1] > 1999) then break end\n"
"   print(tuple)\n"
" end"

#: ../doc/1.7/book/box/box_index.rst:504
msgid "This is an alternative to :ref:`box.space...select() <box_space-select>` which goes via a particular index and can make use of additional parameters that specify the iterator type, and the limit (that is, the maximum number of tuples to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:512 ../doc/1.7/book/box/box_index.rst:647
#: ../doc/1.7/book/box/box_index.rst:678 ../doc/1.7/book/box/box_index.rst:706
#: ../doc/1.7/book/box/box_index.rst:764 ../doc/1.7/book/box/box_index.rst:795
#: ../doc/1.7/book/box/box_index.rst:818
msgid "values to be matched against the index key"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:513
msgid "none, any or all of next parameters"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:514
msgid "type of iterator"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:515
msgid "maximum number of tuples"
msgstr "максимальное количество кортежей"

#: ../doc/1.7/book/box/box_index.rst:516
msgid "start tuple number"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:518
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:519 ../doc/1.7/book/box/box_space.rst:1059
msgid "array of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:523
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""
"-- Создать спейс под названием tester.\n"
" tarantool> sp = box.schema.space.create('tester')\n"
" -- Создать уникальный индекс 'primary'\n"
" -- который не будет нужен для данного примера.\n"
" tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
" -- Создать неуникальный индекс 'secondary'\n"
" -- по второму полю.\n"
" tarantool> sp:create_index('secondary', {\n"
"          >   type = 'tree',\n"
"          >   unique = false,\n"
"          >   parts = {2, 'string'}\n"
"          > })\n"
" -- Вставить три кортежа, значения в поле2 (field[2])\n"
" -- равны 'X', 'Y' и 'Z'.\n"
" tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
" tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
" tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
" -- Выбрать все кортежи, где вторичные ключи\n"
" -- больше, чем 'X'.`\n"
" tarantool> sp.index.secondary:select({'X'}, {\n"
"          >   iterator = 'GT',\n"
"          >   limit = 1000\n"
"          > })"

#: ../doc/1.7/book/box/box_index.rst:549
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:551
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""
"---\n"
" - - [2, 'Y', 'Row with field[2]=Y']\n"
"   - [3, 'Z', 'Row with field[2]=Z']\n"
" ..."

#: ../doc/1.7/book/box/box_index.rst:560
msgid ":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index is the first (primary-key) index. Therefore, for the example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, via the 'primary' index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:567
msgid ":samp:`iterator = {iterator-type}` is optional. If it is omitted, then ``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:572
msgid ":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then every key in the index is considered to be a match, regardless of iterator type. Therefore, for the example above, ``box.space.tester:select{}`` will select every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:582
msgid ":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, ``get`` can be used as a convenient shorthand to get the first tuple in the tuple set that would be returned by ``select``. However, if there is more than one tuple in the tuple set, then ``get`` returns an error."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:590
msgid "**Example with BITSET index:**"
msgstr "**Пример с индексом BITSET:**"

#: ../doc/1.7/book/box/box_index.rst:592
msgid "The following script shows creation and search with a BITSET index. Notice: BITSET cannot be unique, so first a primary-key index is created. Notice: bit values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:596
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
" tarantool> s:create_index('primary_index', {\n"
"          >   parts = {1, 'string'},\n"
"          >   unique = true,\n"
"          >   type = 'TREE'\n"
"          > })\n"
" tarantool> s:create_index('bitset_index', {\n"
"          >   parts = {2, 'unsigned'},\n"
"          >   unique = false,\n"
"          >   type = 'BITSET'\n"
"          > })\n"
" tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
" tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
" tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
" tarantool> s.index.bitset_index:select(0x02, {\n"
"          >   iterator = box.index.EQ\n"
"          > })\n"
" ---\n"
" - - ['Tuple with bit value = 10', 2]\n"
" ...\n"
" tarantool> s.index.bitset_index:select(0x02, {\n"
"          >   iterator = box.index.BITS_ANY_SET\n"
"          > })\n"
" ---\n"
" - - ['Tuple with bit value = 10', 2]\n"
"   - ['Tuple with bit value = 11', 3]\n"
" ...\n"
" tarantool> s.index.bitset_index:select(0x02, {\n"
"          >   iterator = box.index.BITS_ALL_SET\n"
"          > })\n"
" ---\n"
" - - ['Tuple with bit value = 10', 2]\n"
"   - ['Tuple with bit value = 11', 3]\n"
" ...\n"
" tarantool> s.index.bitset_index:select(0x02, {\n"
"          >   iterator = box.index.BITS_ALL_NOT_SET\n"
"          > })\n"
" ---\n"
" - - ['Tuple with bit value = 01', 1]\n"
" ..."

#: ../doc/1.7/book/box/box_index.rst:643
msgid "Search for a tuple via the given index, as described :ref:`earlier <box_index-note>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:649
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:650 ../doc/1.7/book/box/box_index.rst:683
#: ../doc/1.7/book/box/box_index.rst:711 ../doc/1.7/book/box/box_index.rst:740
#: ../doc/1.7/book/box/box_index.rst:804 ../doc/1.7/book/box/box_index.rst:821
#: ../doc/1.7/book/box/box_space.rst:159 ../doc/1.7/book/box/box_space.rst:475
#: ../doc/1.7/book/box/box_space.rst:650 ../doc/1.7/book/box/box_space.rst:700
#: ../doc/1.7/book/box/box_space.rst:998 ../doc/1.7/book/box/box_space.rst:1203
#: ../doc/1.7/book/box/box_tuple.rst:83 ../doc/1.7/book/box/box_tuple.rst:239
#: ../doc/1.7/book/box/box_tuple.rst:240 ../doc/1.7/book/box/box_tuple.rst:406
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:221
msgid "tuple"
msgstr "кортеж"

#: ../doc/1.7/book/box/box_index.rst:654
msgid "no such index;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:655
msgid "wrong type;"
msgstr "неправильный тип;"

#: ../doc/1.7/book/box/box_index.rst:656
msgid "more than one tuple matches."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:658
msgid "**Complexity factors:** Index size, Index type. See also :ref:`space_object:get() <box_space-get>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:663
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:674
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:680
msgid "the tuple for the first key in the index. If optional ``key-value`` is supplied, returns the first key which is greater than or equal to ``key-value``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:685 ../doc/1.7/book/box/box_index.rst:713
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr "**Возможные ошибки:** index is not of type 'TREE'."

#: ../doc/1.7/book/box/box_index.rst:687 ../doc/1.7/book/box/box_index.rst:715
#: ../doc/1.7/book/box/box_index.rst:742 ../doc/1.7/book/box/box_space.rst:921
#: ../doc/1.7/book/box/box_space.rst:1066
msgid "**Complexity factors:** Index size, Index type."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:691
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:702
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:708
msgid "the tuple for the last key in the index. If optional ``key-value`` is supplied, returns the last key which is less than or equal to ``key-value``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:719
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:730
msgid "Find a random value in the specified index. This method is useful when it's important to get insight into data distribution in an index without having to iterate over the entire data set."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:737
msgid "an arbitrary non-negative integer"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:739
msgid "the tuple for the random key in the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:744
msgid "**Note re storage engine:** vinyl does not support ``random()``."
msgstr "**Примечание про движок базы данных:** vinyl не поддерживает ``random()``."

#: ../doc/1.7/book/box/box_index.rst:748
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:759
msgid "Iterate over an index, counting the number of tuples which match the key-value."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:765 ../doc/1.7/book/box/box_space.rst:220
msgid "comparison method"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:767
msgid "the number of matching index keys."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:768 ../doc/1.7/book/box/box_index.rst:917
#: ../doc/1.7/book/box/box_schema.rst:139
#: ../doc/1.7/book/box/box_schema.rst:143
#: ../doc/1.7/book/box/box_session.rst:78
#: ../doc/1.7/book/box/box_session.rst:85
#: ../doc/1.7/book/box/box_session.rst:113
#: ../doc/1.7/book/box/box_session.rst:198
#: ../doc/1.7/book/box/box_session.rst:229
#: ../doc/1.7/book/box/box_space.rst:273 ../doc/1.7/book/box/box_space.rst:286
#: ../doc/1.7/book/box/box_space.rst:291 ../doc/1.7/book/box/box_space.rst:293
#: ../doc/1.7/book/box/box_space.rst:295 ../doc/1.7/book/box/box_space.rst:297
#: ../doc/1.7/book/box/box_space.rst:299 ../doc/1.7/book/box/box_tuple.rst:117
#: ../doc/1.7/book/box/box_tuple.rst:146 ../doc/1.7/book/box/box_tuple.rst:199
#: ../doc/1.7/reference/reference_lua/fiber.rst:367
#: ../doc/1.7/reference/reference_lua/fiber.rst:709
#: ../doc/1.7/reference/reference_lua/fio.rst:314
#: ../doc/1.7/reference/reference_lua/fio.rst:990
#: ../doc/1.7/reference/reference_lua/socket.rst:262
#: ../doc/1.7/reference/reference_lua/socket.rst:385
msgid "number"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:772
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:787 ../doc/1.7/book/box/box_space.rst:1161
#: ../doc/1.7/book/box/box_tuple.rst:387
msgid "Update a tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:789
msgid "Same as :ref:`box.space...update() <box_space-update>`, but key is searched in this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:796 ../doc/1.7/book/box/box_space.rst:1195
#: ../doc/1.7/book/box/box_space.rst:1316
msgid "operation type represented in string"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:797 ../doc/1.7/book/box/box_space.rst:1196
#: ../doc/1.7/book/box/box_space.rst:1317 ../doc/1.7/book/box/box_tuple.rst:399
msgid "what field the operation will apply to. The field number can be negative, meaning the position from the end of tuple. (#tuple + negative field number + 1)"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:801 ../doc/1.7/book/box/box_space.rst:1200
#: ../doc/1.7/book/box/box_space.rst:1321 ../doc/1.7/book/box/box_tuple.rst:403
msgid "what value will be applied"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:803 ../doc/1.7/book/box/box_space.rst:1202
msgid "the updated tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:810
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:812
msgid "Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched in this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:820
msgid "the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:823
msgid "**Note re storage engine:** vinyl will return `nil`, rather than the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:830
msgid "Alter an index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:834
msgid "options list, same as the options list for ``create_index``, see the chart named :ref:`Options for space_object:create_index() <box_space-create_index>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:838 ../doc/1.7/book/box/box_index.rst:893
#: ../doc/1.7/book/box/box_schema.rst:229
#: ../doc/1.7/book/box/box_schema.rst:447
#: ../doc/1.7/book/box/box_schema.rst:597 ../doc/1.7/book/box/box_space.rst:512
#: ../doc/1.7/book/box/box_space.rst:967 ../doc/1.7/book/box/box_space.rst:1026
#: ../doc/1.7/book/box/box_space.rst:1135
#: ../doc/1.7/book/box/data_model.rst:153
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:245
#: ../doc/1.7/reference/reference_lua/console.rst:74
#: ../doc/1.7/reference/reference_lua/fiber.rst:413
#: ../doc/1.7/reference/reference_lua/fiber.rst:456
#: ../doc/1.7/reference/reference_lua/fiber.rst:869
#: ../doc/1.7/reference/reference_lua/fiber.rst:877
#: ../doc/1.7/reference/reference_lua/log.rst:94
#: ../doc/1.7/reference/reference_lua/log.rst:108
#: ../doc/1.7/reference/reference_lua/msgpack.rst:206
#: ../doc/1.7/reference/reference_lua/tap.rst:129
#: ../doc/1.7/reference/reference_lua/tap.rst:152
#: ../doc/1.7/reference/reference_lua/tap.rst:212
msgid "nil"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:842 ../doc/1.7/book/box/box_index.rst:871
msgid "index does not exist,"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:843
msgid "the first index cannot be changed to {unique = false},"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:847
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:861
msgid "Drop an index. Dropping a primary-key index has a side effect: all tuples are deleted."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:867
msgid "nil."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:872
msgid "a primary-key index cannot be dropped while a secondary-key index exists."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:877
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:887
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:240
msgid "Rename an index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:891
msgid "new name for index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:895
msgid "**Possible errors:** index_object does not exist."
msgstr "**Возможные ошибки:** index_object does not exist."

#: ../doc/1.7/book/box/box_index.rst:899
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:251
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:905 ../doc/1.7/book/box/box_space.rst:1133
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:911
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:916 ../doc/1.7/book/box/box_tuple.rst:145
msgid "number of bytes"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:921
msgid "Example showing use of the box functions"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:923
msgid "This example will work with the sandbox configuration described in the preface. That is, there is a space named tester with a numeric primary key. The example function will:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:927
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:928
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:931
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:930
msgid "field[1] = 1000"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:931
msgid "field[2] = a uuid"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:932
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:933
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:934
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:935
msgid "Return the formatted value."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:937
msgid "The function uses Tarantool box functions :ref:`box.space...select <box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:946
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:971 ../doc/1.7/book/box/box_tuple.rst:455
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:973
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:990
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:992
msgid "Here is an example that shows how to build one's own iterator. The ``paged_iter`` function is an \"iterator function\", which will only be understood by programmers who have read the Lua manual section `Iterators and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated retrievals, that is, it returns 10 tuples at a time from a table named \"t\", whose primary key was defined with ``create_index('primary',{parts={1,'string'}})``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:999
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1013
msgid "Programmers who use ``paged_iter`` do not need to know why it works, they only need to know that, if they call it within a loop, they will get 10 tuples at a time until there are no more tuples. In this example the tuples are merely printed, a page at a time. But it should be simple to change the functionality, for example by yielding after each retrieval, or by breaking when the tuples fail to match some additional criteria."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1020
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1033
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1035
msgid "The :ref:`box.index <box_index>` submodule may be used for spatial searches if the index type is RTREE. There are operations for searching *rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects with more than 4 corners and more than 4 sides, sometimes called hyperrectangles). This manual uses the term *rectangle-or-box* for the whole class of objects that includes both rectangles and boxes. Only rectangles will be illustrated."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1043
msgid "Rectangles are described according to their X-axis (horizontal axis) and Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a picture of four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1083
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1063
msgid "The rectangles are defined according to this scheme: {X-axis coordinate of top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1073
msgid "Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1076
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1078
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1091
msgid "Field#1 doesn't matter, we just make it because we need a primary-key index. (RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) The second field must be an \"array\", which means its values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1097
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1102
msgid "And now, following the description of `RTREE iterator types`_, we can search the rectangles with these requests:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1107
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1123
msgid "Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1131
msgid "Now let us create a space and index for cuboids, which are rectangle-or-boxes that have 6 corners and 6 sides."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1134
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1145
msgid "The additional option here is ``dimension=3``. The default dimension is 2, which is why it didn't need to be specified for the examples of rectangle. The maximum dimension is 20. Now for insertions and selections there will usually be 6 coordinates. For example:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1150
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1155
msgid "Now let us create a space and index for Manhattan-style spatial objects, which are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1158
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1169
msgid "The additional option here is ``distance='manhattan'``. The default distance calculator is 'euclid', which is the straightforward as-the-crow-flies method. The optional distance calculator is 'manhattan', which can be a more appropriate method if one is following the lines of a grid rather than traveling in a straight line."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1175
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1181
msgid "More examples of spatial searching are online in the file `R tree index quick start and usage`_."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:5
msgid "Submodule `box.info`"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:9
msgid "The ``box.info`` submodule provides access to information about server instance variables."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:12
msgid "**cluster.uuid** is the UUID of the replica set. Every instance in a replica set will have the same ``cluster.uuid`` value. This value is also stored in :ref:`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:16
msgid "**id** corresponds to **replication.id** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:18
msgid "**lsn** corresponds to **replication.lsn** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:20
msgid "**memory** has the statistics about memory (see :ref:`below <box_info_memory>`)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:22
msgid "**pid** is the process ID. This value is also shown by :ref:`tarantool <tarantool-build>` module and by the Linux command ``ps -A``."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:25
msgid "**ro** is ``true`` if the instance is in \"read-only\" mode (same as :ref:`read_only <cfg_basic-read_only>` in ``box.cfg{}``)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:27
msgid "**signature** is the sum of all **lsn** values from the vector clocks (**vclock**) of all instances in the replica set."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:29
msgid "**status** corresponds to **replication.upstream.status** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:30
msgid "**uptime** is the number of seconds since the instance started. This value can also be retrieved with :ref:`tarantool.uptime() <tarantool-build>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:33
msgid "**uuid** corresponds to **replication.uuid** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:35
msgid "**vclock** corresponds to **replication.downstream.vclock** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:37
msgid "**version** is the Tarantool version. This value is also shown by :ref:`tarantool -V <index-tarantool_version>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:39
msgid "**vinyl** returns runtime statistics for vinyl storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:45
msgid "The **memory** function of ``box.info`` gives the ``admin`` user a picture of the whole Tarantool instance. (Use ``box.info.vinyl()`` instead for a picture specifically of the vinyl subsystem.)"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:49
msgid "**memory().cache** -- number of bytes used for caching user data. The memtx storage engine does not require a cache, so in fact this is the number of bytes in the cache for the tuples stored for the vinyl storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:53
msgid "**memory().data** -- number of bytes used for storing user data (the tuples) with the memtx engine and with level 0 of the vinyl engine, without taking memory fragmentation into account."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:56
msgid "**memory().index** -- number of bytes used for indexing user data, including memtx and vinyl memory tree extents, the vinyl page index, and the vinyl bloom filters."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:59
msgid "**memory().lua** -- number of bytes used for Lua runtime."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:60
msgid "**memory().net** -- number of bytes used for network input/output buffers."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:61
msgid "**memory().tx** -- number of bytes in use by active transactions. For the vinyl storage engine, this is the total size of all allocated objects (struct ``txv``, struct ``vy_tx``, struct ``vy_read_interval``) and tuples pinned for those objects."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:66
msgid "An example with a minimum allocation while only the memtx storage engine is in use:"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:69
msgid ""
"tarantool> box.info.memory()\n"
"---\n"
"- cache: 0\n"
"  data: 6552\n"
"  tx: 0\n"
"  lua: 1315567\n"
"  net: 98304\n"
"  index: 1196032\n"
"..."
msgstr ""
"tarantool> box.info.memory()\n"
"        ---\n"
"        - cache: 0\n"
"          data: 6552\n"
"          tx: 0\n"
"          lua: 1315567\n"
"          net: 98304\n"
"          index: 1196032\n"
"        ..."

#: ../doc/1.7/book/box/box_info.rst:85
msgid "The **replication** section of ``box.info()`` contains statistics for all instances in the replica set in regard to the current instance (see also :ref:`\"Monitoring a replica set\" <replication-monitoring>`):"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:89
msgid "**replication.id** is a short numeric identifier of the instance within the replica set."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:91
msgid "**replication.uuid** is a globally unique identifier of the instance. This value is also stored in :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:94
msgid "**replication.lsn** is the :ref:`log sequence number <replication-mechanism>` (LSN) for the latest entry in the instance's :ref:`write ahead log <index-box_persistence>` (WAL)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:98
msgid "**replication.upstream** contains statistics for the replication data uploaded by the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:100
msgid "**replication.upstream.status** is the replication status of the instance:"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:102
msgid "``auth`` means that the instance is getting :ref:`authenticated <authentication>` to connect to a replication source."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:105
msgid "``connecting`` means that the instance is trying to connect to the replications source(s) listed in its :ref:`replication <cfg_replication-replication>` parameter."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:108
msgid "``disconnected`` means that the instance is not connected to the replica set (due to network problems, not replication errors)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:110
msgid "``follow`` means that replication is in progress."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:111
msgid "``running`` means the instance's role is \"master\" (non read-only) and replication is in progress."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:113
msgid "``stopped`` means that replication was stopped due to a replication error (e.g. :ref:`duplicate key <error_codes>`)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:118
msgid "**replication.upstream.idle** is the time (in seconds) since the instance received the last event from a master. This is the primary indicator of replication health. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:125
msgid "**replication.upstream.peer** contains the replication user name, host IP adress and port number used for the instance. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:131
msgid "**replication.upstream.lag** is the time difference between the local time at the instance, recorded when the event was received, and the local time at another master recorded when the event was written to the :ref:`write ahead log <internals-wal>` on that master. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:137
msgid "**replication.upstream.message** contains an error message in case of a :ref:`degraded state <replication-recover>`, empty otherwise."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:140
msgid "**replication.downstream** contains statistics for the replication data requested and downloaded from the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:143
msgid "**replication.downstream.vclock** contains the :ref:`vector clock <internals-vector>`, which is a table of '**id**, **lsn**' pairs, for example :code:`vclock: {1: 3054773, 4: 8938827, 3: 285902018}`. Even if an instance is :ref:`removed <replication-remove_instances>`, its values will still appear here."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:152
msgid "Since ``box.info`` contents are dynamic, it's not possible to iterate over keys with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and returns a Lua table with all keys and values provided in the submodule."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:157
msgid "keys and values in the submodule"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:162
msgid "This example is for a master-replica set that contains one master instance and one replica instance. The request was issued at the replica instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:165
msgid ""
"tarantool> box.info()\n"
"---\n"
"- version: 1.7.6-68-g51fcffb77\n"
"  id: 2\n"
"  ro: true\n"
"  vclock: {1: 5}\n"
"  uptime: 917\n"
"  lsn: 0\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 783e2285-55b1-42d4-b93c-68dcbb7a8c18\n"
"  pid: 35341\n"
"  status: running\n"
"  signature: 5\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 471cd36e-cb2e-4447-ac66-2d28e9dd3b67\n"
"      lsn: 5\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 124.98795700073\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 5}\n"
"    2:\n"
"      id: 2\n"
"      uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"      lsn: 0\n"
"  uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:5
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../doc/1.7/book/box/box_schema.rst:13
msgid "The ``box.schema`` submodule has data-definition functions for spaces, users, roles, function tuples, and sequences."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:20
msgid "Below is a list of all ``box.schema`` functions."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:30
msgid ":ref:`box.schema.space.create() <box_schema-space_create>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:30
msgid "Create a space"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:33
msgid ":ref:`box.schema.user.create() <box_schema-user_create>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:33
msgid "Create a user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:36
msgid ":ref:`box.schema.user.drop() <box_schema-user_drop>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:36
msgid "Drop a user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:39
msgid ":ref:`box.schema.user.exists() <box_schema-user_exists>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:39
msgid "Check if a user exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:42
msgid ":ref:`box.schema.user.grant() <box_schema-user_grant>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:42
msgid "Grant privileges to a user or a role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:45
msgid ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:45
msgid "Revoke privileges from a user or a role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:48
msgid ":ref:`box.schema.user.password() <box_schema-user_password>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:48
msgid "Get a hash of a user's password"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:51
msgid ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:51
msgid "Associate a password with a user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:54
msgid ":ref:`box.schema.user.info() <box_schema-user_info>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:54
msgid "Get a description of a user's privileges"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:57
msgid ":ref:`box.schema.role.create() <box_schema-role_create>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:57
msgid "Create a role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:60
msgid ":ref:`box.schema.role.drop() <box_schema-role_drop>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:60
msgid "Drop a role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:63
msgid ":ref:`box.schema.role.exists() <box_schema-role_exists>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:63
msgid "Check if a role exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:66
msgid ":ref:`box.schema.role.grant() <box_schema-role_grant>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:66
msgid "Grant privileges to a role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:69
msgid ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:69
msgid "Revoke privileges from a role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:72
msgid ":ref:`box.schema.role.info() <box_schema-role_info>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:72
msgid "Get a description of a role's privileges"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:75
msgid ":ref:`box.schema.func.create() <box_schema-func_create>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:75
msgid "Create a function tuple"
msgstr "Создание кортежа с функцией"

#: ../doc/1.7/book/box/box_schema.rst:78
msgid ":ref:`box.schema.func.drop() <box_schema-func_drop>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:78
msgid "Drop a function tuple"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:81
msgid ":ref:`box.schema.func.exists() <box_schema-func_exists>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:81
msgid "Check if a function tuple exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:84
msgid ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:84
msgid "Create a new sequence generator"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:87
msgid ":ref:`sequence_object:next() <box_schema-sequence_next>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:87
msgid "Generate and return the next value"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:90
msgid ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:90
msgid "Change sequence options"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:93
msgid ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:93
msgid "Reset sequence state"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:96
msgid ":ref:`sequence_object:set() <box_schema-sequence_set>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:96
msgid "Set the new value"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:99
msgid ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:99
msgid "Drop the sequence"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:102
msgid ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:102 ../doc/1.7/book/box/box_space.rst:40
msgid "Create an index"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:110
msgid "Create a :ref:`space <index-box_space>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:112
msgid "name of space, which should not be a number and should not contain special characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:114
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:116
msgid "space object"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:117
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:209
#: ../doc/1.7/reference/reference_lua/fiber.rst:188
#: ../doc/1.7/reference/reference_lua/fiber.rst:212
#: ../doc/1.7/reference/reference_lua/fiber.rst:232
#: ../doc/1.7/reference/reference_lua/fio.rst:757
#: ../doc/1.7/reference/reference_lua/http.rst:50
#: ../doc/1.7/reference/reference_lua/iconv.rst:53
#: ../doc/1.7/reference/reference_lua/net_box.rst:203
#: ../doc/1.7/reference/reference_lua/socket.rst:136
#: ../doc/1.7/reference/reference_lua/socket.rst:154
#: ../doc/1.7/reference/reference_lua/socket.rst:370
#: ../doc/1.7/reference/reference_lua/tap.rst:98
msgid "userdata"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:121
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:129 ../doc/1.7/book/box/box_space.rst:265
#: ../doc/1.7/book/box/data_model.rst:451
msgid "Default"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:131
msgid "temporary"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:131
msgid "space contents are temporary: changes are not stored in the :ref:`write-ahead log <internals-wal>` and there is no :ref:`replication <replication>`. Note re storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:131
#: ../doc/1.7/book/box/box_schema.rst:149
#: ../doc/1.7/book/box/data_model.rst:463
#: ../doc/1.7/reference/reference_lua/msgpack.rst:196
msgid "false"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:139 ../doc/1.7/book/box/box_space.rst:273
msgid "id"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:139
msgid "unique identifier: users can refer to spaces with the id instead of the name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:139
msgid "last space's id, +1"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:143
msgid "field_count"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:143
msgid "fixed count of :ref:`fields <index-box_tuple>`: for example if field_count=5, it is illegal to insert a tuple with fewer than or more than 5 fields"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:143
msgid "0 i.e. not fixed"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:149 ../doc/1.7/book/box/box_space.rst:277
msgid "if_not_exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:149
msgid "create space only if a space with the same name does not exist already, otherwise do nothing but do not cause an error"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:155
msgid "engine"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:155
msgid "'memtx' or 'vinyl'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:155
#: ../doc/1.7/book/box/box_schema.rst:157
#: ../doc/1.7/book/box/box_schema.rst:380
#: ../doc/1.7/book/box/box_session.rst:102
#: ../doc/1.7/book/box/box_session.rst:121
#: ../doc/1.7/book/box/box_session.rst:129
#: ../doc/1.7/book/box/data_model.rst:157
#: ../doc/1.7/reference/reference_lua/errno.rst:58
#: ../doc/1.7/reference/reference_lua/fiber.rst:284
#: ../doc/1.7/reference/reference_lua/fiber.rst:388
#: ../doc/1.7/reference/reference_lua/fiber.rst:433
#: ../doc/1.7/reference/reference_lua/fio.rst:177
#: ../doc/1.7/reference/reference_lua/fio.rst:199
#: ../doc/1.7/reference/reference_lua/fio.rst:219
#: ../doc/1.7/reference/reference_lua/fio.rst:238
#: ../doc/1.7/reference/reference_lua/json.rst:49
#: ../doc/1.7/reference/reference_lua/msgpack.rst:53
#: ../doc/1.7/reference/reference_lua/pickle.rst:83
#: ../doc/1.7/reference/reference_lua/socket.rst:282
#: ../doc/1.7/reference/reference_lua/socket.rst:313
#: ../doc/1.7/reference/reference_lua/socket.rst:329
#: ../doc/1.7/reference/reference_lua/string.rst:66
#: ../doc/1.7/reference/reference_lua/string.rst:91
#: ../doc/1.7/reference/reference_lua/string.rst:114
#: ../doc/1.7/reference/reference_lua/string.rst:225
#: ../doc/1.7/reference/reference_lua/string.rst:248
#: ../doc/1.7/reference/reference_lua/string.rst:271
#: ../doc/1.7/reference/reference_lua/uri.rst:87
#: ../doc/1.7/reference/reference_lua/yaml.rst:48
msgid "string"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:155
msgid "'memtx'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:157
#: ../doc/1.7/book/box/box_space.rst:1737
#: ../doc/1.7/book/box/box_space.rst:1740
msgid "user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:157
msgid "name of the user who is considered to be the space's :ref:`owner <authentication-owners_privileges>` for authorization purposes"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:157
msgid "current user's name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:162
msgid "format"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:162
msgid "field names and types: See the illustrations of format clauses in the :ref:`space_object:format() <box_space-format>` description and in the :ref:`box.space._space <box_space-space>` example. Optional and usually not specified."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:162
msgid "(blank)"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:170
msgid "There are three :ref:`syntax variations <app_server-object_reference>` for object references targeting space objects, for example :samp:`box.schema.space.drop({space-id})` will drop a space. However, the common approach is to use functions attached to the space objects, for example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:179
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:197
msgid "After a space is created, usually the next step is to :ref:`create an index <box_space-create_index>` for it, and then it is available for insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:206
msgid "Create a user. For explanation of how Tarantool maintains user data, see section :ref:`Users<authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:211
#: ../doc/1.7/book/box/box_schema.rst:303
#: ../doc/1.7/book/box/box_schema.rst:579
#: ../doc/1.7/reference/reference_lua/digest.rst:236
msgid "The possible options are:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:213
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user already exists,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:216
msgid "``password`` (default = '') - string; the ``password`` = *password* specification is good because in a :ref:`URI <index-uri>` (Uniform Resource Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:223
#: ../doc/1.7/book/box/box_space.rst:1827
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:225
msgid "name of user, which should not be a number and should not contain special characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:227
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:231
#: ../doc/1.7/book/box/box_schema.rst:252
#: ../doc/1.7/book/box/box_schema.rst:663
#: ../doc/1.7/book/box/data_model.rst:595
#: ../doc/1.7/reference/reference_lua/net_box.rst:205
#: ../doc/1.7/reference/reference_lua/net_box.rst:272
#: ../doc/1.7/reference/reference_lua/net_box.rst:402
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_schema.rst:233
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:243
msgid "Drop a user. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:248
#: ../doc/1.7/book/box/box_schema.rst:268
msgid "the name of the user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:249
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:254
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:263
msgid "Return ``true`` if a user exists; return ``false`` if a user does not exist. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:269
#: ../doc/1.7/book/box/box_schema.rst:481
#: ../doc/1.7/book/box/box_schema.rst:634
#: ../doc/1.7/reference/reference_lua/uuid.rst:128
msgid "bool"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:273
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:283
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a user or to another role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:286
#: ../doc/1.7/book/box/box_schema.rst:328
msgid "the name of the user."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:287
#: ../doc/1.7/book/box/box_schema.rst:329
#: ../doc/1.7/book/box/box_schema.rst:498
#: ../doc/1.7/book/box/box_schema.rst:531
msgid "'read' or 'write' or 'execute' or 'create' or 'alter' or 'drop' or a combination."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:289
#: ../doc/1.7/book/box/box_schema.rst:331
#: ../doc/1.7/book/box/box_schema.rst:500
#: ../doc/1.7/book/box/box_schema.rst:533
msgid "'space' or 'function' or 'sequence'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:290
msgid "name of object to grant permissions to."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:291
msgid "name of role to grant to user."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:292
msgid "``grantor``, ``if_not_exists``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:294
msgid "If :samp:`'function','{object-name}'` is specified, then a _func tuple with that object-name must exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:297
msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'. In this case, object name is omitted."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:300
#: ../doc/1.7/book/box/box_schema.rst:340
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:305
msgid "``grantor`` = *grantor_name_or_id* -- string or number, for custom grantor,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:306
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user already has the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:311
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:325
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a user or from another role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:332
#: ../doc/1.7/book/box/box_schema.rst:501
#: ../doc/1.7/book/box/box_schema.rst:534
msgid "the name of a function or space or sequence."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:334
msgid "The user must exist, and the object must exist, but it is not an error if the user does not have the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:337
#: ../doc/1.7/book/box/box_schema.rst:508
#: ../doc/1.7/book/box/box_schema.rst:539
msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:345
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:356
msgid "Return a hash of a user's password. For explanation of how Tarantool maintains passwords, see section :ref:`Passwords <authentication-passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:362
msgid "If a non-'guest' user has no password, it’s **impossible** to connect to Tarantool using this user. The user is regarded as “internal” only, not usable from a remote connection. Such users can be useful if they have defined some procedures with the :ref:`SETUID <box_schema-func_create>` option, on which privileges are granted to externally-connectable users. This way, external users cannot create/drop objects, they can only invoke procedures."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:369
msgid "For the 'guest' user, it’s impossible to set a password: that would be misleading, since 'guest' is the default user on a newly-established connection over a :ref:`binary port <admin-security>`, and Tarantool does not require a password to establish a :ref:`binary connection <box_protocol-iproto_protocol>`. It is, however, possible to change the current user to ‘guest’ by providing the :ref:`AUTH packet <box_protocol-authentication>` with no password at all or an empty password. This feature is useful for connection pools, which want to reuse a connection for a different user without re-establishing it."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:379
msgid "password to be hashed"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:384
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:392
msgid "Associate a password with the user who is currently logged in, or with the user specified by user-name. The user must exist and must not be 'guest'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:395
msgid "Users who wish to change their own passwords should use ``box.schema.user.passwd(password)`` syntax."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:398
msgid "Administrators who wish to change passwords of other users should use ``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:401
msgid "user-name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:402
msgid "password"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:406
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:415
msgid "Return a description of a user's :ref:`privileges <authentication-owners_privileges>`. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:420
msgid "the name of the user. This is optional; if it is not supplied, then the information will be for the user who is currently logged in."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:428
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:437
msgid "Create a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:441
msgid "name of role, which should not be a number and should not contain special characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:443
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role already exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:451
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:460
msgid "Drop a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:464
#: ../doc/1.7/book/box/box_schema.rst:480
msgid "the name of the role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:465
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:470
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:478
msgid "Return ``true`` if a role exists; return ``false`` if a role does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:485
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:495
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:497
#: ../doc/1.7/book/box/box_schema.rst:530
#: ../doc/1.7/book/box/box_schema.rst:560
msgid "the name of the role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:502
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role already has the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:506
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:511
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` -- to grant a role to a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:516
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:528
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:536
msgid "The role must exist, and the object must exist, but it is not an error if the role does not have the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:542
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:547
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:558
msgid "Return a description of a role's privileges."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:564
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:572
msgid "Create a function :ref:`tuple <index-box_tuple>`. This does not create the function itself -- that is done with Lua -- but if it is necessary to grant privileges for a function, box.schema.func.create must be done first. For explanation of how Tarantool maintains function data, see reference on :ref:`_func <box_space-func>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:581
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the ``_func`` tuple already exists."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:584
msgid "``setuid`` = ``true|false`` (default = false) - with ``true`` to make Tarantool treat the function’s caller as the function’s creator, with full privileges. Remember that SETUID works only over :ref:`binary ports <admin-security>`. SETUID doesn't work if you invoke a function via an :ref:`admin console <admin-security>` or inside a Lua script."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:591
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:593
msgid "name of function, which should not be a number and should not contain special characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:595
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:601
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:612
msgid "Drop a function tuple. For explanation of how Tarantool maintains function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:616
#: ../doc/1.7/book/box/box_schema.rst:633
msgid "the name of the function"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:617
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the _func tuple does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:622
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:630
msgid "Return true if a function tuple exists; return false if a function tuple does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:638
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:646
msgid "Reload a C module or function without restarting the server."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:648
msgid "Under the hood, Tarantool loads a new copy of the module (``*.so`` shared library) and starts routing all new request to the new version. The previous version remains active until all started calls are finished. All shared libraries are loaded with ``RTLD_LOCAL`` (see \"man 3 dlopen\"), therefore multiple copies can co-exist without any problems."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:656
msgid "When a function from a certain module is reloaded, all the other functions from this module are also reloaded."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:658
msgid "Reload will fail if a module was loaded from Lua script with `ffi.load() <http://luajit.org/ext_ffi_api.html#ffi_load>`_."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:661
msgid "the name of the module or function to reload"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:665
msgid ""
"-- reload a function\n"
"box.schema.func.reload('module.function')\n"
"-- reload the entire module contents\n"
"box.schema.func.reload('module')\n"
"-- reload everything\n"
"box.schema.func.reload()"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:678
#: ../doc/1.7/book/box/data_model.rst:426
msgid "Sequences"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:680
msgid "An introduction to sequences is in the :ref:`Sequences <index-box_sequence>` section of the \"Data model\" chapter. Here are the details for each function and option."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:688
msgid "Create a new sequence generator."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:690
msgid "the name of the sequence"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:692
msgid "see a quick overview in the \"Options for ``box.schema.sequence.create()``\" :ref:`chart <index-box_sequence-options>` (in the :ref:`Sequences <index-box_sequence>` section of the \"Data model\" chapter), and see more details below."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:699
msgid "a reference to a new sequence object."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:701
msgid "Options:"
msgstr "Опции:"

#: ../doc/1.7/book/box/box_schema.rst:703
msgid "``start`` -- the STARTS WITH value. Type = integer, Default = 1."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:705
msgid "``min`` -- the MINIMUM value. Type = integer, Default = 1."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:707
msgid "``max`` - the MAXIMUM value. Type = integer, Default = 9223372036854775807."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:709
msgid "There is a rule: ``min`` <= ``start`` <= ``max``. For example it is illegal to say ``{start=0}`` because then the specified start value (0) would be less than the default min value (1)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:713
msgid "There is a rule: ``min`` <= next-value <= ``max``. For example, if the next generated value would be 1000, but the maximum value is 999, then that would be considered \"overflow\"."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:718
msgid "``cycle`` -- the CYCLE value. Type = bool. Default = false."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:720
msgid "If the sequence generator's next value is an overflow number, it causes an error return -- unless ``cycle == true``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:723
msgid "But if ``cycle == true``, the count is started again, at the MINIMUM value or at the MAXIMUM value (not the STARTS WITH value)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:726
msgid "``cache`` -- the CACHE value. Type = unsigned integer. Default = 0."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:728
msgid "Currently Tarantool ignores this value, it is reserved for future use."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:730
msgid "``step`` -- the INCREMENT BY value. Type = integer. Default = 1."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:732
msgid "Ordinarily this is what is added to the previous value."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:738
msgid "Generate the next value and return it."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:740
msgid "The generation algorithm is simple:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:742
msgid "If this is the first time, then return the STARTS WITH value."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:743
msgid "If the previous value plus the INCREMENT value is less than the MINIMUM value or greater than the MAXIMUM value, that is \"overflow\", so either return an error (if ``cycle`` = ``false``) or return the MAXIMUM value (if ``cycle`` = ``true`` and ``step`` < 0) or return the MINIMUM value (if ``cycle`` = ``true`` and ``step`` > 0)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:749
msgid "If there was no error, then save the returned result, it is now the \"previous value\"."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:752
msgid "For example, suppose sequence 'S' has:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:754
msgid "``min`` == -6,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:755
msgid "``max`` == -1,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:756
msgid "``step`` == -3,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:757
msgid "``start`` = -2,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:758
msgid "``cycle`` = true,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:759
msgid "previous value = -2."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:761
msgid "Then ``box.sequence.S:next()`` returns -5 because -2 + (-3) == -5."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:763
msgid "Then ``box.sequence.S:next()`` again returns -1 because -5 + (-3) < -6, which is overflow, causing cycle, and ``max`` == -1."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:766
msgid "This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:771
msgid "This function should not be used in \"cross-engine\" transactions (transactions which use both the memtx and the vinyl storage engines)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:774
msgid "To see what the previous value was, without changing it, you can select from the :ref:`_sequence_data <box_space-sequence_data>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:782
msgid "The ``alter()`` function can be used to change any of the sequence's options. Requirements and restrictions are the same as for :ref:`box.schema.sequence.create() <box_schema-sequence_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:790
msgid "Set the sequence back to its original state. The effect is that a subsequent ``next()`` will return the ``start`` value. This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:799
msgid "Set the \"previous value\" to ``new-previous-value``. This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:807
msgid "Drop an existing sequence."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:811
msgid "Here is an example showing all sequence options and operations:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:813
msgid ""
"s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=200,\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:834
msgid "You can use the :samp:`sequence={sequence-name}` (or :samp:`sequence={sequence-id}` or :samp:`sequence=true`) option when :ref:`creating <box_space-create_index>` or :ref:`altering <box_index-alter>` a primary-key index. The sequence becomes associated with the index, so that the next ``insert()`` will put the next generated number into the primary-key field, if the field would otherwise be nil."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:842
msgid "For example, if 'Q' is a sequence and 'T' is a new space, then this will work:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:845
msgid ""
"tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:861
msgid "(Notice that the index now has a ``sequence_id`` field.)"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:863
msgid "And this will work:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:865
msgid ""
"tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/box_schema.rst:874
msgid "If you are using negative numbers for the sequence options, make sure that the index key type is 'integer'. Otherwise the index key type may be either 'integer' or 'unsigned'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:878
msgid "A sequence cannot be dropped if it is associated with an index."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:5
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../doc/1.7/book/box/box_session.rst:11
msgid "The ``box.session`` submodule allows querying the session state, writing to a session-specific temporary Lua table, or setting up triggers which will fire when a session starts or ends. A *session* is an object associated with each client connection."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:20
msgid "Below is a list of all ``box.session`` functions and members."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:30
msgid ":ref:`box.session.id() <box_session-id>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:30
msgid "Get the current session's ID"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:33
msgid ":ref:`box.session.exists() <box_session-exists>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:33
msgid "Check if a session exists"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:36
msgid ":ref:`box.session.peer() <box_session-peer>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:36
msgid "Get the session peer's host address and port"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:39
msgid ":ref:`box.session.sync() <box_session-sync>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:39
msgid "Get the sync integer constant"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:42
msgid ":ref:`box.session.user() <box_session-user>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:42
msgid "Get the current user's name"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:45
msgid ":ref:`box.session.type() <box_session-type>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:45
msgid "Get the connection type or cause of action"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:48
msgid ":ref:`box.session.su() <box_session-su>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:48
msgid "Change the current user"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:51
msgid ":ref:`box.session.uid() <box_session-uid>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:51
msgid "Get the current user's ID"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:54
msgid ":ref:`box.session.euid() <box_session-euid>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:54
msgid "Get the current effective user's ID"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:57
msgid ":ref:`box.session.storage <box_session-storage>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:57
msgid "Table with session-specific names and values"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:60
msgid ":ref:`box.session.on_connect() <box_session-on_connect>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:60
msgid "Define a connect trigger"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:63
msgid ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:63
msgid "Define a disconnect trigger"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:66
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:66
msgid "Define an authentication trigger"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:76
msgid "the unique identifier (ID) for the current session. The result can be 0 meaning there is no session."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:84
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:91
msgid "This function works only if there is a peer, that is, if a connection has been made to a separate Tarantool instance."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:94
msgid "The host address and port of the session peer, for example \"127.0.0.1:55457\". If the session exists but there is no connection to a separate instance, the return is null. The command is executed on the server instance, so the \"local name\" is the server instance's host and port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:104
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:110
msgid "the value of the :code:`sync` integer constant used in the `binary protocol <https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:119
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:127
msgid "the type of connection or cause of action."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:131
msgid "Possible return values are:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:133
msgid "'binary' if the connection was done via the binary protocol, for example to a target made with :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:136
msgid "'console' if the connection was done via the administrative console, for example to a target made with :ref:`console.listen <console-listen>`;"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:139
msgid "'repl' if the connection was done directly, for example when :ref:`using Tarantool as a client <admin-using_tarantool_as_a_client>`;"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:141
msgid "'applier' if the action is due to :ref:`replication <replication>`, regardless of how the connection was done;"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:144
msgid "'background' if the action is in a :ref:`background fiber <fiber-module>`, regardless of whether the Tarantool server was :ref:`started in the background <cfg_basic-background>`."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:149
msgid "``box.session.type()`` is useful for an :ref:`on_replace() <box_space-on_replace>` trigger on a replica -- the value will be 'applier' if and only if the trigger was activated because of a request that was done on the master."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:159
msgid "Change Tarantool's :ref:`current user <authentication-users>` -- this is analogous to the Unix command ``su``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:162
msgid "Or, if function-to-execute is specified, change Tarantool's :ref:`current user <authentication-users>` temporarily while executing the function -- this is analogous to the Unix command ``sudo``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:167
msgid "name of a target user"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:168
msgid "name of a function, or definition of a function. Additional parameters may be passed to ``box.session.su``, they will be interpreted as parameters of function-to-execute."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:175
msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:196
msgid "the user ID of the :ref:`current user <authentication-users>`."
msgstr "ID :ref:`текущего пользователя <authentication-users>`."

#: ../doc/1.7/book/box/box_session.rst:200
msgid "Every user has a unique name (seen with :ref:`box.session.user() <box_session-user>`) and a unique ID (seen with ``box.session.uid()``). The values are stored together in the ``_user`` space."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:208
msgid "the effective user ID of the :ref:`current user <authentication-users>`."
msgstr "рабочий ID :ref:`текущего пользователя <authentication-users>`."

#: ../doc/1.7/book/box/box_session.rst:210
msgid "This is the same as :ref:`box.session.uid() <box_session-uid>`, except in two cases:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:213
msgid "The first case: if the call to ``box.session.euid()`` is within a function invoked by :ref:`box.session.su(user-name, function-to-execute) <box_session-su>` -- in that case, ``box.session.euid()`` returns the ID of the changed user (the user who is specified by the ``user-name`` parameter of the ``su`` function)  but ``box.session.uid()`` returns the ID of the original user (the user who is calling the ``su`` function)."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:221
msgid "The second case: if the call to ``box.session.euid()`` is within a function specified with :ref:`box.schema.func.create(function-name, {setuid= true}) <box_schema-func_create>` and the binary protocol is in use -- in that case, ``box.session.euid()`` returns the ID of the user who created \"function-name\" but ``box.session.uid()`` returns the ID of the the user who is calling \"function-name\"."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:233
msgid ""
"tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:256
msgid "A Lua table that can hold arbitrary unordered session-specific names and values, which will last until the session ends. For example, this table could be useful to store current tasks when working with a `Tarantool queue manager <https://github.com/tarantool/queue>`_."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:263
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:292
msgid "Define a trigger for execution when a new session is created due to an event such as :ref:`console.connect <console-connect>`. The trigger function will be the first thing executed after a new session is created. If the trigger execution fails and raises an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:297
#: ../doc/1.7/book/box/box_session.rst:328
#: ../doc/1.7/book/box/box_session.rst:401
#: ../doc/1.7/book/box/box_space.rst:754 ../doc/1.7/book/box/box_space.rst:825
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:298
#: ../doc/1.7/book/box/box_session.rst:329
#: ../doc/1.7/book/box/box_session.rst:402
#: ../doc/1.7/book/box/box_space.rst:756
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:299
#: ../doc/1.7/book/box/box_session.rst:330
#: ../doc/1.7/book/box/box_session.rst:403
#: ../doc/1.7/book/box/box_space.rst:759 ../doc/1.7/book/box/box_space.rst:830
msgid "nil or function pointer"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:301
#: ../doc/1.7/book/box/box_session.rst:332
#: ../doc/1.7/book/box/box_session.rst:405
#: ../doc/1.7/book/box/box_space.rst:761
msgid "If the parameters are (nil, old-trigger-function), then the old trigger is deleted."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:303
#: ../doc/1.7/book/box/box_session.rst:334
#: ../doc/1.7/book/box/box_session.rst:407
#: ../doc/1.7/book/box/box_space.rst:768 ../doc/1.7/book/box/box_space.rst:839
msgid "Details about trigger characteristics are in the :ref:`triggers <triggers-box_triggers>` section."
msgstr "Подробная информация о характеристиках триггера находится в разделе :ref:`Триггеры <triggers-box_triggers>`."

#: ../doc/1.7/book/box/box_session.rst:307
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:316
msgid "If a trigger always results in an error, it may become impossible to connect to a server to reset it."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:323
msgid "Define a trigger for execution after a client has disconnected. If the trigger function causes an error, the error is logged but otherwise is ignored. The trigger is invoked while the session associated with the client still exists and can access session properties, such as :ref:`box.session.id() <box_session-id>`."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:338
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:347
msgid "After the following series of requests, a Tarantool instance will write a message using the :ref:`log <log-module>` module whenever any user connects or disconnects."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:350
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:367
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:369
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:380
msgid "Define a trigger for execution during :ref:`authentication <authentication-users>`."
msgstr "Определяет триггер, используемый во время :ref:`аутентификации <authentication-users>`."

#: ../doc/1.7/book/box/box_session.rst:382
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:384
msgid "The :ref:`console.connect <console-connect>` function includes an authentication check for all users except 'guest'. For this case, the ``on_auth`` trigger function is invoked after the ``on_connect`` trigger function, if and only if the connection has succeeded so far."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:389
msgid "The :ref:`binary protocol <admin-security>` has a separate :ref:`authentication packet <box_protocol-authentication>`. For this case, connection and authentication are considered to be separate steps."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:393
msgid "Unlike other trigger types, ``on_auth`` trigger functions are invoked **before** the event. Therefore a trigger function like :code:`function auth_function () v = box.session.user(); end` will set :code:`v` to \"guest\", the user name before the authentication is done. To get the user name **after** the authentication is done, use the special syntax: :code:`function auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:399
msgid "If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:409
msgid "**Example 1**"
msgstr "**Пример 1**"

#: ../doc/1.7/book/box/box_session.rst:411
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:418
msgid "**Example 2**"
msgstr "**Пример 2**"

#: ../doc/1.7/book/box/box_session.rst:420
msgid "This is a more complex example, with two server instances."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:422
msgid "The first server instance listens on port 3301; its default user name is 'admin'. There are three ``on_auth`` triggers:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:426
msgid "The first trigger has a function with no arguments, it can only look at ``box.session.user()``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:428
msgid "The second trigger has a function with a ``user_name`` argument, it can look at both of: ``box.session.user()`` and ``user_name``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:430
msgid "The third trigger has a function with a ``user_name`` argument and a ``status`` argument, it can look at all three of: ``box.session.user()`` and ``user_name`` and ``status``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:435
msgid "The second server instance will connect with :ref:`console.connect <console-connect>`, and then will cause a display of the variables that were set by the trigger functions."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:440
msgid ""
"-- On the first server instance, which listens on port 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:463
msgid ""
"-- On the second server instance, that connects to port 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:469
msgid "The result looks like this:"
msgstr "Теперь результат выглядит следующим образом:"

#: ../doc/1.7/book/box/box_session.rst:471
msgid ""
"function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:5
msgid "Submodule `box.slab`"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:13
msgid "The ``box.slab`` submodule provides access to slab allocator statistics. The slab allocator is the main allocator used to store :ref:`tuples <index-box_tuple>`. This can be used to monitor the total memory usage and memory fragmentation."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:21
msgid "Below is a list of all ``box.slab`` functions."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:31
msgid ":ref:`box.runtime.info() <box_runtime_info>`"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:31
msgid "Show a memory usage report for Lua runtime"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:34
msgid ":ref:`box.slab.info() <box_slab_info>`"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:34
msgid "Show an aggregated memory usage report for slab allocator"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:37
msgid ":ref:`box.slab.stats() <box_slab_stats>`"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:37
msgid "Show a detailed memory usage report for slab allocator"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:45
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:49
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:50
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:51
msgid "``used`` is the current memory size used by Lua."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:57
msgid ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:74
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:76
msgid "This report is useful for assessing out-of-memory risks: the risks are high if both ``arena_used_ratio`` and ``quota_used_ratio`` are high (90-95%)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:79
msgid "If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or ``items_used_ratio`` indicate that the memory fragmentation is low (i.e. the memory is used efficiently)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:83
msgid "If ``quota_used_ratio`` is high (approaching 100%), then low ``arena_used_ratio`` (50-60%) indicates that the memory is heavily fragmentized. Most probably, there is no immediate out-of-memory risk in this case, but generally this is an issue to consider. For example, probable risks are that the entire memory quota is used for tuples, and there is are no slabs left for a piece of an index. Or that all slabs are allocated for storing tuples, but in fact all the slabs are half-empty."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:93
msgid "``items_size`` is the *total* amount of memory (including allocated, but currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:95
msgid "``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` (these are slabs used only for tuples, no indexes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:97
msgid "``quota_size`` is the maximum amount of memory that the slab allocator can use for both tuples and indexes (as configured in :ref:`memtx_memory <cfg_storage-memtx_memory>` parameter, e.g. the default is 1 gigabyte = 2^30 bytes = 1,073,741,824 bytes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:101
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:102
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:103
msgid "``items_used`` is the *efficient* amount of memory (omitting allocated, but currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:105
msgid "``quota_used`` is the amount of memory that is already distributed to the slab allocator;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:107
msgid "``arena_size`` is the *total* memory used for tuples and indexes together (including allocated, but currently free slabs);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:109
msgid "``arena_used`` is the *efficient* memory used for storing tuples and indexes together (omitting allocated, but currently free slabs)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:116
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:140
msgid "Show a detailed memory usage report (in bytes) for the slab allocator. The report is broken down into groups by *data item size* as well as by *slab size* (64-byte, 136-byte, etc). The report includes the memory allocated for storing both tuples and indexes."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:147
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:148
msgid "``mem_used`` is the memory used for storing data items (tuples and indexes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:149
msgid "``item_count`` is the number of stored items;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:150
msgid "``item_size`` is the size of each data item;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:151
msgid "``slab_count`` is the number of slabs allocated;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:152
msgid "``slab_size`` is the size of each allocated slab."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:158
msgid "Here is a sample report for the first group:"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:160
msgid ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:172
msgid "This report is saying that there are 2 data items (``item_count`` = 2) stored in one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so ``mem_used`` = 2 * 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of which 16384 - 48 = 16232 bytes are free (``mem_free``)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:177
msgid "A complete report would show memory usage statistics for all groups:"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:179
msgid ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:210
msgid "The total ``mem_used`` for all groups in this report equals ``arena_used`` in :ref:`box.slab.info() <box_slab_info>` report."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:5
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../doc/1.7/book/box/box_space.rst:11
msgid "The ``box.space`` submodule has the data-manipulation functions ``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. It also has members, such as id, and whether or not a space is enabled. Submodule source code is available in file `src/box/lua/schema.lua <https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:21
msgid "Below is a list of all ``box.space`` functions and members."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:31
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:31
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:34
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:34
msgid "Get count of bytes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:37
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:37 ../doc/1.7/book/box/box_space.rst:58
msgid "Get count of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:40
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:43
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:43
#: ../doc/1.7/reference/reference_lua/net_box.rst:116
msgid "Delete a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:46
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:46
msgid "Destroy a space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:49
msgid ":ref:`space_object:format() <box_space-format>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:49
msgid "Declare field names and types"
msgstr "Объявить имена и типы полей"

#: ../doc/1.7/book/box/box_space.rst:52
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:52
#: ../doc/1.7/reference/reference_lua/net_box.rst:101
msgid "Select a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:55
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:55
#: ../doc/1.7/reference/reference_lua/net_box.rst:104
msgid "Insert a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:58
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:61
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:61
msgid "Create a replace trigger with a function that cannot change the tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:65
msgid ":ref:`space_object:before_replace() <box_space-before_replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:65
msgid "Create a replace trigger with a function that can change the tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:69
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:72
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:72 ../doc/1.7/book/box/box_space.rst:78
#: ../doc/1.7/reference/reference_lua/net_box.rst:107
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:75
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:75
msgid "Rename a space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:78
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:81
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:81
msgid "Enable/disable a replace trigger"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:84
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:84
#: ../doc/1.7/reference/reference_lua/net_box.rst:98
msgid "Select one or more tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:87
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:87
msgid "Delete all tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:90
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:93
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:96
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:96
msgid "Flag, true if space is enabled"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:99
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:99
msgid "Required number of fields"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:102
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:102
msgid "Numeric identifier of space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:105
msgid ":ref:`space_object.index <box_space-space_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:105
msgid "Container of space's indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:108
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:108
msgid "(Metadata) List of replica sets"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:111
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:111
msgid "(Metadata) List of function tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:114
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:114
msgid "(Metadata) List of indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:117
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:117
msgid "(Metadata) List of privileges"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:120
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:120
msgid "(Metadata) List of schemas"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:123
msgid ":ref:`box.space._sequence <box_space-sequence>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:123 ../doc/1.7/book/box/box_space.rst:126
msgid "(Metadata) List of sequences"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:126
msgid ":ref:`box.space._sequence_data <box_space-sequence_data>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:129
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:129
msgid "(Metadata) List of spaces"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:132
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:132
msgid "(Metadata) List of users"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:144
msgid "Insert a new tuple using an auto-increment primary key. The space specified by space_object must have an :ref:`'unsigned' or 'integer' or 'number' <index-box_indexed-field-types>` primary key index of type ``TREE``. The primary-key field will be incremented before the insert."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:150
msgid "Since version 1.7.5 this method is deprecated – it is better to use a :ref:`sequence <index-box_sequence>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:153 ../doc/1.7/book/box/box_space.rst:186
#: ../doc/1.7/book/box/box_space.rst:216 ../doc/1.7/book/box/box_space.rst:243
#: ../doc/1.7/book/box/box_space.rst:469 ../doc/1.7/book/box/box_space.rst:509
#: ../doc/1.7/book/box/box_space.rst:531 ../doc/1.7/book/box/box_space.rst:644
#: ../doc/1.7/book/box/box_space.rst:695 ../doc/1.7/book/box/box_space.rst:727
#: ../doc/1.7/book/box/box_space.rst:905 ../doc/1.7/book/box/box_space.rst:963
#: ../doc/1.7/book/box/box_space.rst:993 ../doc/1.7/book/box/box_space.rst:1049
#: ../doc/1.7/book/box/box_space.rst:1130
#: ../doc/1.7/book/box/box_space.rst:1191
#: ../doc/1.7/book/box/box_space.rst:1312
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:155
msgid "tuple's fields, other than the primary-key field"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:158 ../doc/1.7/book/box/box_space.rst:997
msgid "the inserted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:161
msgid "**Complexity factors:** Index size, Index type, Number of indexes accessed, :ref:`WAL settings <cfg_binary_logging_snapshots-rows_per_wal>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:166
msgid "index has wrong type;"
msgstr "index has wrong type;"

#: ../doc/1.7/book/box/box_space.rst:167
msgid "primary-key indexed field is not a number."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:171
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:189
msgid "Number of bytes in the space. This number, which is stored in Tarantool's internal memory, represents the total number of bytes in all tuples, not including index keys. For a measure of index size, see :ref:`index_object:bsize() <box_index-bsize>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:197
msgid ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr ""
"tarantool> box.space.tester:bsize()\n"
"        ---\n"
"        - 22\n"
"        ..."

#: ../doc/1.7/book/box/box_space.rst:204
msgid "**Note re storage engine:** vinyl does not support ``bsize()``."
msgstr "**Примечание про движок базы данных:** vinyl не поддерживает ``bsize()``."

#: ../doc/1.7/book/box/box_space.rst:211
msgid "Return the number of tuples. If compared with :ref:`len() <box_space-len>`, this method works slower because ``count()`` scans the entire space to count the tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:218 ../doc/1.7/book/box/box_space.rst:471
#: ../doc/1.7/book/box/box_space.rst:1193
msgid "primary-key field values, must be passed as a Lua table if key is multi-part"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:222
msgid "Number of tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:226
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:237
msgid "Create an :ref:`index <index-box_index>`. It is mandatory to create an index for a space before trying to insert tuples into it, or select tuples from it. The first created index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:245
msgid "name of index, which should not be a number and should not contain special characters"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:247
msgid "see \"Options for space_object:create_index()\" below"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:250
msgid "index object"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:251
msgid "index_object"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:255
msgid "**Options for space_object:create_index()**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:267
msgid "type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:267
msgid "type of index"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:267
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: vinyl only supports 'TREE'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:267
msgid "'TREE'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:273
msgid "unique identifier"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:273
msgid "last index's id, +1"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:275
msgid "unique"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:275
msgid "index is unique"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:275
msgid "``true``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:277
msgid "no error if duplicate name"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:277
msgid "``false``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279
msgid "parts"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279
msgid "field-numbers  + types"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279
msgid "{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'boolean' or 'array' or 'scalar', and optional collation, and optional is_nullable value}"
msgstr "{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'boolean' or 'array' or 'scalar', and optional collation, and optional is_nullable value}"

#: ../doc/1.7/book/box/box_space.rst:279
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:286
msgid "dimension"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:286
msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:286 ../doc/1.7/book/box/box_space.rst:1745
msgid "2"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:288
msgid "distance"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:288
msgid "affects RTREE only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:288
msgid "string ('euclid' or 'manhattan')"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:288
msgid "'euclid'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:291
msgid "bloom_fpr"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:291 ../doc/1.7/book/box/box_space.rst:293
#: ../doc/1.7/book/box/box_space.rst:295 ../doc/1.7/book/box/box_space.rst:297
#: ../doc/1.7/book/box/box_space.rst:299
msgid "affects vinyl only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:291
msgid "``vinyl_bloom_fpr``"
msgstr "``vinyl_bloom_fpr``"

#: ../doc/1.7/book/box/box_space.rst:293
msgid "page_size"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:293
msgid "``vinyl_page_size``"
msgstr "``vinyl_page_size``"

#: ../doc/1.7/book/box/box_space.rst:295
msgid "range_size"
msgstr "range_size"

#: ../doc/1.7/book/box/box_space.rst:295
msgid "``vinyl_range_size``"
msgstr "``vinyl_range_size``"

#: ../doc/1.7/book/box/box_space.rst:297
msgid "run_count_per_level"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:297
msgid "``vinyl_run_count_per_level``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:299
msgid "run_size_ratio"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:299
msgid "``vinyl_run_size_ratio``"
msgstr "``vinyl_run_size_ratio``"

#: ../doc/1.7/book/box/box_space.rst:301
msgid "sequence"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:301
msgid "see section regarding :ref:`specifying a sequence in create_index() <box_schema-sequence_create_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:301
msgid "string or number"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:301
msgid "not present"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:306
msgid "The options in the above chart are also applicable for :ref:`index_object:alter() <box_index-alter>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:308
msgid "**Note re storage engine:** vinyl has extra options which by default are based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, :ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, :ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`, and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- see the description of those parameters. The current values can be seen by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:321
msgid "too many parts;"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:322
msgid "index '...' already exists;"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:323
msgid "primary key must be unique."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:325
msgid ""
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', 2, 'string'}})\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.space.tester\n"
"        ---\n"
"        ...\n"
"        tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', 2, 'string'}})\n"
"        ---\n"
"        ..."

#: ../doc/1.7/book/box/box_space.rst:336
msgid "**Details about index field types:**"
msgstr "**Подробнее о типах полей индекса:**"

#: ../doc/1.7/book/box/box_space.rst:338
msgid "The seven index field types (unsigned | string | integer | number | boolean | array | scalar) differ depending on what values are allowed, and what index types are allowed."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:342
msgid "**unsigned**: unsigned integers between 0 and 18446744073709551615, about 18 quintillion. May also be called 'uint' or 'num', but 'num' is deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:346
msgid "**string**: any set of octets, up to the :ref:`maximum length <limitations_bytes_in_index_key>`. May also be called 'str'. Legal in memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. A string may have a :ref:`collation <index-collation>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:350
msgid "**integer**: integers between -9223372036854775808 and 18446744073709551615. May also be called 'int'. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:353
msgid "**number**: integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, or double-precision floating point numbers. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:357
msgid "**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr "**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."

#: ../doc/1.7/book/box/box_space.rst:359
msgid "**array**: array of numbers. Legal in memtx :ref:`RTREE <box_index-rtree>` indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:360
msgid "**scalar**: booleans (true or false), or integers between -9223372036854775808 and 18446744073709551615, or single-precision floating point numbers, or double-precison floating-point numbers, or strings. When there is a mix of types, the key order is: booleans, then numbers, then strings. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:367
msgid "Additionally, `nil` is allowed with any index field type if :ref:`is_nullable=true <box_space-is_nullable>` is specified."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:372
msgid "**Index field types to use in space_object:create_index()**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:383
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../doc/1.7/book/box/box_space.rst:383
msgid "What can be in it"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:383
msgid "Where is it legal"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:383 ../doc/1.7/book/box/data_model.rst:269
#: ../doc/1.7/book/box/data_model.rst:451
#: ../doc/1.7/reference/reference_lua/socket.rst:581
msgid "Examples"
msgstr "Примеры"

#: ../doc/1.7/book/box/box_space.rst:385
msgid "**unsigned**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:385
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:385 ../doc/1.7/book/box/box_space.rst:392
#: ../doc/1.7/book/box/box_space.rst:396 ../doc/1.7/book/box/box_space.rst:404
#: ../doc/1.7/book/box/box_space.rst:411
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:385
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../doc/1.7/book/box/box_space.rst:389
msgid "**string**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:389
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:389
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:389
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:392
msgid "**integer**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:392
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:392
msgid "-2^63 |br|"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:396 ../doc/1.7/book/box/data_model.rst:282
msgid "**number**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:396
msgid "integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:396
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:404 ../doc/1.7/book/box/data_model.rst:296
msgid "**boolean**"
msgstr "**boolean**"

#: ../doc/1.7/book/box/box_space.rst:404
#: ../doc/1.7/reference/reference_lua/socket.rst:343
#: ../doc/1.7/reference/reference_lua/string.rst:140
#: ../doc/1.7/reference/reference_lua/string.rst:170
msgid "true or false"
msgstr "true  / false"

#: ../doc/1.7/book/box/box_space.rst:404
msgid "false |br| true"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:407 ../doc/1.7/book/box/data_model.rst:299
msgid "**array**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:407
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:407
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:407
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:411 ../doc/1.7/book/box/data_model.rst:304
msgid "**scalar**"
msgstr "**scalar**"

#: ../doc/1.7/book/box/box_space.rst:411
msgid "booleans (true or false), integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, double-precision floating point numbers, strings"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:411
msgid "true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:423
msgid "**Allowing null for an indexed key:** If the index type is TREE, and the index is not the primary index, then the ``parts={...}`` clause may include ``is_nullable=true`` or ``is_nullable=false`` (the default). If ``is_nullable`` is true, then it is legal to insert ``nil`` or an equivalent such as ``msgpack.NULL``. Within indexes, such \"null values\" are always treated as equal to other null values, and are always treated as less than non-null values. Nulls may appear multiple times even in a unique index. Example:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:431
msgid "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:437
msgid "**Using field names instead of field numbers:** ``create_index()`` can use field names and/or field types described by the optional :ref:`space_object:format() <box_space-format>` clause. In the following example, we show ``format()`` for a space that has two columns named 'x' and 'y', and then we show five variations of the ``parts={}`` clause of ``create_index()``, first for the 'x' column, second for both the 'x' and 'y' columns. The variations include omitting the type, using numbers, and adding extra braces."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:446
msgid ""
"box.space.tester:format({{name='x', type='scalar'}, {name='y', type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:460
msgid "**Note re storage engine:** vinyl supports only the TREE index type, and vinyl secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:467
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:474
msgid "the deleted tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:477
msgid "**Complexity factors:** Index size, Index type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:479
msgid "**Note re storage engine:** vinyl will return ``nil``, rather than the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:484
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:499 ../doc/1.7/book/box/box_space.rst:714
#: ../doc/1.7/book/box/box_space.rst:1013
#: ../doc/1.7/book/box/box_space.rst:1120
#: ../doc/1.7/book/box/box_space.rst:1292
#: ../doc/1.7/book/box/box_space.rst:1340
msgid "For more usage scenarios and typical errors see :ref:`Example: using data operations <box_space-operations-detailed-examples>` further in this section."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:507
msgid "Drop a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:514 ../doc/1.7/book/box/box_space.rst:652
#: ../doc/1.7/book/box/box_space.rst:969
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr "**Возможные ошибки:** ``space_object`` does not exist."

#: ../doc/1.7/book/box/box_space.rst:516 ../doc/1.7/book/box/box_space.rst:654
#: ../doc/1.7/book/box/box_space.rst:1004
msgid "**Complexity factors:** Index size, Index type, Number of indexes accessed, WAL settings."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:521
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:529
msgid "Declare field names and :ref:`types <index-box_data-types>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:533
msgid "a list of field names and types"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:535
msgid "nil, unless format-clause is omitted"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:539
msgid "``space_object`` does not exist;"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:540
msgid "field names are duplicated,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:541
msgid "type is not legal."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:543
msgid "Ordinarily Tarantool allows unnamed untyped fields. But with ``format`` users can, for example, document that the Nth field is the surname field and must contain strings. It is also possible to specify a format clause in :ref:`box.schema.space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:549
msgid "The format clause contains ``{name='...',type='...'}`` pairs. The name may be any string, provided that two fields do not have the same name."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:553
msgid "The type can be one of those allowed for :ref:`indexed fields <index-box_indexed-field-types>`: unsigned | string | integer | number | boolean | array-of-numbers | scalar (the same as the requirement in :ref:`\"Options for space_object:create_index\" <box_space-create_index-options>`). Additionally the type can one of those not allowed for indexed field types: any | array-of-any-kind | map."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:561
msgid "It is legal for tuples to have more fields than are described by a format clause. The way to constrain the number of fields is to specify a space's :ref:`field_count <box_space-field_count>` member."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:565
msgid "It is legal to use ``format`` on a space that already has a format, thus replacing any previous definitions, provided that there is no conflict with existing data or index definitions."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:571
msgid "box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:575
msgid "There are legal variations of the format clause:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:577
msgid "omitting both 'name=' and 'type=',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:578
msgid "omitting 'type=' alone, and"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:579
msgid "adding extra braces."
msgstr "добавление дополнительных фигурных скобок."

#: ../doc/1.7/book/box/box_space.rst:581
msgid "The following examples show all the variations, first for one field named 'x', second for two fields named 'x' and 'y'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:584
msgid ""
"box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:597
msgid "The following example shows how to create a space, format it with all possible types, and insert into it."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:600
msgid ""
"tarantool> box.schema.space.create('t')\n"
"--- ...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                     {name='2',type='unsigned'},\n"
"         >                     {name='3',type='string'},\n"
"         >                     {name='4',type='number'},\n"
"         >                     {name='5',type='integer'},\n"
"         >                     {name='6',type='boolean'},\n"
"         >                     {name='7',type='scalar'},\n"
"         >                     {name='8',type='array'},\n"
"         >                     {name='9',type='map'}})\n"
"--- ...\n"
"tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"--- ...\n"
"tarantool> box.space.t:insert{{'a'},      -- any\n"
"         >                    1,          -- unsigned\n"
"         >                    'W?',       -- string\n"
"         >                    5.5,        -- number\n"
"         >                    -0,         -- integer\n"
"         >                    true,       -- boolean\n"
"         >                    true,       -- scalar\n"
"         >                    {{'a'}},    -- array\n"
"         >                    {val=1}}    -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"..."
msgstr ""
"tarantool> box.schema.space.create('t')\n"
"       --- ...\n"
"       tarantool> box.space.t:format({{name='1',type='any'},\n"
"                >                     {name='2',type='unsigned'},\n"
"                >                     {name='3',type='string'},\n"
"                >                     {name='4',type='number'},\n"
"                >                     {name='5',type='integer'},\n"
"                >                     {name='6',type='boolean'},\n"
"                >                     {name='7',type='scalar'},\n"
"                >                     {name='8',type='array'},\n"
"                >                     {name='9',type='map'}})\n"
"       --- ...\n"
"       tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"       --- ...\n"
"       tarantool> box.space.t:insert{{'a'},      -- any\n"
"                >                    1,          -- unsigned\n"
"                >                    'W?',       -- string\n"
"                >                    5.5,        -- number\n"
"                >                    -0,         -- integer\n"
"                >                    true,       -- boolean\n"
"                >                    true,       -- scalar\n"
"                >                    {{'a'}},    -- array\n"
"                >                    {val=1}}    -- map\n"
"       ---\n"
"       - [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"       ..."

#: ../doc/1.7/book/box/box_space.rst:629
msgid "Names specified with the format clause can be used in :ref:`space_object:get() <box_space-get>` and in :ref:`space_object:create_index() <box_space-create_index>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:633
msgid "If the format clause is omitted, then the returned value is the table that was used in a previous :samp:`{space_object}:format({format-clause})` invocation. For example, after ``box.space.tester:format({{'x','scalar'}})``, ``box.space.tester:format()`` will return [{'name': 'x', 'type': 'scalar'}]."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:642
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:646 ../doc/1.7/book/box/box_space.rst:1051
msgid "value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:649
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:657
msgid "The ``box.space...select`` function returns a set of tuples as a Lua table; the ``box.space...get`` function returns at most a single tuple. And it is possible to get the first tuple in a space by appending ``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:665
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:669
msgid "**Using field names instead of field numbers:** `get()` can use field names described by the optional :ref:`space_object:format() <box_space-format>` clause. This is similar to a standard Lua feature, where a component can be referenced by its name instead of its number. For example, we can format the `tester` space with a field named `x` and use the name `x` in the index definition:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:676
msgid ""
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:681
msgid "Then, if ``get`` or ``select`` retrieve a single tuple, we can reference the field 'x' in the tuple by its name:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:684
msgid ""
"box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:693
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:697
msgid "tuple to be inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:699
msgid "the inserted tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:702
msgid "**Possible errors:** If a tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`."
msgstr "**Возможные ошибки:** If a tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`."

#: ../doc/1.7/book/box/box_space.rst:707
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"        ---\n"
"        - [5000, 'tuple number five thousand']\n"
"        ..."

#: ../doc/1.7/book/box/box_space.rst:722
msgid "Return the number of tuples in the space. If compared with :ref:`count() <box_space-count>`, this method works faster because ``len()`` does not scan the entire space to count the tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:730
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:734
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:741
msgid "**Note re storage engine:** vinyl does not support ``len()``. Possible workarounds are to use :ref:`count() <box_space-count>` or ``#select(...)``."
msgstr "**Примечание про движок базы данных:** vinyl не поддерживает ``len()``. Possible workarounds are to use :ref:`count() <box_space-count>` or ``#select(...)``."

#: ../doc/1.7/book/box/box_space.rst:749 ../doc/1.7/book/box/box_space.rst:820
msgid "Create a \"replace :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:764 ../doc/1.7/book/box/box_space.rst:835
msgid "If it is necessary to know whether the trigger activation happened due to replication or on a specific connection type, the function can refer to :ref:`box.session.type() <box_session-type>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:770
msgid "See also :ref:`space_object:before_replace() <box_space-before_replace>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:772 ../doc/1.7/book/box/box_space.rst:1632
msgid "**Example #1:**"
msgstr "**Пример №1:**"

#: ../doc/1.7/book/box/box_space.rst:774
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:781
msgid "The ``trigger-function`` can have two parameters: old tuple, new tuple. For example, the following code causes nil to be printed when the insert request is processed, and causes [1, 'Hi'] to be printed when the delete request is processed:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:786
msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new) print(old) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:795 ../doc/1.7/book/box/box_space.rst:1677
msgid "**Example #2:**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_space.rst:797
msgid "The following series of requests will create a space, create an index, create a function which increments a counter, create a trigger, do two inserts, drop the space, and display the counter value - which is 2, because the function is executed once after each insert."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:802
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:827
msgid "existing trigger function which will be replaced by ``trigger-function``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:832
msgid "If the parameters are ``(nil, old-trigger-function)``, then the old trigger is deleted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:842
msgid "See also :ref:`space_object:on_replace() <box_space-on_replace>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:844
msgid "Administrators can make replace triggers with ``on_replace()``, or make triggers with ``before_replace()``. If they make both types, then all ``before_replace`` triggers are executed before all ``on_replace`` triggers. The functions for both ``on_replace`` and ``before_replace`` triggers can make changes to the database, but only the functions for ``before_replace`` triggers can change the tuple that is being replaced."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:853
msgid "Since a ``before_replace`` trigger function has the extra capability of making a change to the old tuple, it also can have extra overhead, to fetch the old tuple before making the change. Therefore an ``on_replace`` trigger is better if there is no need to change the old tuple. However, this only applies for the memtx engine -- for the vinyl engine, the fetch will happen for either kind of trigger. (With memtx the tuple data is stored along with the index key so no extra search is necessary; with vinyl that is not the case so the extra search is necessary.)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:865
msgid "Where the extra capability is not needed, ``on_replace`` should be used instead of ``before_replace``. Usually ``before_replace`` is used only for certain replication scenarios -- it is useful for conflict resolution."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:870
msgid "The value that a ``before_replace`` trigger function can return affects what will happen after the return. Specifically:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:873
msgid "if there is no return value, then execution proceeds, inserting|replacing the new value;"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:875
msgid "if the value is nil, then the tuple will be deleted;"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:876
msgid "if the value is the same as the old parameter, then no `on_replace`` function will be called and the data change will be skipped"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:879
msgid "if the value is the same as the new parameter, then it's as if the ``before_replace`` function wasn't called;"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:881
msgid "if the value is something else, then execution proceeds, inserting|replacing the new value."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:886
msgid "The following are ``before_replace`` functions that have no return value, or that return nil, or the same as the old parameter, or the same as the new parameter, or something else."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:890
msgid ""
"function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:902
msgid "Search for a tuple or a set of tuples in the given space, and allow iterating over one tuple at a time."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:909
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:918 ../doc/1.7/book/box/box_space.rst:1063
msgid "no such space;"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:919 ../doc/1.7/book/box/box_space.rst:1064
msgid "wrong type."
msgstr "Общий тип"

#: ../doc/1.7/book/box/box_space.rst:923
msgid "For examples of complex ``pairs`` requests, where one can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\"), see the later section :ref:`index_object:pairs <box_index-index_pairs>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:930
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:961
msgid "Rename a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:965
msgid "new name for space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:973
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:987
msgid "Insert a tuple into a space. If a tuple with the same primary key already exists, ``box.space...:replace()`` replaces the existing tuple with a new one. The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have the same effect; the latter is sometimes used to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:995
msgid "tuple to be inserted"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1000
msgid "**Possible errors:** If a different tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen if there is a unique secondary index.)"
msgstr "**Возможные ошибки:** If a different tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen  if there is a unique secondary index.)"

#: ../doc/1.7/book/box/box_space.rst:1009
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1021
msgid "At the time that a :ref:`trigger <triggers>` is defined, it is automatically enabled - that is, it will be executed. :ref:`Replace <box_space-on_replace>` triggers can be disabled with :samp:`box.space.{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1030
msgid "The following series of requests will associate an existing function named `F` with an existing space named `T`, associate the function a second time with the same space (so it will be called twice), disable all triggers of `T`, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1035
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1047
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1054
msgid "the tuples whose primary-key fields are equal to the fields of the passed key. If the number of passed fields is less than the number of fields in the primary key, then only the passed fields are compared, so ``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1070
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, 'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1115
msgid "For examples of complex ``select`` requests, where one can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\") and how many tuples to return, see the later section :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1128
msgid "Deletes all tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1137
msgid "The ``truncate`` method can only be called by the user who created the space, or from within a ``setuid`` function created by the user who created the space. Read more about ``setuid`` functions in the reference for :ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1143
msgid "The ``truncate`` method cannot be called from within a transaction."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1147
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1163
msgid "The ``update`` function supports operations on fields — assignment, arithmetic (if the field is numeric), cutting and pasting fragments of a field, deleting or inserting a field. Multiple operations can be combined in a single update request, and in this case they are performed atomically and sequentially. Each operation requires specification of a field number. When multiple operations are present, the field number for each operation is assumed to be relative to the most recent state of the tuple, that is, as if all previous operations in a multi-operation update have already been applied. In other words, it is always safe to merge multiple ``update`` invocations into a single invocation, with no change in semantics."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1175
msgid "Possible operators are:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1177
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1178
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1179
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1180
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1181
msgid "``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1183
msgid "``:`` for string splice"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1184
msgid "``!`` for insertion"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1185
msgid "``#`` for deletion"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1186
msgid "``=`` for assignment"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1188
msgid "For ``!`` and ``=`` operations the field number can be ``-1``, meaning the last field in the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1205
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr "**Возможные ошибки:** it is illegal to modify a primary-key field."

#: ../doc/1.7/book/box/box_space.rst:1207
#: ../doc/1.7/book/box/box_space.rst:1331
msgid "**Complexity factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1210
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1212
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1216
msgid "the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning *add a value to a field and then assign a value to a field*, the first affected field is field ``1`` and the value which will be added to it is ``55``, the second affected field is field ``3`` and the value which will be assigned to it is ``'x'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1224
msgid "Assume that initially there is a space named ``tester`` with a primary-key index whose type is ``unsigned``. There is one tuple, with ``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1228
msgid "In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br| The first argument is ``tester``, that is, the affected space is ``tester``. The second argument is ``999``, that is, the affected tuple is identified by primary key value = 999. The third argument is ``=``, that is, there is one operation — *assignment to a field*. The fourth argument is ``2``, that is, the affected field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1239
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` |br| the arguments are the same, except that the key is passed as a Lua table (inside braces). This is unnecessary when the primary key has only one field, but would be necessary if the primary key had more than one field. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1246
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br| the arguments are the same, except that the fourth argument is ``3``, that is, the affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1253
msgid "In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br| the arguments are the same, except that the third argument is ``'+'``, that is, the operation is addition rather than assignment. Since ``field[3]`` previously contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1261
msgid "In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, 'C'}})`` |br| the idea is to modify two fields at once. The formats are ``'|'`` and ``=``, that is, there are two operations, OR and assignment. The fourth and fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1270
msgid "In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` from ``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` becomes ``field[2]`` before we subtract ``3`` from it, and that's why the seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1278
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` |br| we're making a long string so that splice will work in the next example. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1283
msgid "In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})`` |br| The third argument is ``':'``, that is, this is the example of splice. The fourth argument is ``2`` because the change will occur in ``field[2]``. The fifth argument is 2 because deletion will begin with the second byte. The sixth argument is 1 because the number of bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1300
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1302
msgid "If there is an existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :ref:`space_object:update() <box_space-update>` and the ``{{operator, field_no, value}, ...}`` parameter is used. If there is no existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :ref:`space_object:insert() <box_space-insert>` and the ``{tuple_value}`` parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` will not read a tuple and perform error checks before returning -- this is a design feature which enhances throughput but requires more caution on the part of the user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1314
msgid "default tuple to be inserted, if analogue isn't found"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1323
#: ../doc/1.7/reference/reference_lua/fio.rst:651
msgid "null"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1327
msgid "It is illegal to modify a primary-key field."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1328
msgid "It is illegal to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1336
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1348
msgid "Whether or not this space is enabled. The value is ``false`` if the space has no index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1355
msgid "The required field count for all tuples in this space. The field_count can be set initially with:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1395
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1367
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1371
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1382
msgid "Ordinal space number. Spaces can be referenced by either name or number. Thus, if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1389
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1400
msgid "A container for all defined indexes. There is a Lua object of type :ref:`box.index <box_index>` with methods to search tuples and iterate over them in predefined order."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1408
msgid ""
"# checking the number of indexes for space 'tester'\n"
"tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"# checking the type of index 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1425
msgid "``_cluster`` is a system space for support of the :ref:`replication feature <replication>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1432
msgid "``_func`` is a system space with function tuples made by :ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1435
#: ../doc/1.7/book/box/box_space.rst:1488
#: ../doc/1.7/book/box/box_space.rst:1526
#: ../doc/1.7/book/box/box_space.rst:1621
#: ../doc/1.7/book/box/box_space.rst:1716
msgid "Tuples in this space contain the following fields:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1437
msgid "the numeric function id, a number,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1438
msgid "the function name,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1439
msgid "flag,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1440
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1442
msgid "The ``_func`` space does not include the function’s body. You continue to create Lua functions in the usual way, by saying ``function function_name () ... end``, without adding anything in the ``_func`` space. The ``_func`` space only exists for storing function tuples so that their names can be used within :ref:`grant/revoke <authentication-owners_privileges>` functions."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1450
#: ../doc/1.7/book/box/box_space.rst:1536
msgid "You can:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1452
msgid "Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-func_create>`,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1454
msgid "Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-func_drop>`,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1456
msgid "Check whether a ``_func`` tuple exists with :ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1461
msgid "In the following example, we create a function named ‘f7’, put it into Tarantool's ``_func`` space and grant 'execute' privilege for this function to 'guest' user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1465
msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1486
msgid "``_index`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1490
msgid "``id`` (= id of space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1491
msgid "``iid`` (= index number within space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1492
msgid "``name``,"
msgstr "``name``,"

#: ../doc/1.7/book/box/box_space.rst:1493
msgid "``type``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1494
msgid "``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` ...]."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1496
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1498
msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, 'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, 'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, 'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, 'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1523
msgid "``_priv`` is a system space where :ref:`privileges <authentication-owners_privileges>` are stored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1528
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1529
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1530
msgid "the type of object: 'space', 'function', 'sequence' or 'universe',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1531
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1532
msgid "the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, \"create\" = 32, \"drop\" = 64, \"alter\" = 128, or a combination such as \"read,write,execute\"."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1538
msgid "Grant a privilege with :ref:`box.schema.user.grant() <box_schema-user_grant>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1539
msgid "Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-user_revoke>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1543
msgid "Generally, privileges are granted or revoked by the owner of the object (the user who created it), or by the 'admin' user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1546
msgid "Before dropping any objects or users, make sure that all their associated privileges have been revoked."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1549
msgid "Only the :ref:`'admin' user <authentication-owners_privileges>` can grant privileges for the 'universe'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1552
msgid "Only the 'admin' user or the creator of a space can drop, alter, or truncate the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1555
msgid "Only the 'admin' user or the creator of a user can change a different user’s password."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1562
msgid "``_schema`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1564
msgid "This space contains the following tuples:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1566
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1567
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1568
msgid "``max_id`` tuple with the maximal space ID,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1569
msgid "``once...`` tuples that correspond to specific :ref:`box.once() <box-once>` blocks from the instance's :ref:`initialization file <index-init_label>`. The first field in these tuples contains the ``key`` value from the corresponding ``box.once()`` block prefixed with 'once' (e.g. `oncehello`), so you can easily find a tuple that corresponds to a specific ``box.once()`` block."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1579
msgid "Here is what ``_schema`` contains in a typical installation (notice the tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1582
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1596
msgid "``_sequence`` is a system space for support of the :ref:`sequence feature <index-box_sequence>`. It contains persistent information that was established by :ref:`box.schema.sequence.create() <box_schema-sequence_create>` or :ref:`box.schema.sequence.alter() <box_schema-sequence_alter>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1606
msgid "``_sequence_data`` is a system space for support of the :ref:`sequence feature <index-box_sequence>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1609
msgid "Each tuple in ``_sequence_data`` contains two fields:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1611
msgid "the id of the sequence, and"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1612
msgid "the last value that the sequence generator returned (non-persistent information)."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1619
msgid "``_space`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1623
msgid "``id``,"
msgstr "``id``,"

#: ../doc/1.7/book/box/box_space.rst:1624
msgid "``owner`` (= id of user who owns the space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1625
msgid "``name``, ``engine``, ``field_count``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1626
msgid "``flags`` (e.g. temporary),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1627
msgid "``format`` (as made by a :ref:`format clause <box_space-format>`)."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1629
msgid "These fields are established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1634
msgid "The following function will display all simple fields in all tuples of ``_space``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1637
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1656
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1658
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1679
msgid "The following requests will create a space using ``box.schema.space.create()`` with a :ref:`format clause <box_space-format>`, then retrieve the ``_space`` tuple for the new space. This illustrates the typical use of the ``format`` clause, it shows the recommended names and data types for the fields."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1685
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': 'unsigned'}]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1714
msgid "``_user`` is a system space where user-names and password hashes are stored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1718
msgid "the numeric id of the tuple (\"id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1719
msgid "the numeric id of the tuple’s creator,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1720
msgid "the name,"
msgstr "имя,"

#: ../doc/1.7/book/box/box_space.rst:1721
msgid "the type: 'user' or 'role',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1722
msgid "optional password."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1724
msgid "There are five special tuples in the ``_user`` space: 'guest', 'admin', 'public', 'replication', and 'super'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1735
msgid "ID"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1737
msgid "guest"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1737
#: ../doc/1.7/book/box/data_model.rst:466
msgid "0"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1737
msgid "Default user when connecting remotely. Usually an untrusted user with few privileges."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1740
msgid "admin"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1740
#: ../doc/1.7/book/box/data_model.rst:453
#: ../doc/1.7/book/box/data_model.rst:457
#: ../doc/1.7/book/box/data_model.rst:469
msgid "1"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1740
msgid "Default user when using Tarantool as a console. Usually an :ref:`administrative user <authentication-owners_privileges>` with all privileges."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1745
msgid "public"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1745
#: ../doc/1.7/book/box/box_space.rst:1753
#: ../doc/1.7/book/box/box_space.rst:1757
msgid "role"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1745
msgid "Pre-defined :ref:`role <authentication-roles>`, automatically granted to new users when they are created with ``box.schema.user.create(user-name)``. Therefore a convenient way to grant 'read' on space 't' to every user that will ever exist is with ``box.schema.role.grant('public','read','space','t')``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1753
msgid "replication"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1753
msgid "3"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1753
msgid "Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user can grant to users who need to use :ref:`replication <replication>` features."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1757
msgid "super"
msgstr "super (суперпользователь)"

#: ../doc/1.7/book/box/box_space.rst:1757
msgid "31"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1757
msgid "Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user can grant to users who need all privileges on all objects. The 'super' role has these privileges on 'universe': read, write, execute, create, drop, alter."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1765
msgid "To select a tuple from the ``_user`` space, use ``box.space._user:select()``. For example, here is what happens with a select for user id = 0, which is the 'guest' user, which by default has no password:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1769
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1778
msgid "To change tuples in the ``_user`` space, do not use ordinary ``box.space`` functions for insert or update or delete. The ``_user`` space is special, so there are special functions which have appropriate error checking."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1782
msgid "To create a new user, use :ref:`box.schema.user.create() <box_schema-user_create>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1821
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1791
msgid "To change the user's password, use :ref:`box.schema.user.password() <box_schema-user_password>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1830
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1803
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1842
msgid "box.schema.user.drop(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1810
msgid "To check whether a user exists, use :ref:`box.schema.user.exists() <box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1850
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1818
msgid "To find what privileges a user has, use :ref:`box.schema.user.info() <box_schema-user_info>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1857
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1831
msgid "Here is a session which creates a new user with a strong password, selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1834
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1849
msgid "Example: using box.space functions to read _space tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1851
msgid "This function will illustrate how to look at all the spaces, and for each display: approximately how many tuples it contains, and the first field of its first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and ``pairs()``. The iteration through the spaces is coded as a scan of the ``_space`` system space, which contains metadata. The third field in ``_space`` contains the space name, so the key instruction ``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in the tuple of ``_space`` that we've just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1861
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1885
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1887
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1907
msgid "Example: using box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1909
msgid "The objective is to display field names and field types of a system space -- using metadata to find metadata."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1912
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1914
msgid "A simple way is to look at the constants in box.schema, which tell us that there is an item named SPACE_ID == 288, so these statements will retrieve the correct tuple:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1918
msgid "``box.space._space:select{ 288 }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1919
#: ../doc/1.7/dev_guide/lua_style_guide.rst:375
msgid "or"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1920
msgid "``box.space._space:select{ box.schema.SPACE_ID }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1922
msgid "Another way is to look at the tuples in box.space._index, which tell us that there is a secondary index named 'name' for space number 288, so this statement also will retrieve the correct tuple:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1926
msgid "``box.space._space.index.name:select{ '_space' }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1928
msgid "However, the retrieved tuple is not easy to read:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1930
msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, {'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': 'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': 'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1940
msgid "It looks disorganized because field number 7 has been formatted with recommended names and data types. How can one get those specific sub-fields? Since it's visible that field number 7 is an array of maps, this `for` loop will do the organizing:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1945
msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1967
msgid "Example: using data operations"
msgstr "Пример: использование операций с данными"

#: ../doc/1.7/book/box/box_space.rst:1969
msgid "This example demonstrates all legal scenarios -- as well as typical errors -- for each :ref:`data operation <index-box_data-operations>` in Tarantool: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE <box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE <box_space-operations-replace>`, and :ref:`SELECT <box_space-operations-select>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1978
msgid ""
"-- Bootstrap the database --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Create a primary index --\n"
"pk = s:create_index('pk', {parts = {{'field1'}}})\n"
"-- Create a unique secondary index --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{'field2'}}})\n"
"-- Create a non-unique secondary index --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{'field3'}}, unique = false})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1998
msgid "INSERT"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2000
msgid "``insert`` accepts a well-formatted tuple and checks all keys for duplicates."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2002
msgid ""
"tarantool> -- Unique indexes: ok --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Conflicting primary key: error --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Conflicting unique secondary key: error --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Key {1} exists in sk_non_uniq index, but it is not unique: ok --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2032
msgid "DELETE"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2034
msgid "``delete`` accepts a full key of any unique index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2036
msgid "``space:delete`` is an alias for \"delete by primary key\"."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2038
msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a primary key: ok --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly delete by a primary key: ok --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a unique secondary key: ok --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a non-unique secondary index: error --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2111
msgid "The key must be full: ``delete`` cannot work with partial keys."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2113
msgid ""
"tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{1, 'unsigned'}, {2, 'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Delete by a partial key: error --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Delete by a full key: ok --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2147
msgid "UPDATE"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2149
msgid "Similarly to ``delete``, ``update`` accepts a full key of any unique index, and also the operations to execute."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2152
msgid "``space:update`` is an alias for \"update by primary key\"."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2154
msgid ""
"tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a primary key: ok --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly update by a primary key: ok --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a unique secondary key: ok --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a non-unique secondary key: error --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2240
msgid "UPSERT"
msgstr "UPSERT"

#: ../doc/1.7/book/box/box_space.rst:2242
msgid "``upsert`` accepts a well-formatted tuple and update operations."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2244
msgid "If an old tuple is found by the primary key of the specified tuple, then the update operations are applied to the old tuple, and the new tuple is ignored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2248
msgid "If no old tuple is found, then the new tuple is inserted, and the update operations are **ignored**."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2251
msgid "Indexes have no ``upsert`` method - this is a method of a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2253
msgid ""
"tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- As the first argument, upsert accepts --\n"
"tarantool> -- a well-formatted tuple, NOT a key! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2287
msgid "``upsert`` turns into ``insert`` when no old tuple is found by the primary key."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2289
msgid ""
"tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- As you can see, {1, 2, 3} were inserted, --\n"
"tarantool> -- and the update operations were not applied. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Performing another upsert with the same primary key, --\n"
"tarantool> -- but different values in the other fields. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- The old tuple was found by the primary key {1} --\n"
"tarantool> -- and update operations were applied. --\n"
"tarantool> -- The new tuple was ignored. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2313
msgid "``upsert`` searches for an old tuple by the primary index, NOT by a secondary index. This can lead to a duplication error if the new tuple ruins the uniqueness of a secondary index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2317
msgid ""
"tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- But this works, when uniqueness is preserved. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2344
msgid "REPLACE"
msgstr "REPLACE"

#: ../doc/1.7/book/box/box_space.rst:2346
msgid "``replace`` accepts a well-formatted tuple and searches for an old tuple by the primary key of the new tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2349
msgid "If the old tuple is found, then it is deleted, and the new tuple is inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2351
msgid "If the old tuple was not found, then just the new tuple is inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2353
msgid ""
"tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2375
msgid "``replace`` can ruin unique constraints, like ``upsert`` does."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2377
msgid ""
"tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- This replace fails, because if the new tuple {1, 2, 0} replaces --\n"
"tarantool> -- the old tuple by the primary key from 'pk' index {1, 1, 1}, --\n"
"tarantool> -- this results in a duplicate unique secondary key in 'sk_uniq' index: --\n"
"tarantool> -- key {2} is used both in the new tuple and in {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2403
msgid "SELECT"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2405
msgid "``select`` works with any indexes (primary/secondary) and with any keys (unique/non-unique, full/partial)."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2408
msgid "If a key is partial, then ``select`` searches by all keys, where the prefix matches the specified key part."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:2411
msgid ""
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_stat.rst:5
msgid "Submodule `box.stat`"
msgstr ""

#: ../doc/1.7/book/box/box_stat.rst:7
msgid "The ``box.stat`` submodule provides access to request and network statistics. Show the average number of requests per second, and the total number of requests since startup, broken down by request type. Or, show network activity statistics."
msgstr ""

#: ../doc/1.7/book/box/box_stat.rst:12
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: &0 []\n"
"- *0\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:5
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../doc/1.7/book/box/box_tuple.rst:13
msgid "The ``box.tuple`` submodule provides read-only access for the ``tuple`` userdata type. It allows, for a single :ref:`tuple <index-box_tuple>`: selective retrieval of the field contents, retrieval of information about size, iteration over all the fields, and conversion to a `Lua table <https://www.lua.org/pil/2.5.html>`_."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:22
msgid "Below is a list of all ``box.tuple`` functions."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:32
msgid ":ref:`box.tuple.new() <box_tuple-new>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:32
msgid "Create a tuple"
msgstr "Создание кортежа"

#: ../doc/1.7/book/box/box_tuple.rst:35
msgid ":ref:`#tuple_object <box_tuple-count_fields>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:35
msgid "Count tuple fields"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:38
msgid ":ref:`tuple_object:bsize() <box_tuple-bsize>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:38
msgid "Get count of bytes in a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:41
msgid ":ref:`tuple_object[field-number] <box_tuple-field_number>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:41
msgid "Get a tuple's specific field"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:44
msgid ":ref:`tuple_object:find() <box_tuple-find>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:44
msgid "Get the number of the first field matching the search value"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:47
msgid ":ref:`tuple_object:findall() <box_tuple-find>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:47
msgid "Get the number of all fields matching the search value"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:50
msgid ":ref:`tuple_object:transform() <box_tuple-transform>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:50
msgid "Remove (and replace) a tuple's fields"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:53
msgid ":ref:`tuple_object:unpack() <box_tuple-unpack>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:53
msgid "Get a tuple's fields"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:56
msgid ":ref:`tuple_object:totable() <box_tuple-totable>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:56
msgid "Get a tuple's fields as a table"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:59
msgid ":ref:`tuple_object:tomap() <box_tuple-tomap>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:59
msgid "Get a tuple's fields as a table along with key:value pairs"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:62
msgid ":ref:`tuple_object:pairs() <box_tuple-pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:65
msgid ":ref:`tuple_object:update() <box_tuple-update>`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:73
msgid "Construct a new tuple from either a scalar or a Lua table. Alternatively, one can get new tuples from tarantool's :ref:`select <box_space-select>` or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :ref:`update <box_space-update>` requests, which can be regarded as statements that do ``new()`` implicitly."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:80
msgid "the value that will become the tuple contents."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:82
msgid "a new tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:85
msgid "In the following example, ``x`` will be a new table object containing one tuple and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple ``t``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:91
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:114
msgid "The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:119
msgid "In the following example, a tuple named ``t`` is created and then the number of fields in ``t`` is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:122
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:136
msgid "If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in the tuple. With both the memtx storage engine and the vinyl storage engine the default maximum is one megabyte (:ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`). Every field has one or more \"length\" bytes preceding the actual contents, so ``bsize()`` returns a value which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:148
msgid "In the following example, a tuple named ``t`` is created which has three fields, and for each field it takes one byte to store the length and three bytes to store the contents, and a bit for overhead, so ``bsize()`` returns ``3*(1+3)+1``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:153
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:167
msgid "If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:170
msgid "field value."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:171
msgid "lua-value"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:173
msgid "In the following example, a tuple named ``t`` is created and then the second field in ``t`` is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:176
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:191
msgid "If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of the first field in ``t`` that matches the search value, and ``t:findall(search-value [, search-value ...])`` will return numbers of all fields in ``t`` that match the search value. Optionally one can put a numeric argument ``field-number`` before the search-value to indicate “start searching at field number ``field-number``.”"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:198
msgid "the number of the field in the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:201
msgid "In the following example, a tuple named ``t`` is created and then: the number of the first field in ``t`` which matches 'a' is returned, then the numbers of all the fields in ``t`` which match 'a' are returned, then the numbers of all the fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:207
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:230
msgid "If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-remove})` will return a tuple where, starting from field ``start-field-number``, a number of fields (``fields-to-remove``) are removed. Optionally one can add more arguments after ``fields-to-remove`` to indicate new values that will replace what was removed."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:236
msgid "base 1, may be negative"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:242
msgid "In the following example, a tuple named ``t`` is created and then, starting from the second field, two fields are removed but one new one is added, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:246
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:260
msgid "If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:unpack(1)`` will return all fields starting with field number 1, ``t:unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:264
msgid "field(s) from the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:265
msgid "lua-value(s)"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:267
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:270
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:288
msgid "If ``t`` is a tuple instance, ``t:totable()`` will return all fields, ``t:totable(1)`` will return all fields starting with field number 1, ``t:totable(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:292
msgid "It is preferable to use ``t:totable()`` rather than ``t:unpack()``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:294
msgid "field(s) from the tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:295 ../doc/1.7/book/box/box_tuple.rst:333
msgid "lua-table"
msgstr "lua-table"

#: ../doc/1.7/book/box/box_tuple.rst:297
msgid "In the following example, a tuple named ``t`` is created, then all its fields are selected, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:300
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:314
msgid "A `Lua table <https://www.lua.org/pil/2.5.html>`_ can have indexed values, also called key:value pairs. For example, here:"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:318
msgid "a = {}; a['field1'] = 10; a['field2'] = 20"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:322
msgid "``a`` is a table with \"field1: 10\" and \"field2: 20\"."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:324
msgid "The :ref:`tuple_object:totable() <box_tuple-totable>` function only returns a table containing the values. But the ``tuple_object:tomap()`` function returns a table containing not only the values, but also the key:value pairs."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:329
msgid "This only works if the tuple comes from a space that has been formatted with a :ref:`format clause <box_space-format>`."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:332
msgid "field(s) and key:value pair(s) from the tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:335
msgid "In the following example, a tuple named ``t1`` is returned from a space that has been formatted, then a table named ``t1map`` is produced from ``t1``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:339
msgid ""
"format = {{'field1', 'unsigned'}, {'field2', 'unsigned'}}\n"
"s = box.schema.space.create('test', {format = format})\n"
"s:create_index('pk',{parts={1,'unsigned',2,'unsigned'}})\n"
"t1 = s:insert{10, 20}\n"
"t1map = t1:tomap()"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:347
msgid "``t1map`` will contain \"field1: 10\" and \"field2: 20\"."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:353
msgid "In Lua, `lua-table-value:pairs() <https://www.lua.org/pil/7.3.html>`_ is a method which returns: ``function``, ``lua-table-value``, ``nil``. Tarantool has extended this so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is useful for Lua iterators, because Lua iterators traverse a value's components until an end marker is reached."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:359
msgid "function, tuple-value, nil"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:360
msgid "function, lua-value, nil"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:362
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected using a Lua for-end loop."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:365
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:389
msgid "This function updates a tuple which is not in a space. Compare the function :extsamp:`box.space.{*{space-name}*}:update({*{key}*}, {{{*{format}*}, {*{field_no}*}, {*{value}*}}, ...})` which updates a tuple in a space."
msgstr "Эта функция обновляет кортеж, который находится не в спейсе. Ср. функцию :extsamp:`box.spac{*{space-name}e}*}:updat{*{key}y}*}{{{*{format}t}*}{*{field_no}o}*}{*{value}e}*}}, ...})`, которая обновляет кортеж в спейсе."

#: ../doc/1.7/book/box/box_tuple.rst:393
msgid "For details: see the description for ``operator``, ``field_no``, and ``value`` in the section :ref:`box.space.space-name:update{key, format, {field_number, value}...) <box_space-update>`."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:397
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:405
msgid "new tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:408
msgid "In the following example, a tuple named ``t`` is created and then its second field is updated to equal 'B'."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:411
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:423
#: ../doc/1.7/reference/configuration/index.rst:91
#: ../doc/1.7/reference/reference_lua/digest.rst:368
#: ../doc/1.7/reference/reference_lua/fiber.rst:556
#: ../doc/1.7/reference/reference_lua/fiber.rst:752
#: ../doc/1.7/reference/reference_lua/fiber.rst:881
#: ../doc/1.7/reference/reference_lua/log.rst:112
#: ../doc/1.7/reference/reference_lua/msgpack.rst:99
#: ../doc/1.7/reference/reference_lua/net_box.rst:451
#: ../doc/1.7/reference/reference_lua/tap.rst:322
#: ../doc/1.7/reference/reference_lua/uuid.rst:132
#: ../doc/1.7/reference/reference_lua/yaml.rst:68
#: ../doc/1.7/reference/reference_rock/dbms.rst:249
#: ../doc/1.7/reference/reference_rock/dbms.rst:590
msgid "Example"
msgstr "Пример"

#: ../doc/1.7/book/box/box_tuple.rst:425
msgid "This function will illustrate how to convert tuples to/from Lua tables and lists of scalars:"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:428
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"lua_table = tuple:totable()                             -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:436
msgid "Then it will find the field that contains 'b', remove that field from the tuple, and display how many bytes remain in the tuple. The function uses Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, ``bsize()``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:441
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:457
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:5
msgid "Functions for transaction management"
msgstr "Управление экземплярами"

#: ../doc/1.7/book/box/box_txn_management.rst:11
msgid "For general information and examples, see section :ref:`Transaction control <atomic-atomic_execution>`."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:14
msgid "Observe the following rules when working with transactions:"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:16
msgid "Rule #1"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:19
msgid "The requests in a transaction must be sent to a server as a single block. It is not enough to enclose them between begin and commit or rollback. To ensure they are sent as a single block: put them in a function, or put them all on one line, or use a delimiter so that multi-line requests are handled together."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:25
msgid "Rule #2"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:28
msgid "All database operations in a transaction should use the same storage engine. It is not safe to access tuple sets that are defined with ``{engine='vinyl'}`` and also access tuple sets that are defined with ``{engine='memtx'}``, in the same transaction."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:33
msgid "Rule #3"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:36
msgid "Requests which cause changes to the data definition -- create, alter, drop, truncate -- must not be used."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:43
msgid "Below is a list of all functions for transaction management."
msgstr "Ниже приведен перечень всех функций для управления транзакциями."

#: ../doc/1.7/book/box/box_txn_management.rst:53
msgid ":ref:`box.begin() <box-begin>`"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:53
msgid "Begin the transaction"
msgstr "Начало транзакции."

#: ../doc/1.7/book/box/box_txn_management.rst:56
msgid ":ref:`box.commit() <box-commit>`"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:56
msgid "End the transaction and save all changes"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:59
msgid ":ref:`box.rollback() <box-rollback>`"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:59
msgid "End the transaction and discard all changes"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:62
msgid ":ref:`box.savepoint() <box-savepoint>`"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:62
msgid "Get a savepoint descriptor"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:65
msgid ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:65
msgid "Do not end the transaction and discard all changes made after a savepoint"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:69
msgid ":ref:`box.atomic() <box-atomic>`"
msgstr ":ref:`box.atomic() <box-atomic>`"

#: ../doc/1.7/book/box/box_txn_management.rst:69
msgid "Execute a function, treating it as a transaction"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:77
msgid "Begin the transaction. Disable :ref:`implicit yields <atomic-implicit-yields>` until the transaction ends. Signal that writes to the :ref:`write-ahead log <internals-wal>` will be deferred until the transaction ends. In effect the fiber which executes ``box.begin()`` is starting an \"active multi-request transaction\", blocking all other fibers."
msgstr "Начните транзакцию. Отключите :ref:`неявную передачу данных <atomic-implicit- yields>` до окончания транзакции. Сигнал о записи в :ref :`журнал упреждающей записи <internals-wal>` будет задержан до окончания транзакции. Фактически файбер, который выполняет функцию ``box.begin()``, начинает \"активную транзакцию со множеством запросов\" с блокировкой всех остальных файберов."

#: ../doc/1.7/book/box/box_txn_management.rst:88
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:94
msgid "End the transaction, but cancel all its data-change operations. An explicit call to functions outside ``box.space`` that always yield, such as :ref:`fiber.sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-yield>`, will have the same effect."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:103
msgid "Return a descriptor of a savepoint (type = table), which can be used later by :ref:`box.rollback_to_savepoint(savepoint) <box-rollback_to_savepoint>`. Savepoints can only be created while a transaction is active, and they are destroyed when a transaction ends."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:112
msgid "Do not end the transaction, but cancel all its data-change and :ref:`box.savepoint() <box-savepoint>` operations that were done after the specified savepoint."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:118
msgid ""
"function f()\n"
"  box.begin()           -- start transaction\n"
"  box.space.t:insert{1} -- this will not be rolled back\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- this will be rolled back\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- end transaction\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:133
msgid "Execute a function, acting as if the function starts with an implicit :ref:`box.begin() <box-begin>` and ends with an implicit :ref:`box.commit() <box-commit>` if successful, or ends with an implicit :ref:`box.rollback() <box-rollback>` if there is an error."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:5
msgid "Data model"
msgstr "Модель данных"

#: ../doc/1.7/book/box/data_model.rst:7
msgid "This section describes how Tarantool stores values and what operations with data it supports."
msgstr "В этом разделе описывается то, как в Tarantool'е организовано хранение данных и какие операции с данным он поддерживает."

#: ../doc/1.7/book/box/data_model.rst:10
msgid "If you tried to create a database as suggested in our :ref:`\"Getting started\" exercises <getting_started>`, then your test database now looks like this:"
msgstr "Если вы пробовали создать базу данных, как предлагается в упражнениях в :ref:`\"Руководстве для начинающих\" <getting_started>`, то ваша тестовая база данных выглядит следующим образом:"

#: ../doc/1.7/book/box/data_model.rst:20
msgid "Space"
msgstr "Спейс"

#: ../doc/1.7/book/box/data_model.rst:22
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr "*Спейс* — с именем 'tester' в нашем примере — это контейнер."

#: ../doc/1.7/book/box/data_model.rst:24
msgid "When Tarantool is being used to store data, there is always at least one space. Each space has a unique **name** specified by the user. Besides, each space has a unique **numeric identifier** which can be specified by the user, but usually is assigned automatically by Tarantool. Finally, a space always has an **engine**: *memtx* (default) -- in-memory engine, fast but limited in size, or *vinyl* -- on-disk engine for huge data sets."
msgstr "Когда Tarantool используется для хранения данных, всегда существует хотя бы один спейс. У каждого спейса есть уникальное **имя**, указанное пользователем. Кроме того, пользователь может указать уникальный **числовой идентификатор**, но обычно Tarantool назначает его автоматически. Наконец, в спейсе всегда есть **движок**: *memtx* (по умолчанию) — in-memory движок, быстрый, но ограниченный в размере, или *vinyl* — дисковый движок для огромного количества данных."

#: ../doc/1.7/book/box/data_model.rst:31
msgid "A space is a container for :ref:`tuples <index-box_tuple>`. To be functional, it needs to have a :ref:`primary index <index-box_index>`. It can also have secondary indexes."
msgstr "Спейс — это контейнер для :ref:`кортежей <index-box_tuple>`. Для работы ему необходим :ref:`первичный индекс <index-box_index>`. Также возможно использование вторичных индексов."

#: ../doc/1.7/book/box/data_model.rst:39
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:18
msgid "Tuple"
msgstr "Кортеж"

#: ../doc/1.7/book/box/data_model.rst:41
msgid "A **tuple** plays the same role as a “row” or a “record”, and the components of a tuple (which we call “fields”) play the same role as a “row column” or “record field”, except that:"
msgstr "**Кортеж** играет такую же роль, как “строка” или “запись”, а компоненты кортежа (которые мы называем “полями”) играют такую же роль, что и “столбец” или “поле записи”, не считая того, что:"

#: ../doc/1.7/book/box/data_model.rst:45
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr "поля могут представлять собой композитные структуры, такие как таблицы типа массива или ассоциативного массива, а также"

#: ../doc/1.7/book/box/data_model.rst:46
msgid "fields don't need to have names."
msgstr "полям не нужны имена."

#: ../doc/1.7/book/box/data_model.rst:48
msgid "Any given tuple may have any number of fields, and the fields may be of different :ref:`types <index-box_data-types>`. The identifier of a field is the field's number, base 1 (in Lua and other 1-based languages) or base 0 (in PHP or C/C++). For example, “1” or \"0\" can be used in some contexts to refer to the first field of a tuple."
msgstr "В любом кортеже может быть любое количество полей, и это могут быть поля разных :ref:`типов <index-box_data-types>`. Идентификатором поля является его номер, начиная с 1 (в Lua и других языках с индексацией с 1) или с 0 (в PHP или C/C++). Например, “1” или \"0\" могут использоваться в некоторых контекстах для обозначения первого поля кортежа."

#: ../doc/1.7/book/box/data_model.rst:55
msgid "Tuples in Tarantool are stored as `MsgPack <https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr "Кортежи в Tarantool'е хранятся в виде массивов `MsgPack <https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/1.7/book/box/data_model.rst:58
msgid "When Tarantool returns a tuple value in console, it uses the `YAML <https://en.wikipedia.org/wiki/YAML>`_ format, for example: ``[3, 'Ace of Base', 1993]``."
msgstr "Когда Tarantool выводит значение в кортеже в консоль, используется формат `YAML <https://ru.wikipedia.org/wiki/YAML>`_, например: ``[3, 'Ace of  Base', 1993]``."

#: ../doc/1.7/book/box/data_model.rst:68
msgid "An **index** is a group of key values and pointers."
msgstr "**Индекс** — это совокупность значений ключей и указателей."

#: ../doc/1.7/book/box/data_model.rst:70
msgid "As with spaces, you should specify the index **name**, and let Tarantool come up with a unique **numeric identifier** (\"index id\")."
msgstr "Как и для спейсов, индексам следует указать **имена**, а Tarantool определит уникальный **числовой идентификатор** (\"ID индекса\")."

#: ../doc/1.7/book/box/data_model.rst:73
msgid "An index always has a **type**. The default index type is 'TREE'. TREE indexes are provided by all Tarantool engines, can index unique and non-unique values, support partial key searches, comparisons and ordered results. Additionally, memtx engine supports HASH, RTREE and BITSET indexes."
msgstr "У индекса всегда есть определенный **тип**. Тип индекса по умолчанию — 'TREE'. Все движки Tarantool'а предоставляют TREE-индексы, которые могут индексировать уникальные и неуникальные значения, поддерживают поиск по компонентам ключа, сравнение ключей и упорядоченные результаты. Кроме того, движок memtx поддерживает следующие индексы: HASH, RTREE и BITSET."

#: ../doc/1.7/book/box/data_model.rst:78
msgid "An index may be **multi-part**, that is, you can declare that an index key value is composed of two or more fields in the tuple, in any order. For example, for an ordinary TREE index, the maximum number of parts is 255."
msgstr "Индекс может быть **многокомпонентным**, то есть можно объявить, что ключ индекса состоит из двух или более полей в кортеже в любом порядке. Например, для обычного TREE-индекса максимальное количество частей равно 255."

#: ../doc/1.7/book/box/data_model.rst:82
msgid "An index may be **unique**, that is, you can declare that it would be illegal to have the same key value twice."
msgstr "Индекс может быть **уникальным**, то есть можно объявить, что недопустимо дважды задавать одно значение ключа."

#: ../doc/1.7/book/box/data_model.rst:85
msgid "The first index defined on a space is called the **primary key index**, and it must be unique. All other indexes are called **secondary indexes**, and they may be non-unique."
msgstr "Первый индекс, определенный для спейса, называется **первичный индекс**. Он должен быть уникальным. Все остальные индексы называются **вторичными индексами**, они могут строиться по неуникальным значениям."

#: ../doc/1.7/book/box/data_model.rst:89
msgid "An index definition may include identifiers of tuple fields and their expected **types** (see allowed :ref:`indexed field types <index-box_indexed-field-types>` below)."
msgstr "Индекс может содержать идентификаторы полей кортежа и их предполагаемые **типы** (см. допустимые :ref:`типы индексированных полей <index-box_indexed-field-types>` ниже)."

#: ../doc/1.7/book/box/data_model.rst:93
msgid "In our example, we first defined the primary index (named 'primary') based on field #1 of each tuple:"
msgstr "В нашем примере для начала определяем первичный индекс (под названием 'primary') по полю №1 каждого кортежа:"

#: ../doc/1.7/book/box/data_model.rst:96
msgid "tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})"
msgstr "tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})"

#: ../doc/1.7/book/box/data_model.rst:100
msgid "The effect is that, for all tuples in space 'tester', field #1 must exist and must contain an unsigned integer. The index type is 'hash', so values in field #1 must be unique, because keys in HASH indexes are unique."
msgstr "Смысл в том, что поле №1 должно существовать и содержать целое число без знака для всех кортежей в спейсе 'tester'. Тип индекса — 'hash', поэтому значения в поле №1 должны быть уникальными, поскольку ключи в HASH-индексах уникальны."

#: ../doc/1.7/book/box/data_model.rst:105
msgid "After that, we defined a secondary index (named 'secondary') based on field #2 of each tuple:"
msgstr "После этого мы определим вторичный индекс (под названием 'secondary') по полю №2 каждого кортежа:"

#: ../doc/1.7/book/box/data_model.rst:108
msgid "tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, 'string'}})"
msgstr "tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, 'string'}})"

#: ../doc/1.7/book/box/data_model.rst:112
msgid "The effect is that, for all tuples in space 'tester', field #2 must exist and must contain a string. The index type is 'tree', so values in field #2 must not be unique, because keys in TREE indexes may be non-unique."
msgstr "Смысл в том, что поле №2 должно существовать и содержать строку для всех кортежей в спейсе 'tester'. Тип индекса — 'tree', поэтому значения в поле №2 не должны быть уникальными, поскольку ключи в TREE-индексах могут не быть уникальными."

#: ../doc/1.7/book/box/data_model.rst:119
msgid "Space definitions and index definitions are stored permanently in Tarantool's system spaces :ref:`_space <box_space-space>` and :ref:`_index <box_space-index>` (for details, see reference on :ref:`box.space <box_space>` submodule)."
msgstr "Определения спейса и определения индексов хранятся в системных спейсах Tarantool'а :ref:`_space <box_space-space>` и :ref:`_index <box_space-index>` соответственно (для получения подробной информации см. справочник по вложенному модулю :ref:`box.space <box_space>`)."

#: ../doc/1.7/book/box/data_model.rst:123
msgid "You can add, drop, or alter the definitions at runtime, with some restrictions. See syntax details in reference on :ref:`box <box-module>` module."
msgstr "Можно добавлять, опускать или изменять определения во время исполнения кода с некоторыми ограничениями. Более подробно о синтаксисе см. в справочнике по модулю :ref:`box <box-module>`."

#: ../doc/1.7/book/box/data_model.rst:130
msgid "Data types"
msgstr "Типы данных"

#: ../doc/1.7/book/box/data_model.rst:132
msgid "Tarantool is both a database and an application server. Hence a developer often deals with two type sets: the programming language types (e.g. Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr "Tarantool представляет собой базу данных и сервер приложений одновременно. Следовательно, разработчик часто работает с двумя наборами типов: типы языка программирования (например, Lua) и типы формата хранилища Tarantool (MsgPack)."

#: ../doc/1.7/book/box/data_model.rst:141
msgid "Lua vs MsgPack"
msgstr "Lua в сравнении с MsgPack"

#: ../doc/1.7/book/box/data_model.rst:151
msgid "Scalar / compound"
msgstr "Скалярный / составной"

#: ../doc/1.7/book/box/data_model.rst:151
msgid "MsgPack |nbsp| type"
msgstr "MsgPack-тип |nbsp|"

#: ../doc/1.7/book/box/data_model.rst:151
msgid "Lua type"
msgstr "Lua-тип"

#: ../doc/1.7/book/box/data_model.rst:151
msgid "Example value"
msgstr "Пример значения"

#: ../doc/1.7/book/box/data_model.rst:153
#: ../doc/1.7/book/box/data_model.rst:155
#: ../doc/1.7/book/box/data_model.rst:157
#: ../doc/1.7/book/box/data_model.rst:159
#: ../doc/1.7/book/box/data_model.rst:161
msgid "scalar"
msgstr "скалярный"

#: ../doc/1.7/book/box/data_model.rst:153
msgid "\"`nil`_\""
msgstr "\"`nil`_\" (нулевое значение)"

#: ../doc/1.7/book/box/data_model.rst:153
#: ../doc/1.7/reference/reference_lua/msgpack.rst:208
msgid "msgpack.NULL"
msgstr "msgpack.NULL"

#: ../doc/1.7/book/box/data_model.rst:155
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\" (логическое значение)"

#: ../doc/1.7/book/box/data_model.rst:155
#: ../doc/1.7/book/box/data_model.rst:296
#: ../doc/1.7/book/box/data_model.rst:304
#: ../doc/1.7/reference/reference_lua/msgpack.rst:198
msgid "true"
msgstr "true"

#: ../doc/1.7/book/box/data_model.rst:157
msgid "\"`string`_\""
msgstr "\"`string`_\" (строка)"

#: ../doc/1.7/book/box/data_model.rst:157
msgid "'A B C'"
msgstr "'A B C'"

#: ../doc/1.7/book/box/data_model.rst:159
#: ../doc/1.7/reference/reference_lua/errno.rst:45
msgid "integer"
msgstr "integer (целое число)"

#: ../doc/1.7/book/box/data_model.rst:159
#: ../doc/1.7/book/box/data_model.rst:161
msgid "\"`number`_\""
msgstr "\"`number`_\" (число)"

#: ../doc/1.7/book/box/data_model.rst:159
msgid "12345"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:161
msgid "double"
msgstr "double (числа с двойной точностью)"

#: ../doc/1.7/book/box/data_model.rst:161
msgid "1.2345"
msgstr "1,2345"

#: ../doc/1.7/book/box/data_model.rst:163
#: ../doc/1.7/book/box/data_model.rst:165
#: ../doc/1.7/book/box/data_model.rst:167
msgid "compound"
msgstr "compound"

#: ../doc/1.7/book/box/data_model.rst:163
msgid "map"
msgstr "map (ассоциативный массив)"

#: ../doc/1.7/book/box/data_model.rst:163
msgid "\"`table`_\" (with string keys)"
msgstr "\"`table`_\" (таблица со строковыми ключами)"

#: ../doc/1.7/book/box/data_model.rst:163
msgid "{'a': 5, 'b': 6}"
msgstr "{'a': 5, 'b': 6}"

#: ../doc/1.7/book/box/data_model.rst:165
#: ../doc/1.7/book/box/data_model.rst:167
msgid "array"
msgstr "array (массив)"

#: ../doc/1.7/book/box/data_model.rst:165
msgid "\"`table`_\" (with integer keys)"
msgstr "\"`table`_\" (таблица с целочисленными ключами)"

#: ../doc/1.7/book/box/data_model.rst:165
msgid "[1, 2, 3, 4, 5]"
msgstr "[1, 2, 3, 4, 5]"

#: ../doc/1.7/book/box/data_model.rst:167
msgid "tuple (\"`cdata`_\")"
msgstr "tuple (\"`cdata`_\") (кортеж)"

#: ../doc/1.7/book/box/data_model.rst:167
msgid "[12345, 'A B C']"
msgstr "[12345, 'A B C']"

#: ../doc/1.7/book/box/data_model.rst:177
msgid "In Lua, a **nil** type has only one possible value, also called *nil* (displayed as **null** on Tarantool's command line, since the output is in the YAML format). Nils may be compared to values of any types with == (is-equal) or ~= (is-not-equal), but other operations will not work. Nils may not be used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr "В языке Lua тип *nil* (нулевой) может иметь только одно значение, также называемое *nil* (отображаемое как **null** в командной строке Tarantool'а, поскольку значения выводятся в формате YAML). Нулевое значение можно сравнивать со значениями любых типов с помощью операторов == (равен) или ~= (не равен), но никакие другие операции для нулевых значений не доступны. Нулевые значения также нельзя использовать в Lua-таблицах; вместо нулевого значения в таком случае можно указать :ref:`msgpack.NULL <msgpack-null>`"

#: ../doc/1.7/book/box/data_model.rst:185
msgid "A **boolean** is either ``true`` or ``false``."
msgstr "Тип *boolean* (логический) может иметь только значения ``true`` или ``false``."

#: ../doc/1.7/book/box/data_model.rst:189
msgid "A **string** is a variable-length sequence of bytes, usually represented with alphanumeric characters inside single quotes. In both Lua and MsgPack, strings are treated as binary data, with no attempts to determine a string's character set or to perform any string conversion -- unless there is an optional :ref:`collation <index-collation>`. So, usually, string sorting and comparison are done byte-by-byte, without any special collation rules applied. (Example: numbers are ordered by their point on the number line, so 2345 is greater than 500; meanwhile, strings are ordered by the encoding of the first byte, then the encoding of the second byte, and so on, so '2345' is less than '500'.)"
msgstr "Тип **string**  (строка) представляет собой последовательность байтов переменной длины, обычно представленную буквенно-цифровые символы в одинарных кавычках. Как в Lua, так и в MsgPack строки рассматриваются как бинарные данные без попыток определить набор символов строки или выполнить преобразование строки — кроме случаев, когда есть опциональное :ref:`сравнение символов <index-collation>`. Таким образом, обычно сортировка и сравнение строк выполняются побайтово, не применяя дополнительных правил сравнения символов. (Пример: числа упорядочены по их положению на числовой прямой, поэтому 2345 больше, чем 500; а строки упорядочены по кодировке первого байта, затем кодировке второго байта и так далее, таким образом, '2345' меньше, чем '500'.)"

#: ../doc/1.7/book/box/data_model.rst:202
msgid "In Lua, a **number** is double-precision floating-point, but Tarantool allows both integer and floating-point values. Tarantool will try to store a Lua number as floating-point if the value contains a decimal point or is very large (greater than 100 trillion = 1e14), otherwise Tarantool will store it as an integer. To ensure that even very large numbers are stored as integers, use the :ref:`tonumber64 <other-tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned Long Long) suffix. Here are examples of numbers using regular notation, exponential notation, the ULL suffix and the ``tonumber64`` function: ``-55``, ``-2.7e+20``, ``100000000000000ULL``, ``tonumber64('18446744073709551615')``."
msgstr "В языке Lua тип **number** (число) — это число с плавающей запятой двойной точности, но в Tarantool'е можно использовать как целые числа, так и числа с плавающей запятой. Tarantool по возможности сохраняет числа языка Lua в виде чисел с плавающей запятой, если числовое значение содержит десятичную запятую или если оно очень велико (более 100 триллионов = 1e14). В противном случае, Tarantool сохраняет такое значение в виде целого числа. Чтобы даже очень большие величины гарантированно обрабатывались как целые числа, используйте функцию :ref:`tonumber64 <other-tonumber64>`, либо приписывайте в конце суффикс LL (Long Long) или ULL (Unsigned Long Long). Вот примеры записи чисел в обычном представлении, экспоненциальном, с суффиксом ULL и с использованием функции ``tonumber64``:  ``-55``, ``-2.7e+20``, ``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

#: ../doc/1.7/book/box/data_model.rst:213
msgid "Lua **tables** with string keys are stored as MsgPack maps; Lua tables with integer keys starting with 1 -- as MsgPack arrays. Nils may not be used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr "В Lua **tables** (таблицы) со строковыми ключами хранятся как ассоциативные массивы в MsgPack; Lua-таблицы с целочисленными ключами, начиная с 1, хранятся как массивы в MsgPack. Нулевые значения нельзя использовать в Lua-таблицах; вместо нулевого значения в таком случае можно указать :ref:`msgpack.NULL <msgpack- null>`"

#: ../doc/1.7/book/box/data_model.rst:218
msgid "A **tuple** is a light reference to a MsgPack array stored in the database. It is a special type (cdata) to avoid conversion to a Lua table on retrieval. A few functions may return tables with multiple tuples. For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr "Тип **tuple** (кортеж) представляет собой легкую ссылку на массив MsgPack, который хранится в базе данных. Это особый тип (cdata), чтобы избежать конвертации в Lua-таблицу при выборке данных. Некоторые функции могут возвращать таблицы с множеством кортежей. Примеры с кортежами см. в :ref:`box.tuple <box_tuple>`."

#: ../doc/1.7/book/box/data_model.rst:225
msgid "Tarantool uses the MsgPack format for database storage, which is variable-length. So, for example, the smallest number requires only one byte, but the largest number requires nine bytes."
msgstr "Tarantool использует формат MsgPack для хранения в базе данных переменной длины. Поэтому, например, для наименьшего числа требуется только один байт, но для наибольшего числа требуется девять байтов."

#: ../doc/1.7/book/box/data_model.rst:229
msgid "Examples of insert requests with different data types:"
msgstr "Примеры запроса вставки с разными типами данных:"

#: ../doc/1.7/book/box/data_model.rst:231
msgid ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."
msgstr ""
"tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"        —-\n"
"        - [1, null, true, 'A B C', 12345, 1.2345]\n"
"        ...\n"
"        tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"        —-\n"
"        - [2, {'a': 5, 'b': 6}]\n"
"        ...\n"
"        tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"        —-\n"
"        - [3, [1, 2, 3, 4, 5]]\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:250
msgid "Indexed field types"
msgstr "Типы индексированных полей"

#: ../doc/1.7/book/box/data_model.rst:252
msgid "Indexes restrict values which Tarantool's MsgPack may contain. This is why, for example, 'unsigned' is a separate **indexed field type**, compared to ‘integer’ data type in MsgPack: they both store ‘integer’ values, but an 'unsigned' index contains only *non-negative* integer values and an ‘integer’ index contains *all* integer values."
msgstr "Индексы ограничивают значения, которые может содержать MsgPack в Tarantool'е. Вот почему, например, тип 'unsigned' (без знака) представляет собой отдельный **тип индексированного поля** в сравнении с типом данных ‘integer’ (целое число) в MsgPack: оба содержат значения с целыми числами, но индекс 'unsigned' содержит только *неотрицательные* целые числовые значения, а индекс ‘integer’ содержит *все* целые числовые значения."

#: ../doc/1.7/book/box/data_model.rst:258
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr "Вот как типы индексированных полей в Tarantool'е соответствуют типам данных MsgPack."

#: ../doc/1.7/book/box/data_model.rst:269
msgid "Indexed field type"
msgstr "Тип индексированного поля"

#: ../doc/1.7/book/box/data_model.rst:269
msgid "MsgPack data type |br| (and possible values)"
msgstr "Тип данных MsgPack |br| (и возможные значения)"

#: ../doc/1.7/book/box/data_model.rst:272
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr "**unsigned** (без знака — может также называться ‘uint’ или ‘num’, но ‘num’ объявлен устаревшим)"

#: ../doc/1.7/book/box/data_model.rst:272
msgid "**integer** (integer between 0 and 18446744073709551615, i.e. about 18 quintillion)"
msgstr "**integer** (целое число в диапазоне от 0 до 18 446 744 073 709 551 615, т.е. около 18 квинтиллионов)"

#: ../doc/1.7/book/box/data_model.rst:272
#: ../doc/1.7/book/box/data_model.rst:292
msgid "TREE, BITSET or HASH"
msgstr "TREE, BITSET или HASH"

#: ../doc/1.7/book/box/data_model.rst:272
msgid "123456"
msgstr "123456"

#: ../doc/1.7/book/box/data_model.rst:277
msgid "**integer** (may also be called ‘int’)"
msgstr "**integer** (целое число — может также называться ‘int’)"

#: ../doc/1.7/book/box/data_model.rst:277
#: ../doc/1.7/book/box/data_model.rst:282
#: ../doc/1.7/book/box/data_model.rst:307
msgid "**integer** (integer between -9223372036854775808 and 18446744073709551615)"
msgstr "``integer`` (целое число в диапазоне от -9 223 372 036 854 775 808 до 18 446 744 073 709 551 615)"

#: ../doc/1.7/book/box/data_model.rst:277
#: ../doc/1.7/book/box/data_model.rst:282
#: ../doc/1.7/book/box/data_model.rst:296
#: ../doc/1.7/book/box/data_model.rst:304
msgid "TREE or HASH"
msgstr "TREE или HASH"

#: ../doc/1.7/book/box/data_model.rst:277
msgid "-2^63"
msgstr "-2^63"

#: ../doc/1.7/book/box/data_model.rst:287
#: ../doc/1.7/book/box/data_model.rst:312
msgid "**double** (single-precision floating point number or double-precision floating point number)"
msgstr "**double** (число с плавающей запятой с одинарной точностью или с двойной точностью)"

#: ../doc/1.7/book/box/data_model.rst:282
#: ../doc/1.7/book/box/data_model.rst:308
msgid "1.234"
msgstr "1,234"

#: ../doc/1.7/book/box/data_model.rst:284
msgid "-44"
msgstr "-44"

#: ../doc/1.7/book/box/data_model.rst:286
msgid "1.447e+44"
msgstr "1,447e+44"

#: ../doc/1.7/book/box/data_model.rst:292
msgid "**string** (may also be called ‘str’)"
msgstr "**string** (строка — может также называться ‘str’)"

#: ../doc/1.7/book/box/data_model.rst:292
msgid "**string** (any set of octets, up to the maximum length)"
msgstr "**string** (строка — любая последовательность октетов до максимальной длины)"

#: ../doc/1.7/book/box/data_model.rst:292
msgid "‘A B C’"
msgstr "‘A B C’"

#: ../doc/1.7/book/box/data_model.rst:294
msgid "‘\\65 \\66 \\67’"
msgstr "‘\\65 \\66 \\67’"

#: ../doc/1.7/book/box/data_model.rst:296
#: ../doc/1.7/book/box/data_model.rst:304
msgid "**bool** (true or false)"
msgstr "**bool** (логический — true или false)"

#: ../doc/1.7/book/box/data_model.rst:299
msgid "**array** (list of numbers representing points in a geometric figure)"
msgstr "**array** (массив — список чисел, который представляет собой точки в геометрической фигуре)"

#: ../doc/1.7/book/box/data_model.rst:299
msgid "RTREE"
msgstr "RTREE"

#: ../doc/1.7/book/box/data_model.rst:299
msgid "{10, 11}"
msgstr "{10, 11}"

#: ../doc/1.7/book/box/data_model.rst:301
msgid "{3, 5, 9, 10}"
msgstr "{3, 5, 9, 10}"

#: ../doc/1.7/book/box/data_model.rst:317
msgid "**string** (any set of octets)"
msgstr "**string** (строковое значение, т.е. любая последовательность октетов)"

#: ../doc/1.7/book/box/data_model.rst:319
msgid "Note: When there is a mix of types, the key order is: booleans, then numbers, then strings."
msgstr "Примечание: в сочетании различных типов порядок будет следующим: логические значения, затем числовые, затем строковые."

#: ../doc/1.7/book/box/data_model.rst:306
msgid "-1"
msgstr "-1"

#: ../doc/1.7/book/box/data_model.rst:310
msgid "‘’"
msgstr "‘’"

#: ../doc/1.7/book/box/data_model.rst:312
msgid "‘ру’"
msgstr "‘ру’"

#: ../doc/1.7/book/box/data_model.rst:329
msgid "Collations"
msgstr "Сортировка"

#: ../doc/1.7/book/box/data_model.rst:331
msgid "By default, when Tarantool compares strings, it uses what we call a **\"binary\" collation**. The only consideration here is the numeric value of each byte in the string. Therefore, if the string is encoded with ASCII or UTF-8, then ``'A' < 'B' < 'a'``, because the encoding of 'A' (what used to be called the \"ASCII value\") is 65, the encoding of 'B' is 66, and the encoding of 'a' is 98. Binary collation is best if you prefer fast deterministic simple maintenance and searching with Tarantool indexes."
msgstr "По умолчанию, когда Tarantool сравнивает строки, он использует то, что мы называем **\"бинарной\" сортировкой**. Единственный фактор, который учитывается, это числовое значение каждого байта в строке. Таким образом, если строка кодируется по ASCII или UTF-8, то ``'A' < 'B' < 'a'``, поскольку в кодировке 'A' (что раньше называлось \"значение ASCII\") соответствует 65, 'B' — 66, а 'a' — 98. Бинарная сортировка подходит лучше всего для быстрого детерминированного простого обслуживания и поиска с помощью индексов Tarantool'а."

#: ../doc/1.7/book/box/data_model.rst:340
msgid "But if you want the ordering that you see in phone books and dictionaries, then you need Tarantool's **optional collations** -- ``unicode`` and ``unicode_ci`` -- that allow for ``'A' < 'a' < 'B'`` and ``'A' = 'a' < 'B'`` respectively."
msgstr "Однако если необходимо распределение, как в телефонных справочниках и словарях, то вам нужна **опциональная сортировка** Tarantool'а — ``unicode`` и ``unicode_ci`` — которые обеспечивают ``'A' < 'a' < 'B'`` и ``'A' = 'a' < 'B'`` соответственно."

#: ../doc/1.7/book/box/data_model.rst:345
msgid "Optional collations use the ordering according to the `Default Unicode Collation Element Table (DUCET) <http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_ and the rules described in `Unicode® Technical Standard #10 Unicode Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_. The only difference between the two collations is about `weights <https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"
msgstr "Опциональная сортировка использует распределение в соответствии с `Таблицей сортировки символов Юникода по умолчанию (DUCET) <http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_ и правилами, указанными в `Техническом стандарте Юникода №10 — Алгоритм сортировки по Юникоду (Unicode® Technical Standard #10 Unicode Collation Algorithm (UTS #10 UCA)) <http://unicode.org/reports/tr10>`_. Единственное отличие между двумя сортировками — `вес <https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"

#: ../doc/1.7/book/box/data_model.rst:352
msgid "``unicode`` collation observes four weight levels, from L1 to L4,"
msgstr "сортировка ``unicode`` принимает во внимание четыре уровня веса, от L1 до L4,"

#: ../doc/1.7/book/box/data_model.rst:353
msgid "``unicode_ci`` collation observes only L1 weights, the ``ci`` suffix meaning \"`case-insensitive <https://www.unicode.org/reports/tr35/tr35-collation.html#Case_Parameters>`_\"."
msgstr "сортировка ``unicode_ci`` принимает во внимание только вес L1, суффикс ``ci`` в данном случае означает \"`нечувствительный к регистру (case-insensitive) <https://www.unicode.org/reports/tr35/tr35-collation.html#Case_Parameters>`_\"."

#: ../doc/1.7/book/box/data_model.rst:356
msgid "As an example, let's take some Russian words:"
msgstr "Для примера возьмем некоторые русские слова:"

#: ../doc/1.7/book/box/data_model.rst:358
msgid ""
"'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"
msgstr ""
"'ЕЛЕ'\n"
"        'елейный'\n"
"        'ёлка'\n"
"        'еловый'\n"
"        'елозить'\n"
"        'Ёлочка'\n"
"        'ёлочный'\n"
"        'ЕЛь'\n"
"        'ель'"

#: ../doc/1.7/book/box/data_model.rst:370
msgid "...and show the difference in ordering and selecting by index:"
msgstr "...и покажем разницу в упорядочении и выборке по индексу:"

#: ../doc/1.7/book/box/data_model.rst:372
msgid "with ``unicode`` collation:"
msgstr "с сортировкой по ``unicode``:"

#: ../doc/1.7/book/box/data_model.rst:374
msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', collation='unicode'}}})\n"
"        ...\n"
"        tarantool> box.space.T.index.I:select()\n"
"        ---\n"
"        - - ['ЕЛЕ']\n"
"          - ['елейный']\n"
"          - ['ёлка']\n"
"          - ['еловый']\n"
"          - ['елозить']\n"
"          - ['Ёлочка']\n"
"          - ['ёлочный']\n"
"          - ['ель']\n"
"          - ['ЕЛь']\n"
"        ...\n"
"        tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"        ---\n"
"        - []\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:395
msgid "with ``unicode_ci`` collation:"
msgstr "с сортировкой по ``unicode_ci``:"

#: ../doc/1.7/book/box/data_model.rst:397
msgid ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."
msgstr ""
"tarantool> box.space.T:create_index('I', {parts = {{1,'str', collation='unicode_ci'}}})\n"
"        ...\n"
"        tarantool> box.space.S.index.I:select()\n"
"        ---\n"
"        - - ['ЕЛЕ']\n"
"          - ['елейный']\n"
"          - ['ёлка']\n"
"          - ['еловый']\n"
"          - ['елозить']\n"
"          - ['Ёлочка']\n"
"          - ['ёлочный']\n"
"          - ['ЕЛь']\n"
"        ...\n"
"        tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"        ---\n"
"        - - ['ёлка']\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:417
msgid "In fact, though, good collation involves much more than these simple examples of upper case / lower case equivalence in alphabets. We also consider accent marks, non-alphabetic writing systems, and special rules that apply for combinations of characters."
msgstr "Фактически хорошая сортировка включает в себя гораздо больше, чем простые примеры эквивалентности заглавных букв и строчных в алфавитах. Учитываются также знаки ударения, системы письменности без алфавита и специальные правила, которые применяются в отношении сочетания символов."

#: ../doc/1.7/book/box/data_model.rst:428
msgid "A **sequence** is a generator of ordered integer values."
msgstr "**Последовательность** — это генератор упорядоченных значений целых чисел."

#: ../doc/1.7/book/box/data_model.rst:430
msgid "As with spaces and indexes, you should specify the sequence **name**, and let Tarantool come up with a unique **numeric identifier** (\"sequence id\")."
msgstr "Как и для спейсов и индексов, для последовательностей следует указать **имена**, а Tarantool определит уникальный **числовой идентификатор** (\"ID последовательности\")."

#: ../doc/1.7/book/box/data_model.rst:433
msgid "As well, you can specify several options when creating a new sequence. The options determine what value will be generated whenever the sequence is used."
msgstr "Кроме того, можно указать несколько параметров при создании новой последовательности. Параметры определяют, какое значение будет генерироваться при использовании последовательности."

#: ../doc/1.7/book/box/data_model.rst:440
msgid "Options for ``box.schema.sequence.create()``"
msgstr "Параметры для ``box.schema.sequence.create()``"

#: ../doc/1.7/book/box/data_model.rst:451
msgid "Option name"
msgstr "Имя параметра"

#: ../doc/1.7/book/box/data_model.rst:451
msgid "Type and meaning"
msgstr "Тип и значение"

#: ../doc/1.7/book/box/data_model.rst:453
msgid "**start**"
msgstr "**start** (начало)"

#: ../doc/1.7/book/box/data_model.rst:453
msgid "Integer. The value to generate the first time a sequence is used"
msgstr "Целое число. Значение генерируется, когда последовательность используется впервые"

#: ../doc/1.7/book/box/data_model.rst:453
msgid "start=0"
msgstr "start=0"

#: ../doc/1.7/book/box/data_model.rst:457
msgid "**min**"
msgstr "**min** (мин)"

#: ../doc/1.7/book/box/data_model.rst:457
msgid "Integer. Values smaller than this cannot be generated"
msgstr "Целое число. Ниже указанного значения не могут генерироваться"

#: ../doc/1.7/book/box/data_model.rst:457
msgid "min=-1000"
msgstr "min=-1000"

#: ../doc/1.7/book/box/data_model.rst:460
msgid "**max**"
msgstr "**max** (макс)"

#: ../doc/1.7/book/box/data_model.rst:460
msgid "Integer. Values larger than this cannot be generated"
msgstr "Целое число. Выше указанного значения не могут генерироваться"

#: ../doc/1.7/book/box/data_model.rst:460
msgid "9223372036854775807"
msgstr "9 223 372 036 854 775 807"

#: ../doc/1.7/book/box/data_model.rst:460
msgid "max=0"
msgstr "max=0"

#: ../doc/1.7/book/box/data_model.rst:463
msgid "**cycle**"
msgstr "**cycle** (цикл)"

#: ../doc/1.7/book/box/data_model.rst:463
msgid "Boolean. Whether to start again when values cannot be generated"
msgstr "Логическое значение. Если значения не могут быть сгенерированы, начинать ли заново"

#: ../doc/1.7/book/box/data_model.rst:463
msgid "cycle=true"
msgstr "cycle=true"

#: ../doc/1.7/book/box/data_model.rst:466
msgid "**cache**"
msgstr "**cache** (кэш)"

#: ../doc/1.7/book/box/data_model.rst:466
msgid "Integer. The number of values to store in a cache"
msgstr "Целое число. Количество значений для хранения в кэше"

#: ../doc/1.7/book/box/data_model.rst:466
msgid "cache=0"
msgstr "cache=0"

#: ../doc/1.7/book/box/data_model.rst:469
msgid "**step**"
msgstr "**step** (шаг)"

#: ../doc/1.7/book/box/data_model.rst:469
msgid "Integer. What to add to the previous generated value, when generating a new value"
msgstr "Целое число. Что добавить к предыдущему сгенерированному значению, когда генерируется новое значение"

#: ../doc/1.7/book/box/data_model.rst:469
msgid "step=-1"
msgstr "step=-1"

#: ../doc/1.7/book/box/data_model.rst:474
msgid "Once a sequence exists, it can be altered, dropped, reset, forced to generate the next value, or associated with an index."
msgstr "Существующую последовательность можно изменять, опускать, сбрасывать, заставить сгенерировать новое значение или ассоциировать с индексом."

#: ../doc/1.7/book/box/data_model.rst:477
msgid "For an initial example, we generate a sequence named 'S'."
msgstr "Для первоначального примера сгенерируем последовательность под названием 'S'."

#: ../doc/1.7/book/box/data_model.rst:479
msgid ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."
msgstr ""
"tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"        ---\n"
"        - step: 1\n"
"          id: 5\n"
"          min: 5\n"
"          cache: 0\n"
"          uid: 1\n"
"          max: 9223372036854775807\n"
"          cycle: false\n"
"          name: S\n"
"          start: 5\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:494
msgid "The result shows that the new sequence has all default values, except for the two that were specified, ``min`` and ``start``."
msgstr "В результате видим, что в новой последовательность есть все значения по умолчанию, за исключением указанных ``min`` и ``start``."

#: ../doc/1.7/book/box/data_model.rst:497
msgid "Then we get the next value, with the ``next()`` function."
msgstr "Затем получаем следующее значение с помощью функции ``next()``."

#: ../doc/1.7/book/box/data_model.rst:499
msgid ""
"tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."
msgstr ""
"tarantool> box.sequence.S:next()\n"
"        ---\n"
"        - 5\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:506
msgid "The result is the same as the start value. If we called ``next()`` again, we would get 6 (because the previous value plus the step value is 6), and so on."
msgstr "Результат точно такой же, как и начальное значение. Если мы снова вызовем ``next()``, то получим 6 (потому что предыдущее значение плюс значение шага составит 6) и так далее."

#: ../doc/1.7/book/box/data_model.rst:510
msgid "Then we create a new table, and say that its primary key may be generated from the sequence."
msgstr "Затем создадим новую таблицу и скажем, что ее первичный ключ можно получить из последовательности."

#: ../doc/1.7/book/box/data_model.rst:513
msgid ""
"tarantool> s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."
msgstr ""
"tarantool> s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"        ---\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:519
msgid "Then we insert a tuple, without specifying a value for the primary key."
msgstr "Затем вставим кортеж, не указывая значение первичного ключа."

#: ../doc/1.7/book/box/data_model.rst:521
msgid ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."
msgstr ""
"tarantool> box.space.T:insert{nil,'other stuff'}\n"
"        ---\n"
"        - [6, 'other stuff']\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:528
msgid "The result is a new tuple where the first field has a value of 6. This arrangement, where the system automatically generates the values for a primary key, is sometimes called \"auto-incrementing\" or \"identity\"."
msgstr "В результате имеем новый кортеж со значением 6 в первом поле. Такой способ организации данных, когда система автоматически генерирует значения для первичного ключа, иногда называется \"автоинкрементным\" (т.е. с автоматическим увеличением) или \"по идентификатору\"."

#: ../doc/1.7/book/box/data_model.rst:533
msgid "For syntax and implementation details, see the reference for :ref:`box.schema.sequence <box_schema-sequence>`."
msgstr "Для получения подробной информации о синтаксисе и методах имплементации см. справочник по :ref:`box.schema.sequence <box_schema-sequence>`."

#: ../doc/1.7/book/box/data_model.rst:540
msgid "Persistence"
msgstr "Персистентность"

#: ../doc/1.7/book/box/data_model.rst:542
msgid "In Tarantool, updates to the database are recorded in the so-called :ref:`write ahead log (WAL) <internals-wal>` files. This ensures data persistence. When a power outage occurs or the Tarantool instance is killed incidentally, the in-memory database is lost. In this situation, WAL files are used to restore the data. Namely, Tarantool reads the WAL files and redoes the requests (this is called the \"recovery process\"). You can change the timing of the WAL writer, or turn it off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr "В Tarantool'е обновления базы данных записываются в так называемые :ref:`файлы журнала упреждающей записи (WAL-файлы) <internals-wal>`. Это обеспечивает персистентность данных. При отключении электроэнергии или случайном завершении работы экземпляра Tarantool'а данные в оперативной памяти теряются. В такой ситуации WAL-файлы используются для восстановления данных так: Tarantool прочитывает WAL-файлы и повторно выполняет запросы (это называется \"процессом восстановления\"). Можно изменить временные настройки метода записи WAL-файлов или отключить его с помощью :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."

#: ../doc/1.7/book/box/data_model.rst:551
msgid "Tarantool also maintains a set of :ref:`snapshot files <internals-snapshot>`. These files contain an on-disk copy of the entire data set for a given moment. Instead of reading every WAL file since the databases were created, the recovery process can load the latest snapshot file and then read only those WAL files that were produced after the snapshot file was made. After checkpointing, old WAL files can be removed to free up space."
msgstr "Tarantool также сохраняет ряд файлов со статическими снимками данных (:ref:`snapshots <internals-snapshot>`). Файл со снимком — это дисковая копия всех данных в базе на какой-то момент. Вместо того, чтобы зачитывать все WAL-файлы, появившиеся с момента создания базы, Tarantool в процессе восстановления может загрузить самый свежий снимок и затем зачитать только те WAL-файлы, которые были сделаны с момента сохранения снимка. После создания новых файлов, старые WAL-файлы могут быть удалены в целях экономии места на диске."

#: ../doc/1.7/book/box/data_model.rst:558
msgid "To force immediate creation of a snapshot file, you can use Tarantool's :ref:`box.snapshot() <box-snapshot>` request. To enable automatic creation of snapshot files, you can use Tarantool's :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`. The checkpoint daemon sets intervals for forced checkpoints. It makes sure that the states of both memtx and vinyl storage engines are synchronized and saved to disk, and automatically removes old WAL files."
msgstr "Чтобы принудительно создать файл со снимком, можно использовать запрос :ref:`box.snapshot() <box-snapshot>` в Tarantool'е. Чтобы включить автоматическое создание файлов со снимком, можно использовать :ref:`демон создания контрольных точек <book_cfg_checkpoint_daemon>` Tarantool'а. Демон создания контрольных точек определяет интервалы для принудительного создания контрольных точек. Он обеспечивает синхронизацию и сохранение на диск образов движков базы данных (как memtx, так и vinyl), а также автоматически удаляет старые WAL-файлы."

#: ../doc/1.7/book/box/data_model.rst:566
msgid "Snapshot files can be created even if there is no WAL file."
msgstr "Файлы со снимками можно создавать, даже если WAL-файлы отсутствуют."

#: ../doc/1.7/book/box/data_model.rst:570
msgid "The memtx engine makes only regular checkpoints with the interval set in :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr "Движок memtx регулярно создает контрольные точки с интервалом, указанным в настройках :ref:`демона создания контрольных точек <book_cfg_checkpoint_daemon>`."

#: ../doc/1.7/book/box/data_model.rst:573
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr "Движок vinyl постоянно сохраняет состояние в контрольной точке в фоновом режиме."

#: ../doc/1.7/book/box/data_model.rst:575
msgid "See the :ref:`Internals <internals-data_persistence>` section for more details about the WAL writer and the recovery process."
msgstr "Для получения более подробной информации о методе записи WAL-файлов и процессе восстановления см. раздел :ref:`Внутренняя реализация <internals-data_persistence>`."

#: ../doc/1.7/book/box/data_model.rst:580
msgid "Operations"
msgstr "Операции"

#: ../doc/1.7/book/box/data_model.rst:586
msgid "Data operations"
msgstr "Операции с данными"

#: ../doc/1.7/book/box/data_model.rst:588
msgid "The basic data operations supported in Tarantool are:"
msgstr "Tarantool поддерживает следующие основные операции с данными:"

#: ../doc/1.7/book/box/data_model.rst:590
msgid "five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, REPLACE), and"
msgstr "пять операций по изменению данных (INSERT, UPDATE, UPSERT, DELETE, REPLACE) и"

#: ../doc/1.7/book/box/data_model.rst:591
msgid "one data-retrieval operation (SELECT)."
msgstr "одну операция по выборке данных (SELECT)."

#: ../doc/1.7/book/box/data_model.rst:593
msgid "All of them are implemented as functions in :ref:`box.space <box_space>` submodule."
msgstr "Все они имплементированы в виде функций во вложенном модуле  :ref:`box.space <box_space>`."

#: ../doc/1.7/book/box/data_model.rst:597
msgid ":ref:`INSERT <box_space-insert>`: Add a new tuple to space 'tester'."
msgstr ":ref:`INSERT <box_space-insert>`: добавить новый кортеж к спейсу 'tester'."

#: ../doc/1.7/book/box/data_model.rst:599
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr "Первое поле, field[1], будет 999 (тип MsgPack — `integer`, целое число)."

#: ../doc/1.7/book/box/data_model.rst:601
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr "Второе поле, field[2], будет 'Taranto' (тип MsgPack — `string`, строка)."

#: ../doc/1.7/book/box/data_model.rst:603
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr "tarantool> box.space.tester:insert{999, 'Taranto'}"

#: ../doc/1.7/book/box/data_model.rst:607
msgid ":ref:`UPDATE <box_space-update>`: Update the tuple, changing field field[2]."
msgstr ":ref:`UPDATE <box_space-update>`: обновить кортеж, изменяя поле field[2]."

#: ../doc/1.7/book/box/data_model.rst:609
msgid "The clause \"{999}\", which has the value to look up in the index of the tuple's primary-key field, is mandatory, because ``update()`` requests must always have a clause that specifies a unique key, which in this case is field[1]."
msgstr "Оператор \"{999}\" со значением, которое используется для поиска поля, соответствующего ключу в первичном индексе, является обязательным, поскольку в запросе ``update()`` должен быть оператор, который указывает уникальный ключ, в данном случае — field[1]."

#: ../doc/1.7/book/box/data_model.rst:613
msgid "The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will happen to field[2] with the new value."
msgstr "Оператор \"{{'=', 2, 'Tarantino'}}\" указывает, что назначение нового значения относится к field[2]."

#: ../doc/1.7/book/box/data_model.rst:616
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"

#: ../doc/1.7/book/box/data_model.rst:620
msgid ":ref:`UPSERT <box_space-upsert>`: Upsert the tuple, changing field field[2] again."
msgstr ":ref:`UPSERT <box_space-upsert>`: обновить или вставить кортеж, снова изменяя поле field[2]."

#: ../doc/1.7/book/box/data_model.rst:623
msgid "The syntax of ``upsert()`` is similar to the syntax of ``update()``. However, the execution logic of these two requests is different. UPSERT is either UPDATE or INSERT, depending on the database's state. Also, UPSERT execution is postponed until after transaction commit, so, unlike ``update()``, ``upsert()`` doesn't return data back."
msgstr "Синтаксис ``upsert()`` похож на синтаксис ``update()``. Однако логика выполнения двух запросов отличается. UPSERT означает UPDATE или INSERT, в зависимости от состояния базы данных. Кроме того, выполнение UPSERT откладывается до коммита транзакции, поэтому в отличие от``update()``, ``upsert()`` не возвращает данные."

#: ../doc/1.7/book/box/data_model.rst:629
msgid "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})"
msgstr "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})"

#: ../doc/1.7/book/box/data_model.rst:633
msgid ":ref:`REPLACE <box_space-replace>`: Replace the tuple, adding a new field."
msgstr ":ref:`REPLACE <box_space-replace>`: заменить кортеж, добавляя новое поле."

#: ../doc/1.7/book/box/data_model.rst:635
msgid "This is also possible with the ``update()`` request, but the ``update()`` request is usually more complicated."
msgstr "Это действие также можно выполнить с помощью запроса ``update()``, но обычно запрос ``update()`` более сложен."

#: ../doc/1.7/book/box/data_model.rst:638
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"

#: ../doc/1.7/book/box/data_model.rst:642
msgid ":ref:`SELECT <box_space-select>`: Retrieve the tuple."
msgstr ":ref:`SELECT <box_space-select>`: провести выборку кортежа."

#: ../doc/1.7/book/box/data_model.rst:644
msgid "The clause \"{999}\" is still mandatory, although it does not have to mention the primary key."
msgstr "Оператор \"{999}\" все еще обязателен, хотя в нем не должен упоминаться первичный ключ."

#: ../doc/1.7/book/box/data_model.rst:647
msgid "tarantool> box.space.tester:select{999}"
msgstr "tarantool> box.space.tester:select{999}"

#: ../doc/1.7/book/box/data_model.rst:651
msgid ":ref:`DELETE <box_space-delete>`: Delete the tuple."
msgstr ":ref:`DELETE <box_space-delete>`: удалить кортеж."

#: ../doc/1.7/book/box/data_model.rst:653
msgid "In this example, we identify the primary-key field."
msgstr "В этом примере мы определяем поле, соответствующее ключу в первичном индексе."

#: ../doc/1.7/book/box/data_model.rst:655
msgid "tarantool> box.space.tester:delete{999}"
msgstr "tarantool> box.space.tester:delete{999}"

#: ../doc/1.7/book/box/data_model.rst:659
msgid "Summarizing the examples:"
msgstr "Подводя итоги по примерам:"

#: ../doc/1.7/book/box/data_model.rst:661
msgid "Functions ``insert`` and ``replace`` accept a tuple (where a primary key comes as part of the tuple)."
msgstr "Функции ``insert`` и ``replace`` принимают кортеж (где первичный ключ — это часть кортежа)."

#: ../doc/1.7/book/box/data_model.rst:663
msgid "Function ``upsert`` accepts a tuple (where a primary key comes as part of the tuple), and also the update operations to execute."
msgstr "Функция ``upsert`` принимает кортеж (где первичный ключ — это часть кортежа), а также операции по обновлению."

#: ../doc/1.7/book/box/data_model.rst:666
msgid "Function ``delete`` accepts a full key of any unique index (primary or secondary)."
msgstr "Функция ``delete`` принимает полный ключ любого уникального индекса (первичный или вторичный)."

#: ../doc/1.7/book/box/data_model.rst:668
msgid "Function ``update`` accepts a full key of any unique index (primary or secondary), and also the operations to execute."
msgstr "Функция  ``update`` принимает полный ключ любого уникального индекса (первичный или вторичный), а также операции к выполнению."

#: ../doc/1.7/book/box/data_model.rst:671
msgid "Function ``select`` accepts any key: primary/secondary, unique/non-unique, full/partial."
msgstr "Функция ``select`` принимает любой ключ: первичный/вторичный, уникальный/неуникальный, полный/часть."

#: ../doc/1.7/book/box/data_model.rst:674
msgid "See reference on ``box.space`` for more :ref:`details on using data operations <box_space-operations-detailed-examples>`."
msgstr "Для получения более :ref:`подробной информации по использованию операций с данными <box_space-operations-detailed-examples>` см. справочник по ``box.space``."

#: ../doc/1.7/book/box/data_model.rst:679
msgid "Besides Lua, you can use :ref:`Perl, PHP, Python or other programming language connectors <index-box_connectors>`. The client server protocol is open and documented. See this :ref:`annotated BNF <box_protocol-iproto_protocol>`."
msgstr "Помимо Lua можно использовать :ref:`коннекторы к Perl, PHP, Python или другому языку программирования <index-box_connectors>`. Клиент-серверный протокол открыт и задокументирован. См. :ref:`БНФ с комментариями <box_protocol- iproto_protocol>`."

#: ../doc/1.7/book/box/data_model.rst:686
msgid "Index operations"
msgstr "Операции с индексами"

#: ../doc/1.7/book/box/data_model.rst:688
msgid "Index operations are automatic: if a data-manipulation request changes a tuple, then it also changes the index keys defined for the tuple."
msgstr "Операции с индексами производятся автоматически. Если запрос по манипулированию данными меняет данные в кортеже, то меняются и ключи в индексе для данного кортежа."

#: ../doc/1.7/book/box/data_model.rst:691
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr "Простая операция по созданию индекса, которую мы рассматривали ранее, выглядит следующим образом:"

#: ../doc/1.7/book/box/data_model.rst:730
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{space-name}:create_index('{index-name}')`"

#: ../doc/1.7/book/box/data_model.rst:698
msgid "This creates a unique TREE index on the first field of all tuples (often called \"Field#1\"), which is assumed to be numeric."
msgstr "По умолчанию, при этом создается TREE-индекс по первому полю для всех кортежей (обычно его называют \"Field#1\"). Предполагается, что индексируемое поле является числовым."

#: ../doc/1.7/book/box/data_model.rst:701
msgid "The simple SELECT request that we've illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../doc/1.7/book/box/data_model.rst:740
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"

#: ../doc/1.7/book/box/data_model.rst:708
msgid "This looks for a single tuple via the first index. Since the first index is always unique, the maximum number of returned tuples will be: one."
msgstr "Такой запрос ищет отдельный кортеж по первичному индексу. Поскольку первичный индекс всегда уникален, то данный запрос вернет не более одного кортежа."

#: ../doc/1.7/book/box/data_model.rst:711
msgid "The following SELECT variations exist:"
msgstr "Возможны следующие варианты SELECT:"

#: ../doc/1.7/book/box/data_model.rst:713
msgid "The search can use comparisons other than equality."
msgstr "Помимо условия равенства, при поиске могут использоваться и другие условия сравнения."

#: ../doc/1.7/book/box/data_model.rst:752
msgid ":extsamp:`box.space.{*{space-name}*}:select(value, {iterator = 'GT'})`"
msgstr ":extsamp:`box.space.{*{space-name}*}:select(value, {iterator = 'GT'})`"

#: ../doc/1.7/book/box/data_model.rst:720
msgid "The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, EQ, REQ, GE, GT (for \"less than\", \"less than or equal\", \"equal\", \"reversed equal\", \"greater than or equal\", \"greater than\" respectively). Comparisons make sense if and only if the index type is ‘TREE'."
msgstr "Можно использовать следующие :ref:`операторы сравнения <box_index-iterator-types>`: LT (меньше), LE (меньше  или равно), EQ (равно), REQ (неравно), GE (больше или равно), GT (больше). Сравнения имеют смысл только для индексов типа 'TREE'."

#: ../doc/1.7/book/box/data_model.rst:725
msgid "This type of search may return more than one tuple; if so, the tuples will be in descending order by key when the comparison operator is LT or LE or REQ, otherwise in ascending order."
msgstr "Этот вариант поиска может вернуть более одного кортежа. В таком случае кортежи будут отсортированы в порядке убывания по ключу (если использовался оператор LT, LE или REQ), либо в порядке возрастания (во всех остальных случаях)."

#: ../doc/1.7/book/box/data_model.rst:729
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../doc/1.7/book/box/data_model.rst:768
msgid ":extsamp:`box.space.{*{space-name}*}.index.{*{index-name}*}:select(value)`"
msgstr ":extsamp:`box.space.{*{space-name}*}.index.{*{index-name}*}:select(value)`"

#: ../doc/1.7/book/box/data_model.rst:736
msgid "For a primary-key search, it is optional to specify an index name. For a secondary-key search, it is mandatory."
msgstr "При поиске по первичному индексу имя индекса можно не указывать. При поиске же по вторичному индексу имя индекса указывать необходимо."

#: ../doc/1.7/book/box/data_model.rst:739
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../doc/1.7/book/box/data_model.rst:778
msgid ""
"-- Suppose an index has two parts\n"
":samp:`tarantool> box.space.{space-name}.index.{index-name}.parts`\n"
"---\n"
"- - type: unsigned\n"
"    fieldno: 1\n"
"  - type: string\n"
"    fieldno: 2\n"
"...\n"
"-- Suppose the space has three tuples\n"
":samp:`box.space.{space-name}:select()`\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [2, '']\n"
"..."
msgstr ""
"-- Предположим, индекс состоит из двух частей\n"
"        :samp:`tarantool> box.space.{space-name}.index.{index-name}.parts`\n"
"        ---\n"
"        - - type: unsigned\n"
"            fieldno: 1\n"
"          - type: string\n"
"            fieldno: 2\n"
"        ...\n"
"        -- Предположим, в спейсе 3 кортежа\n"
"        :samp:`box.space.{space-name}:select()`\n"
"        ---\n"
"        - - [1, 'A']\n"
"          - [1, 'B']\n"
"          - [2, '']\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:760
msgid "The search may be for all fields, using a table for the value:"
msgstr "Поиск может производиться по всем полям с использованием таблицы значений:"

#: ../doc/1.7/book/box/data_model.rst:799
msgid ":extsamp:`box.space.{*{space-name}*}:select({1, 'A'})`"
msgstr ":extsamp:`box.space.{*{space-name}*}:select({1, 'A'})`"

#: ../doc/1.7/book/box/data_model.rst:767
msgid "or the search can be for one field, using a table or a scalar:"
msgstr "либо же по одному полю (в этом случае используется таблица или скалярное значение):"

#: ../doc/1.7/book/box/data_model.rst:806
msgid ":samp:`box.space.{space-name}:select(1)`"
msgstr ":samp:`box.space.{space-name}:select(1)`"

#: ../doc/1.7/book/box/data_model.rst:774
msgid "In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1, 'B'}``."
msgstr "Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1,  'B'}``."

#: ../doc/1.7/book/box/data_model.rst:777
msgid "You can specify even zero fields, causing all three tuples to be returned. (Notice that partial key searches are available only in TREE indexes.)"
msgstr "При необходимости можно задать даже нулевые поля, в результате чего Tarantool вернет все три кортежа (обратите внимание, что поиск по компонентам ключа доступен только для TREE-индексов)."

#: ../doc/1.7/book/box/data_model.rst:780
msgid "**Examples**"
msgstr "**Примеры**"

#: ../doc/1.7/book/box/data_model.rst:782
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../doc/1.7/book/box/data_model.rst:784
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"        tarantool> box.space.bitset_example:create_index('primary')\n"
"        tarantool> box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',  parts={2,'unsigned'}})\n"
"        tarantool> box.space.bitset_example:insert{1,1}\n"
"        tarantool> box.space.bitset_example:insert{2,4}\n"
"        tarantool> box.space.bitset_example:insert{3,7}\n"
"        tarantool> box.space.bitset_example:insert{4,3}\n"
"        tarantool> box.space.bitset_example.index.bitset:select(2, {iterator='BITS_ANY_SET'})"

#: ../doc/1.7/book/box/data_model.rst:795
#: ../doc/1.7/book/box/data_model.rst:817
#: ../doc/1.7/tutorials/lua_tutorials.rst:843
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../doc/1.7/book/box/data_model.rst:797
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"        - - [3, 7]\n"
"          - [4, 3]\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:804
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../doc/1.7/book/box/data_model.rst:806
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../doc/1.7/book/box/data_model.rst:808
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = 'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"        tarantool> box.space.rtree_example:create_index('primary')\n"
"        tarantool> box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', parts={2,'ARRAY'}})\n"
"        tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"        tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"        tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = 'GT'})"

#: ../doc/1.7/book/box/data_model.rst:819
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"        - - [1, [3, 5, 9, 10]]\n"
"        ..."

#: ../doc/1.7/book/box/data_model.rst:825
msgid "because a rectangle whose corners are at coordinates ``4,7,5,9`` is entirely within a rectangle whose corners are at coordinates ``3,5,9,10``."
msgstr "поскольку прямоугольник с углами в координатах ``4,7,5,9`` лежит целиком внутри прямоугольника с углами в координатах ``3,5,9,10``."

#: ../doc/1.7/book/box/data_model.rst:828
msgid "Additionally, there exist :ref:`index iterator operations <box_index-index_pairs>`. They can only be used with code in Lua and C/C++. Index iterators are for traversing indexes one key at a time, taking advantage of features that are specific to an index type, for example evaluating Boolean expressions when traversing BITSET indexes, or going in descending order when traversing TREE indexes."
msgstr "Кроме того, есть :ref:`операции с итераторами с индексом <box_index-index_pairs>`. Их можно использовать только с кодом на языках Lua и C/C++. Итераторы с индексом предназначены для обхода индексов по одному ключу за раз, поскольку используют особенности каждого типа индекса, например оценка логических выражений при обходе BITSET-индексов или обход TREE-индексов в порядке по убыванию."

#: ../doc/1.7/book/box/data_model.rst:834
msgid "See also other index operations like :ref:`alter() <box_index-alter>` and :ref:`drop() <box_index-drop>` in reference for :ref:`box.index <box_index>` submodule."
msgstr "См. также информацию о других операциях с итераторами с индексом, таких как :ref:`alter() <box_index-alter>` и :ref:`drop() <box_index-drop>` во вложенном модуле :ref:`box.index <box_index>`."

#: ../doc/1.7/book/box/data_model.rst:839
msgid "Complexity factors"
msgstr "Факторы сложности"

#: ../doc/1.7/book/box/data_model.rst:841
msgid "In reference for :ref:`box.space <box_space>` and :ref:`box.index <box_index>` submodules, there are notes about which complexity factors might affect the resource usage of each function."
msgstr "Что касается вложенных модулей :ref:`box.space <box_space>` и :ref:`box.index <box_index>`, есть информация о том, как факторы сложности могут повлиять на использование каждой функции."

#: ../doc/1.7/book/box/data_model.rst:851
msgid "Complexity factor"
msgstr "Фактор сложности"

#: ../doc/1.7/book/box/data_model.rst:854
msgid "Index size"
msgstr "Размер индекса"

#: ../doc/1.7/book/box/data_model.rst:854
msgid "The number of index keys is the same as the number of tuples in the data set. For a TREE index, if there are more keys, then the lookup time will be greater, although of course the effect is not linear. For a HASH index, if there are more keys, then there is more RAM used, but the number of low-level steps tends to remain constant."
msgstr "Количество ключей в индексе равно количеству кортежей в наборе данных. В случае с TREE-индексом: с ростом количества ключей увеличивается время поиска, хотя зависимость здесь, конечно же, не линейная. В случае с HASH-индексом: с ростом количества ключей увеличивается объем оперативной памяти, но количество низкоуровневых шагов остается примерно тем же."

#: ../doc/1.7/book/box/data_model.rst:862
msgid "Typically, a HASH index is faster than a TREE index if the number of tuples in the space is greater than one."
msgstr "Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу,  если в спейсе более одного кортежа."

#: ../doc/1.7/book/box/data_model.rst:866
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../doc/1.7/book/box/data_model.rst:866
msgid "Ordinarily, only one index is accessed to retrieve one tuple. But to update the tuple, there must be N accesses if the space has N different indexes."
msgstr "Обычно для выборки значений одного кортежа используется только один индекс. Но при обновлении значений в кортеже требуется N обращений, если в спейсе N индексов."

#: ../doc/1.7/book/box/data_model.rst:870
msgid "Note re storage engine: Vinyl optimizes away such accesses if secondary index fields are unchanged by the update. So, this complexity factor applies only to memtx, since it always makes a full-tuple copy on every update."
msgstr "Примечание по движку базы данных: Vinyl отклоняет такой доступ, если обновление не затрагивает поля вторичного индекса. Таким образом, этот фактор сложности влияет только на memtx, поскольку он всегда создает копию всего кортежа при каждом обновлении."

#: ../doc/1.7/book/box/data_model.rst:876
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../doc/1.7/book/box/data_model.rst:876
msgid "A few requests, for example SELECT, can retrieve multiple tuples. This factor is usually less important than the others."
msgstr "Некоторые запросы, например SELECT, могут возвращать несколько кортежей. Как правило, это наименее важный фактор из всех."

#: ../doc/1.7/book/box/data_model.rst:880
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../doc/1.7/book/box/data_model.rst:880
msgid "The important setting for the write-ahead log is :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing or delayed writing, this factor is unimportant. If the setting causes every data-change request to wait for writing to finish on a slow device, this factor is more important than all the others."
msgstr "Важным параметром для записи в WAL является :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или  задана запись с задержкой, но этот фактор не так важен. Если же запись в  WAL производится при каждом запросе на изменение данных, то при каждом таком запросе приходится ждать, пока отработает обращение к более медленному диску, и данный фактор становится важнее всех остальных."

#: ../doc/1.7/book/box/index.rst:5
msgid "Database"
msgstr "Функциональность СУБД"

#: ../doc/1.7/book/box/index.rst:7
msgid "In this chapter, we introduce the basic concepts of working with Tarantool as a database manager."
msgstr "В данной главе мы рассмотрим основные понятия при работе с Tarantool'ом в качестве системы управления базой данных."

#: ../doc/1.7/book/box/limitations.rst:5
msgid "Limitations"
msgstr "Ограничения"

#: ../doc/1.7/book/box/limitations.rst:7
msgid "**Number of parts in an index**"
msgstr "**Количество частей в индексе**"

#: ../doc/1.7/book/box/limitations.rst:9
msgid "For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). For :ref:`RTREE <box_index-rtree>` indexes, the maximum is 1 but the field is an ARRAY of up to 20 dimensions. For BITSET indexes, the maximum is 1."
msgstr "Для TREE-индексов или HASH-индексов максимальное количество — 255 частей (``box.schema.INDEX_PART_MAX``). Для :ref:`RTREE-индексов <box_index-rtree>` максимальное количество — 1, но это поля типа ARRAY (массив) с размерностью до 20. Для BITSET-индексов максимальное количество — 1."

#: ../doc/1.7/book/box/limitations.rst:16
msgid "**Number of indexes in a space**"
msgstr "**Количество индексов в спейсе**"

#: ../doc/1.7/book/box/limitations.rst:18
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr "128 (``box.schema.INDEX_MAX``)."

#: ../doc/1.7/book/box/limitations.rst:22
msgid "**Number of fields in a tuple**"
msgstr "**Количество полей в кортеже**"

#: ../doc/1.7/book/box/limitations.rst:24
msgid "The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The practical maximum is whatever is specified by the space's :ref:`field_count <box_space-field_count>` member, or the maximal tuple length."
msgstr "Теоретически максимальное количество составляет 2 147 483 647 полей (``box.schema.FIELD_MAX``). Практически максимальное количество указано в поле :ref:`field_count <box_space-field_count>` спейса или соответствует максимальной длине кортежа."

#: ../doc/1.7/book/box/limitations.rst:31
msgid "**Number of bytes in a tuple**"
msgstr "**Количество байтов в кортеже**"

#: ../doc/1.7/book/box/limitations.rst:33
msgid "The maximal number of bytes in a tuple is roughly equal to :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (with a metadata overhead of about 20 bytes per tuple, which is added on top of useful bytes). By default, the value of either ``memtx_max_tuple_size`` or ``vinyl_max_tuple_size`` is 1,048,576. To increase it, specify a larger value when starting the Tarantool instance. For example, ``box.cfg{memtx_max_tuple_size=2*1048576}``."
msgstr "Максимальное количество байтов в кортеже примерно равно :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` или :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (с ресурсами метаданных около 20 байтов на кортеж, которые добавляются к полезным байтам). Значение ``memtx_max_tuple_size`` или ``vinyl_max_tuple_size`` по умолчанию составляет 1 048 576. Чтобы его увеличить, укажите большее значение при запуске экземпляра Tarantool'а. Например, ``box.cfg{memtx_max_tuple_size=2*1048576}``."

#: ../doc/1.7/book/box/limitations.rst:45
msgid "**Number of bytes in an index key**"
msgstr "**Количество байтов в индекс-ключе**"

#: ../doc/1.7/book/box/limitations.rst:47
msgid "If a field in a tuple can contain a million bytes, then the index key can contain a million bytes, so the maximum is determined by factors such as :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the index support."
msgstr "Если поле в кортеже может содержать миллион байтов, то индекс-ключ может содержать миллион байтов, поэтому максимальное количество определяется такими факторами, как :ref:`количество байтов в кортеже <limitations_bytes_in_tuple>`, а не параметрами индекса."

#: ../doc/1.7/book/box/limitations.rst:54
msgid "**Number of spaces**"
msgstr "**Количество спейсов**"

#: ../doc/1.7/book/box/limitations.rst:56
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``) but the practical maximum is around 65,000."
msgstr "Теоретически максимальное количество составляет 2 147 483 647 (``box.schema.SPACE_MAX``), но практически максимальное количество — около 65 000."

#: ../doc/1.7/book/box/limitations.rst:61
msgid "**Number of connections**"
msgstr "**Количество соединений**"

#: ../doc/1.7/book/box/limitations.rst:63
msgid "The practical limit is the number of file descriptors that one can set with the operating system."
msgstr "Практически пределом является количество файловых дескрипторов, которые можно определить с операционной системой."

#: ../doc/1.7/book/box/limitations.rst:68
msgid "**Space size**"
msgstr "**Размер спейса**"

#: ../doc/1.7/book/box/limitations.rst:70
msgid "The total maximum size for all spaces is in effect set by :ref:`memtx_memory <cfg_storage-memtx_memory>`, which in turn is limited by the total available memory."
msgstr "Итоговый максимальный размер всех спейсов фактически определяется в :ref:`memtx_memory <cfg_storage-memtx_memory>`, который в свою очередь ограничен общим размером свободной памяти."

#: ../doc/1.7/book/box/limitations.rst:76
msgid "**Update operations count**"
msgstr "**Число операций обновления**"

#: ../doc/1.7/book/box/limitations.rst:78
msgid "The maximum number of operations that can be in a single update is 4000 (``BOX_UPDATE_OP_CNT_MAX``)."
msgstr "Максимальное количество операций, возможное в рамках одного обновления, составляет 4000 (``BOX_UPDATE_OP_CNT_MAX``)."

#: ../doc/1.7/book/box/limitations.rst:83
msgid "**Number of users and roles**"
msgstr "**Количество пользователей и ролей**"

#: ../doc/1.7/book/box/limitations.rst:85
msgid "32 (``BOX_USER_MAX``)."
msgstr "32 (``BOX_USER_MAX``)."

#: ../doc/1.7/book/box/limitations.rst:89
msgid "**Length of an index name or space name or user name**"
msgstr "**Длина имени индекса, имени спейса или имени пользователя**"

#: ../doc/1.7/book/box/limitations.rst:91
msgid "65000 (``box.schema.NAME_MAX``)."
msgstr "65000 (``box.schema.NAME_MAX``)."

#: ../doc/1.7/book/box/limitations.rst:95
msgid "**Number of replicas in a replica set**"
msgstr "**Количество реплик в наборе реплик**"

#: ../doc/1.7/book/box/limitations.rst:97
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr "32 (``box.schema.REPLICA_MAX``)."

#: ../doc/1.7/book/box/triggers.rst:6
msgid "Triggers"
msgstr "Триггеры"

#: ../doc/1.7/book/box/triggers.rst:8
msgid "**Triggers**, also known as **callbacks**, are functions which the server executes when certain events happen."
msgstr "**Триггеры**, которые также называют **обратными вызовами**, представляют собой функции, которые выполняет сервер при наступлении определенных событий."

#: ../doc/1.7/book/box/triggers.rst:11
msgid "There are three types of triggers in Tarantool:"
msgstr "В Tarantool'е есть три типа триггеров:"

#: ../doc/1.7/book/box/triggers.rst:13
msgid ":ref:`connection triggers <box_session-on_connect>`, which are executed when a session begins or ends,"
msgstr ":ref:`триггеры для обработки соединений <box_session-on_connect>`, которые выполняются, когда начинается или заканчивается сессия,"

#: ../doc/1.7/book/box/triggers.rst:16
msgid ":ref:`authentication triggers <box_session-on_auth>`, which are executed during authentication, and"
msgstr ":ref:`триггеры для обработки аутентификации <box_session-on_auth>`, которые выполняются при аутентификации, и"

#: ../doc/1.7/book/box/triggers.rst:19
msgid ":ref:`replace triggers <box_space-on_replace>`, which are for database events."
msgstr ":ref:`триггеры для обработки замены <box_space-on_replace>`, которые предназначены для событий в базе данных."

#: ../doc/1.7/book/box/triggers.rst:22
msgid "All triggers have the following characteristics:"
msgstr "У всех триггеров есть следующие особенности:"

#: ../doc/1.7/book/box/triggers.rst:24
msgid "Triggers associate a function with an event. The request to \"define a trigger\" implies passing the trigger’s function to one of the \"on_event()\" functions: :ref:`box.session.on_connect() <box_session-on_connect>`, :ref:`box.session.on_auth() <box_session-on_auth>`, :ref:`box.session.on_disconnect() <box_session-on_disconnect>`, or :ref:`space_object:on_replace() <box_space-on_replace>` plus :ref:`space_object:before_replace() <box_space-before_replace>`."
msgstr "Триггеры связывают функцию с событием. Запрос \"определения триггера\" подразумевает передачу триггерной функции в одну из функций обработки событий \"on_event()\": :ref:`box.session.on_connect() <box_session-on_connect>`, :ref:`box.session.on_auth() <box_session-on_auth>`, :ref:`box.session.on_disconnect() <box_session-on_disconnect>` или :ref:`space_object:on_replace() <box_space-on_replace>` плюс :ref:`space_object:before_replace() <box_space-before_replace>`."

#: ../doc/1.7/book/box/triggers.rst:33
msgid "Triggers are defined only by the :ref:`'admin' user <authentication-owners_privileges>`."
msgstr "Только :ref:`пользователь 'admin' <authentication-owners_privileges>` определяет триггеры."

#: ../doc/1.7/book/box/triggers.rst:35
msgid "Triggers are stored in the Tarantool instance's memory, not in the database. Therefore triggers disappear when the instance is shut down. To make them permanent, put function definitions and trigger settings into Tarantool's :ref:`initialization script <index-init_label>`."
msgstr "Триггеры хранятся в памяти экземпляра Tarantool'а, а не в базе данных. Поэтому триггеры пропадают, когда экземпляр отключают. Чтобы сохранить их, поместите определения функции и настройки триггера в :ref:`скрипт инициализации <index-init_label>` Tarantool'а."

#: ../doc/1.7/book/box/triggers.rst:40
msgid "Triggers have low overhead. If a trigger is not defined, then the overhead is minimal: merely a pointer dereference and check. If a trigger is defined, then its overhead is equivalent to the overhead of calling a function."
msgstr "Триггеры не приводят к высокой затрате ресурсов. Если триггер не определен, то затрата ресурсов минимальна: только разыменование указателя и проверка. Если триггер определен, то затрата ресурсов аналогична вызову функции."

#: ../doc/1.7/book/box/triggers.rst:44
msgid "There can be multiple triggers for one event. In this case, triggers are executed in the reverse order that they were defined in."
msgstr "Для одного события можно определить несколько триггеров. В таком случае триггеры выполняются в обратном порядке относительно того, как их определили."

#: ../doc/1.7/book/box/triggers.rst:47
msgid "Triggers must work within the event context. However, effects are undefined if a function contains requests which normally could not occur immediately after the event, but only before the return from the event. For example, putting `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or :ref:`box.rollback() <box-rollback>` in a trigger function would be bringing in requests outside the event context."
msgstr "Триггеры должны работать в контексте события. Однако результат не определен, если функция содержит запросы, которые при нормальных условиях не могут быть выполнены непосредственно после события, а только после возврата из события. Например, если указать `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ или :ref:`box.rollback() <box-rollback>` в триггерной функции, запросы не будут выполняться в контексте события."

#: ../doc/1.7/book/box/triggers.rst:54
msgid "Triggers are replaceable. The request to \"redefine a trigger\" implies passing a new trigger function and an old trigger function to one of the \"on_event()\" functions."
msgstr "Триггеры можно заменять. Запрос на \"замену триггера\" подразумевает передачу новой триггерной функции и старой триггерной функции в одну из функций обработки событий \"on_event()\"."

#: ../doc/1.7/book/box/triggers.rst:58
msgid "The \"on_event()\" functions all have parameters which are function pointers, and they all return function pointers. Remember that a Lua function definition such as \"function f() x = x + 1 end\" is the same as \"f = function () x = x + 1 end\" -- in both cases ``f`` gets a function pointer. And \"trigger = box.session.on_connect(f)\" is the same as \"trigger = box.session.on_connect(function () x = x + 1 end)\" -- in both cases ``trigger`` gets the function pointer which was passed."
msgstr "Во всех функциях обработки событий \"on_event()\" есть параметры, которые представляют собой указатели функции, и все они возвращают указатели функции. Следует запомнить, что определение Lua-функции, например, \"function f() x = x + 1 end\" совпадает с \"f = function () x = x + 1 end\" — в обоих случаях ``f`` получит указатель функции. А \"trigger = box.session.on_connect(f)\" — это то же самое, что \"trigger = box.session.on_connect(function () x = x + 1 end)\" — в обоих случаях ``trigger`` получит переданный указатель функции."

#: ../doc/1.7/book/box/triggers.rst:66
msgid "To get a list of triggers, you can use:"
msgstr "Чтобы получить список триггеров, можно использовать следующее:"

#: ../doc/1.7/book/box/triggers.rst:68
msgid "on_connect() – with no arguments – to return a table of all connect-trigger functions;"
msgstr "on_connect() – без аргументов – чтобы вернуть таблицу со всеми триггерными функциями для обработки соединений;"

#: ../doc/1.7/book/box/triggers.rst:69
msgid "on_auth() to return all authentication-trigger functions;"
msgstr "on_auth(), чтобы вернуть все триггерные функции для обработки аутентификации;"

#: ../doc/1.7/book/box/triggers.rst:70
msgid "on_disconnect() to return all disconnect-trigger functions;"
msgstr "on_disconnect(), чтобы вернуть все триггерные функции для обработки отключений;"

#: ../doc/1.7/book/box/triggers.rst:71
msgid "on_replace() to return all replace-trigger functions made for on_replace()."
msgstr "on_replace(), чтобы вернуть все триггерные функции для обработки замены, сделанные для on_replace()."

#: ../doc/1.7/book/box/triggers.rst:72
msgid "before_replace() to return all replace-trigger functions made for before_replace()."
msgstr "before_replace(), чтобы вернуть все триггерные функции для обработки замены, сделанные для before_replace()."

#: ../doc/1.7/book/box/triggers.rst:76
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr "Здесь мы записываем события подключения и отключения в журнал на сервере Tarantool'а."

#: ../doc/1.7/book/box/triggers.rst:78
msgid ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""
"log = require('log')\n"
"       \n"
"       function on_connect_impl()\n"
"         log.info(\"connected \"..box.session.peer()..\", sid \"..box.session.id())\n"
"       end\n"
"       \n"
"       function on_disconnect_impl()\n"
"         log.info(\"disconnected, sid \"..box.session.id())\n"
"       end\n"
"       \n"
"       function on_auth_impl(user)\n"
"         log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"       end\n"
"       \n"
"       function on_connect() pcall(on_connect_impl) end\n"
"       function on_disconnect() pcall(on_disconnect_impl) end\n"
"       function on_auth(user) pcall(on_auth_impl, user) end\n"
"       \n"
"       box.session.on_connect(on_connect)\n"
"       box.session.on_disconnect(on_disconnect)\n"
"       box.session.on_auth(on_auth)"

#: ../doc/1.7/book/connectors/index.rst:5
msgid "Connectors"
msgstr "Коннекторы"

#: ../doc/1.7/book/connectors/index.rst:7
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../doc/1.7/book/connectors/index.rst:11
msgid "Protocol"
msgstr "Протокол"

#: ../doc/1.7/book/connectors/index.rst:13
msgid "Tarantool's binary protocol was designed with a focus on asynchronous I/O and easy integration with proxies. Each client request starts with a variable-length binary header, containing request id, request type, instance id, log sequence number, and so on."
msgstr "Бинарный протокол для передачи данных в Tarantool'е был разработан с учетом потребностей асинхронного ввода-вывода для облегчения интеграции с прокси-серверами. Каждый клиентский запрос начинается с бинарного заголовка переменной длины. В заголовке указывается идентификатор и тип запроса, идентификатор экземпляра, номер записи в журнале и т.д."

#: ../doc/1.7/book/connectors/index.rst:18
msgid "The mandatory length, present in request header simplifies client or proxy I/O. A response to a request is sent to the client as soon as it is ready. It always carries in its header the same type and id as in the request. The id makes it possible to match a request to a response, even if the latter arrived out of order."
msgstr "Также в заголовке обязательно указывается длина запроса, что облегчает обработку данных. Ответ на запрос посылается по мере готовности. В заголовке ответа указывается тот же идентификатор и тип запроса, что и в изначальном запросе. По идентификатору можно легко соотнести запрос с ответом, даже если ответ был получен не в порядке отсылки запросов."

#: ../doc/1.7/book/connectors/index.rst:24
msgid "Unless implementing a client driver, you needn't concern yourself with the complications of the binary protocol. Language-specific drivers provide a friendly way to store domain language data structures in Tarantool. A complete description of the binary protocol is maintained in annotated Backus-Naur form in the source tree: please see the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr "Вдаваться в тонкости реализации Tarantool-протокола нужно только при разработке нового коннектора для Tarantool'а — см. :ref:`полное описание бинарного протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде аннотированных BNF-диаграмм (Backus-Naur Form). В остальных случаях достаточно взять уже существующий коннектор для нужного вам языка программирования. Такие коннекторы позволяют легко хранить структуры данных из разных языков в формате Tarantool'а."

#: ../doc/1.7/book/connectors/index.rst:33
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../doc/1.7/book/connectors/index.rst:35
msgid "The Tarantool API exists so that a client program can send a request packet to a server instance, and receive a response. Here is an example of a what the client would send for ``box.space[513]:insert{'A', 'BB'}``. The BNF description of the components is on the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr "С помощью API Tarantool'а клиентские программы могут отправлять пакеты с запросами в адрес экземпляра и получать на них ответы. Вот пример для запроса :code:`box.space[513]:insert{'A', 'BB'}`. Описания компонентов запроса (в виде BNF-диаграмм) вы найдете на странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-iproto_protocol>`."

#: ../doc/1.7/book/connectors/index.rst:51
msgid "Component"
msgstr "Компонент"

#: ../doc/1.7/book/connectors/index.rst:51
msgid "Byte #0"
msgstr "Байт #0"

#: ../doc/1.7/book/connectors/index.rst:51
msgid "Byte #1"
msgstr "Байт #1"

#: ../doc/1.7/book/connectors/index.rst:51
msgid "Byte #2"
msgstr "Байт #2"

#: ../doc/1.7/book/connectors/index.rst:51
msgid "Byte #3"
msgstr "Байт #3"

#: ../doc/1.7/book/connectors/index.rst:53
msgid "code for insert"
msgstr "код для вставки"

#: ../doc/1.7/book/connectors/index.rst:53
#: ../doc/1.7/book/connectors/index.rst:57
msgid "02"
msgstr "02"

#: ../doc/1.7/book/connectors/index.rst:55
msgid "rest of header"
msgstr "остаток заголовка"

#: ../doc/1.7/book/connectors/index.rst:55
msgid "..."
msgstr "..."

#: ../doc/1.7/book/connectors/index.rst:57
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID спейса"

#: ../doc/1.7/book/connectors/index.rst:57
msgid "cd"
msgstr "cd"

#: ../doc/1.7/book/connectors/index.rst:57
msgid "01"
msgstr "01"

#: ../doc/1.7/book/connectors/index.rst:59
msgid "code for tuple"
msgstr "код для кортежа"

#: ../doc/1.7/book/connectors/index.rst:59
msgid "21"
msgstr "21"

#: ../doc/1.7/book/connectors/index.rst:61
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../doc/1.7/book/connectors/index.rst:61
msgid "92"
msgstr "92"

#: ../doc/1.7/book/connectors/index.rst:63
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../doc/1.7/book/connectors/index.rst:63
msgid "a1"
msgstr "a1"

#: ../doc/1.7/book/connectors/index.rst:63
msgid "41"
msgstr "41"

#: ../doc/1.7/book/connectors/index.rst:65
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../doc/1.7/book/connectors/index.rst:65
msgid "a2"
msgstr "a2"

#: ../doc/1.7/book/connectors/index.rst:65
msgid "42"
msgstr "42"

#: ../doc/1.7/book/connectors/index.rst:68
msgid "Now, you could send that packet to the Tarantool instance, and interpret the response (the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>` has a description of the packet format for responses as well as requests). But it would be easier, and less error-prone, if you could invoke a routine that formats the packet according to typed parameters. Something like ``response = tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is why APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr "Теперь получившийся пакет можно послать в адрес экземпляра Tarantool'а и затем расшифровать ответ (описания формата пакета ответов и вопросов вы найдете на той же странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-iproto_protocol>`). Но более простым и верным способом будет вызвать процедуру, которая сформирует готовый пакет с заданными параметрами. Что-то вроде ``response = tarantool_routine(\"insert\", 513, \"A\", \"B\");``. Для этого и существуют API для драйверов для Perl, Python, PHP и т.д."

#: ../doc/1.7/book/connectors/index.rst:81
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../doc/1.7/book/connectors/index.rst:83
msgid "This chapter has examples that show how to connect to a Tarantool instance via the Perl, PHP, Python, node.js, and C connectors. The examples contain hard code that will work if and only if the following conditions are met:"
msgstr "В этой главе приводятся примеры того, как можно установить соединение с Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python, node.js и C. Обратите внимание, что в примерах указаны фиксированные значения, поэтому для корректной работы всех примеров нужно соблюсти следующие условия:"

#: ../doc/1.7/book/connectors/index.rst:87
msgid "the Tarantool instance (tarantool) is running on localhost (127.0.0.1) and is listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr "экземпляр (Tarantool) запущен на локальной машине (``localhost = 127.0.0.1``),  а прослушивание для него настроено на порту 3301 (``box.cfg.listen = '3301'``),"

#: ../doc/1.7/book/connectors/index.rst:90
msgid "space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has a primary-key index for a numeric field (``box.space[999].index[0].parts[1].type = \"unsigned\"``),"
msgstr "в базе есть спейс``examples`` с идентификатором 999 (``box.space.examples.id = 999``), и у него есть первичный индекс, построенный по ключу числового типа (``box.space[999].index[0].parts[1].type = \"unsigned\"``),"

#: ../doc/1.7/book/connectors/index.rst:94
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены привилегии на чтение и запись."

#: ../doc/1.7/book/connectors/index.rst:96
msgid "It is easy to meet all the conditions by starting the instance and executing this script:"
msgstr "Можно легко соблюсти все условия, запустив экземпляр и выполнив следующий скрипт:"

#: ../doc/1.7/book/connectors/index.rst:99
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"        box.schema.space.create('examples',{id=999})\n"
"        box.space.examples:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"        box.schema.user.grant('guest','read,write','space','examples')\n"
"        box.schema.user.grant('guest','read','space','_space')"

#: ../doc/1.7/book/connectors/__java.rst:3
msgid "Java"
msgstr "Java"

#: ../doc/1.7/book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.7/book/connectors/__go.rst:3
msgid "Go"
msgstr "Go"

#: ../doc/1.7/book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../doc/1.7/book/connectors/__r.rst:3
msgid "R"
msgstr "R"

#: ../doc/1.7/book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../doc/1.7/book/connectors/__erlang.rst:3
msgid "Erlang"
msgstr "Erlang"

#: ../doc/1.7/book/connectors/__erlang.rst:5
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr "См. `Erlang-драйвер для Tarantool'а <https://github.com/stofel/taran>`_."

#: ../doc/1.7/book/connectors/__perl.rst:3
msgid "Perl"
msgstr "Perl"

#: ../doc/1.7/book/connectors/__perl.rst:5
msgid "The most commonly used Perl driver is `tarantool-perl <https://github.com/tarantool/tarantool-perl>`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is by cloning from GitHub."
msgstr "Самый используемый драйвер для Perl — `tarantool-perl <https://github.com/tarantool/tarantool-perl>`_. Он не входит в репозиторий Tarantool'а, его необходимо устанавливать отдельно. Проще всего установить его путем клонирования с GitHub."

#: ../doc/1.7/book/connectors/__perl.rst:10
msgid "To avoid minor warnings that may appear the first time ``tarantool-perl`` is installed, start with installing some other modules that ``tarantool-perl`` uses, with `CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia.org/wiki/Cpan>`_:"
msgstr "Во избежание незначительных предупреждений, которые может выдать система после первой установки ``tarantool-perl``, начните установку с некоторых других модулей, которые использует ``tarantool-perl``, с `CPAN, the Comprehensive Perl Archive Network (Всеобъемлющая сеть архивов Perl) <https://ru.wikipedia.org/wiki/CPAN>`_:"

#: ../doc/1.7/book/connectors/__perl.rst:14
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction"
msgstr ""
"$ sudo cpan install AnyEvent\n"
"      $ sudo cpan install Devel::GlobalDestruction"

#: ../doc/1.7/book/connectors/__perl.rst:19
msgid "Then, to install ``tarantool-perl`` itself, say:"
msgstr "Затем для установки самого ``tarantool-perl``, выполните:"

#: ../doc/1.7/book/connectors/__perl.rst:21
msgid ""
"$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-perl\n"
"$ cd tarantool-perl\n"
"$ git submodule init\n"
"$ git submodule update --recursive\n"
"$ perl Makefile.PL\n"
"$ make\n"
"$ sudo make install"
msgstr ""
"$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-perl\n"
"      $ cd tarantool-perl\n"
"      $ git submodule init\n"
"      $ git submodule update --recursive\n"
"      $ perl Makefile.PL\n"
"      $ make\n"
"      $ sudo make install"

#: ../doc/1.7/book/connectors/__perl.rst:31
msgid "Here is a complete Perl program that inserts ``[99999,'BB']`` into ``space[999]`` via the Perl API. Before trying to run, check that the server instance is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.pl` and say :samp:`perl example.pl`. The program will connect using an application-specific definition of the space. The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`space_object:INSERT<box_space-insert>` request, then — if all is well — end without displaying any messages. If Tarantool is not running on ``localhost`` with :ref:`listen<cfg_basic-listen>` port = 3301, the program will print “Connection refused”."
msgstr "Далее приводится пример полноценной программы на языке Perl, которая осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``space[999]`` с помощью API для языка Perl. Перед запуском проверьте, что у экземпляра задан порт для прослушивания на``localhost:3301``, и в базе создан спейс ``examples``, как :ref:`описано выше <index-connector_setting>`.  Чтобы запустить программу, сохраните код в файл с именем :file:`example.pl` и выполните команду :samp:`perl example.pl`. Программа установит соединение, используя определение спейса для этой цели, откроет сокет для соединения с экземпляром по ``localhost:3301``, пошлет запрос :ref:`space_object:INSERT<box_space-insert>`, а затем — если всё хорошо — закончит работу без каких-либо сообщений. Если Tarantool не запущен на ``localhost`` на :ref:`прослушивание<cfg_basic-listen>` по порту = 3301, то программа выдаст сообщение об ошибке “Connection refused”."

#: ../doc/1.7/book/connectors/__perl.rst:43
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. for 'guest' we do not also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is 'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"        use DR::Tarantool ':constant', 'tarantool';\n"
"        use DR::Tarantool ':all';\n"
"        use DR::Tarantool::MsgPack::SyncClient;\n"
"        \n"
"        my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"          host    => '127.0.0.1',                      # поиск Tarantool-сервера по адресу localhost\n"
"          port    => 3301,                             # на порту 3301\n"
"          user    => 'guest',                          # имя пользователя; здесь же можно добавить 'password=>...'\n"
"        \n"
"          spaces  => {\n"
"            999 => {                                   # определение спейса  space[999] ...\n"
"              name => 'examples',                      # имя спейса space[999] = 'examples'\n"
"              default_type => 'STR',                   # если тип поля в space[999] не задан, то = 'STR'\n"
"              fields => [ {                            # определение полей в спейсе space[999] ...\n"
"                  name => 'field1', type => 'NUM' } ], # имя поля space[999].field[1]='field1', тип ='NUM'\n"
"              indexes => {                             # определение индексов спейса space[999] ...\n"
"                0 => {\n"
"                  name => 'primary', fields => [ 'field1' ] } } } } );\n"
"        \n"
"        $tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../doc/1.7/book/connectors/__perl.rst:67
msgid "The example program uses field type names 'STR' and 'NUM' instead of :ref:`'string' and 'unsigned'<box_space-create_index>`, due to a temporary Perl limitation."
msgstr "Из-за временных ограничений в языке Perl, вместо полей типа :ref:`'string' и 'unsigned'<box_space-create_index>` в тестовой программе указаны поля типа 'STR' и 'NUM'."

#: ../doc/1.7/book/connectors/__perl.rst:70
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see the `tarantool-perl repository <https://github.com/tarantool/tarantool-perl>`_."
msgstr "В этой программе мы привели пример использования лишь одного запроса. Для полноценной работы с Tarantool'ом обратитесь к документации из `репозитория tarantool-perl <https://github.com/tarantool/tarantool-perl>`_."

#: ../doc/1.7/book/connectors/__php.rst:3
msgid "PHP"
msgstr "PHP"

#: ../doc/1.7/book/connectors/__php.rst:5
msgid "The most commonly used PHP driver is `tarantool-php <https://github.com/tarantool/tarantool-php>`_. It is not supplied as part of the Tarantool repository; it must be installed separately, for example with :program:`git`. See `installation instructions <https://github.com/tarantool/tarantool-php/blob/master/#installing-and-building>`_. in the driver's :file:`README` file."
msgstr "Самый используемый драйвер для PHP — `tarantool-php <https://github.com/tarantool/tarantool-php>`_. Он не входит в репозиторий Tarantool'а, его необходимо устанавливать отдельно, например, вместе с :program:`git`. `Инструкции по установке <https://github.com/tarantool/tarantool-php/blob/master/#installing-and-building>`_ см. в файле :file:`README`."

#: ../doc/1.7/book/connectors/__php.rst:12
msgid "Here is a complete PHP program that inserts ``[99999,'BB']`` into a space named ``examples`` via the PHP API. Before trying to run, check that the server instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.php` and say ``php -d extension=~/tarantool-php/modules/tarantool.so example.php``. The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`INSERT<box_space-insert>` request, then — if all is well — print \"Insert succeeded\". If the tuple already exists, the program will print “Duplicate key exists in unique index 'primary' in space 'examples'”."
msgstr "Далее приводится пример полноценной программы на языке PHP, которая осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``examples``  с помощью API для языка PHP. Перед запуском проверьте, что у экземпляра задан порт для :ref:`прослушивания <cfg_basic-listen>`на``localhost:3301``, и в базе создан спейс ``examples``, как :ref:`описано выше <index-connector_setting>`. Чтобы запустить программу, сохраните код в файл с именем :file:`example.php` и выполните команду ``php -d extension=~/tarantool-php/modules/tarantool.so example.php``. Программа откроет сокет для соединения с экземпляром по ``localhost:3301``, пошлет :ref:`INSERT-запрос<box_space-insert>`, а затем — если всё хорошо — выдаст сообщение \"Insert succeeded\". Если такой кортеж уже существует, то программа выдаст сообщение об ошибке “Duplicate key exists in unique index 'primary' in space 'examples'”."

#: ../doc/1.7/book/connectors/__php.rst:23
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"      $tarantool = new Tarantool('localhost', 3301);\n"
"      \n"
"      try {\n"
"          $tarantool->insert('examples', array(99999, 'BB'));\n"
"          echo \"Insert succeeded\\n\";\n"
"      } catch (Exception $e) {\n"
"          echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"      }"

#: ../doc/1.7/book/connectors/__php.rst:35
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `tarantool/tarantool-php <https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr "В этой программе мы привели пример использования лишь одного запроса. Для полноценной работы с Tarantool'ом обратитесь к документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/tarantool-php>`_."

#: ../doc/1.7/book/connectors/__php.rst:40
msgid "Besides, you can use an alternative PHP driver from another GitHub project: it includes a *client* (see `tarantool-php/client <https://github.com/tarantool-php/client>`_) and a *mapper* for that client (see `tarantool-php/mapper <https://github.com/tarantool-php/mapper>`_)."
msgstr "Кроме того, можно использовать иной драйвер для PHP из другого проекта на GitHub: он включает в себя *клиент* (см.`tarantool-php/client <https://github.com/tarantool-php/client>`_) и a *преобразователь* для этого клиента (см. `tarantool-php/mapper <https://github.com/tarantool-php/mapper>`_)."

#: ../doc/1.7/book/connectors/__python.rst:3
msgid "Python"
msgstr "Python"

#: ../doc/1.7/book/connectors/__python.rst:5
msgid "Here is a complete Python program that inserts ``[99999,'Value','Value']`` into space ``examples`` via the high-level Python API."
msgstr "Далее приводится пример полноценной программы на языке Python, которая осуществляет вставку ``[99999,'Value','Value']`` в спейс ``examples`` с помощью высокоуровневого API для языка Python. "

#: ../doc/1.7/book/connectors/__python.rst:8
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"      from tarantool import Connection\n"
"      \n"
"      c = Connection(\"127.0.0.1\", 3301)\n"
"      result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"      print result"

#: ../doc/1.7/book/connectors/__python.rst:17
msgid "To prepare, paste the code into a file named :file:`example.py` and install the ``tarantool-python`` connector with either :samp:`pip install tarantool\\>0.4` to install in :file:`/usr` (requires **root** privilege) or :samp:`pip install tarantool\\>0.4 --user` to install in :file:`~` i.e. user's default directory. Before trying to run, check that the server instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :samp:`python example.py`. The program will connect to the Tarantool server, will send the :ref:`INSERT<box_space-insert>` request, and will not throw any exception if all went well. If the tuple already exists, the program will throw ``tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space 'examples'\")``."
msgstr "Для подготовки сохраните код в файл с именем :file:`example.py` и установите коннектор ``tarantool-python``. Для установки коннектора воспользуйтесь либо командой samp:`pip install tarantool\\>0.4` для установки в директорию :file:`/usr` (потребуются права уровня  **root**), либо командой :samp:`pip install tarantool\\>0.4 —user` для установки в директорию :file:`~`, т.е. в используемую по умолчанию директорию текущего пользователя. Перед запуском проверьте, что у экземпляра задан порт для :ref:`прослушивания <cfg_basic-listen>`на``localhost:3301``, и в базе создан спейс ``examples``, как :ref:`описано выше <index-connector_setting>`. Чтобы запустить программу, выполните команду :samp:`python example.py`. Программа установит соединение с Tarantool-сервером, пошлет :ref:`INSERT-запрос <box_space-insert>` и не выбросит никакого исключения, если всё прошло хорошо. Если такой кортеж уже существует, то программа выбросит исключение ``tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space 'examples'\")``."

#: ../doc/1.7/book/connectors/__python.rst:29
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `tarantool-python <http://github.com/tarantool/tarantool-python>`_ project at GitHub. For an example of using Python API with `queue managers for Tarantool <https://github.com/tarantool/queue>`_, see `queue-python <https://github.com/tarantool/queue-python>`_ project at GitHub."
msgstr "В этой программе мы привели пример использования лишь одного запроса. Для полноценной работы с Tarantool'ом обратитесь к документации из `проекта tarantool-python на GitHub <http://github.com/tarantool/tarantool-python>`_. А на странице `проекта queue-python на GitHub <https://github.com/tarantool/queue-python>`_ вы сможете найти примеры использования Python API для работы с `очередями сообщений в Tarantool'е <https://github.com/tarantool/queue>`_."

#: ../doc/1.7/book/connectors/__nodejs.rst:3
msgid "Node.js"
msgstr "Node.js"

#: ../doc/1.7/book/connectors/__nodejs.rst:5
msgid "The most commonly used node.js driver is the `Node Tarantool driver <https://github.com/KlonD90/node-tarantool-driver>`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is with `npm <https://www.sitepoint.com/beginners-guide-node-package-manager/>`_. For example, on Ubuntu, the installation could look like this after npm has been installed:"
msgstr "Самый используемый драйвер для node.js — `Node Tarantool driver <https://github.com/KlonD90/node-tarantool-driver>`_. Он не входит в репозиторий Tarantool'а, его необходимо устанавливать отдельно. Проще всего установить его вместе с `npm <https://www.sitepoint.com/beginners-guide-node-package-manager/>`_. Например, на Ubuntu, когда npm уже установлен, установка драйвера будет выглядеть следующим образом:"

#: ../doc/1.7/book/connectors/__nodejs.rst:13
msgid "$ npm install tarantool-driver --global"
msgstr "$ npm install tarantool-driver --global"

#: ../doc/1.7/book/connectors/__nodejs.rst:17
msgid "Here is a complete node.js program that inserts ``[99999,'BB']`` into ``space[999]`` via the node.js API. Before trying to run, check that the server instance is :ref:`listening<cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.rs` and say ``node example.rs``. The program will connect using an application-specific definition of the space. The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`INSERT<box_space-insert>` request, then — if all is well — end after saying \"Insert succeeded\". If Tarantool is not running on ``localhost`` with listen port = 3301, the program will print “Connect failed”. If :ref:`user 'guest' user<box_space-user>` does not have authorization to connect, the program will print \"Auth failed\". If the insert request fails for any reason, for example because the tuple already exists, the program will print \"Insert failed\"."
msgstr "Далее приводится пример полноценной программы на языке node.js, которая осуществляет вставку кортежа ``[99999,'BB']`` в спейс ``space[999]`` с помощью API для языка node.js. Перед запуском проверьте, что у экземпляра задан порт для :ref:`прослушивания <cfg_basic-listen>`на``localhost:3301``, и в базе создан спейс ``examples``, как :ref:`описано выше <index-connector_setting>`. Чтобы запустить программу, сохраните код в файл с именем :file:`example.rs` и выполните команду ``node example.rs``. Программа установит соединение, используя определение спейса для этой цели, откроет сокет для соединения с экземпляром по ``localhost:3301``, отправит :ref:`INSERT-запрос <box_space-insert>`, а затем — если всё хорошо — выдаст сообщение \"Insert succeeded\". Если Tarantool не запущен на ``localhost`` на прослушивание по порту = 3301, то программа выдаст сообщение об ошибке “Connect failed”. Если у :ref:`пользователя 'guest' <box_space-user>` нет прав на соединение, программа выдаст сообщение об ошибке \"Auth failed\". Если запрос вставки по какой-либо причине не сработает, например поскольку такой кортеж уже существует, то программа выдаст сообщение об ошибке \"Insert failed\"."

#: ../doc/1.7/book/connectors/__nodejs.rst:31
msgid ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); });\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); });\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""
"var TarantoolConnection = require('tarantool-driver');\n"
"      var conn = new TarantoolConnection({port: 3301});\n"
"      var insertTuple = [99999, \"BB\"];\n"
"      conn.connect().then(function() {\n"
"          conn.auth(\"guest\", \"\").then(function() {\n"
"              conn.insert(999, insertTuple).then(function() {\n"
"                  console.log(\"Insert succeeded\");\n"
"                  process.exit(0);\n"
"          }, function(e) { console.log(\"Insert failed\");  process.exit(1); });\n"
"          }, function(e) { console.log(\"Auth failed\");    process.exit(1); });\n"
"          }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"

#: ../doc/1.7/book/connectors/__nodejs.rst:45
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see  `The node.js driver repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr "В этой программе мы привели пример использования лишь одного запроса. Для полноценной работы с Tarantool'ом обратитесь к документации из `репозитория драйвера для node.js <https://github.com/KlonD90/node-tarantool-driver>`_."

#: ../doc/1.7/book/connectors/__csharp.rst:3
msgid "C#"
msgstr "C#"

#: ../doc/1.7/book/connectors/__csharp.rst:5
msgid "The most commonly used C# driver is `progaudi.tarantool <https://github.com/progaudi/progaudi.tarantool>`_, previously named ``tarantool-csharp``. It is not supplied as part of the Tarantool repository; it must be installed separately. The makers recommend `cross-platform installation using Nuget <https://www.nuget.org/packages/progaudi.tarantool>`_."
msgstr "Самый используемый драйвер для C# — `progaudi.tarantool <https://github.com/progaudi/progaudi.tarantool>`_, который раньше назывался ``tarantool-csharp``. Он не входит в репозиторий Tarantool'а, его необходимо устанавливать отдельно. Создатели драйвера рекомендуют `кроссплатформенную установку с помощью Nuget <https://www.nuget.org/packages/progaudi.tarantool>`_."

#: ../doc/1.7/book/connectors/__csharp.rst:11
msgid "To be consistent with the other instructions in this chapter, here is a way to install the driver directly on Ubuntu 16.04."
msgstr "Чтобы придерживаться метода оформления других инструкций в данной главе, дадим описание способа установки драйвера напрямую на 16.04."

#: ../doc/1.7/book/connectors/__csharp.rst:14
msgid "Install .net core from Microsoft. Follow `.net core installation instructions <https://www.microsoft.com/net/core#ubuntu>`_."
msgstr "Установите среду .NET Core от Microsoft. Следуйте `инструкциям по установке .NET Core <https://www.microsoft.com/net/core#ubuntu>`_."

#: ../doc/1.7/book/connectors/__csharp.rst:19
msgid "Mono will not work, nor will .Net from xbuild. Only .net core supported on Linux and Mac."
msgstr "Mono не сработает, как не сработает и .Net от xbuild. Только .NET Core поддерживается на Linux и Mac."

#: ../doc/1.7/book/connectors/__csharp.rst:21
msgid "Read the Microsoft End User License Agreement first, because it is not an ordinary open-source agreement and there will be a message during installation saying \"This software may collect information about you and your use of the software, and send that to Microsoft.\" Still you can `set environment variables <https://docs.microsoft.com/en-us/dotnet/core/tools/telemetry#behavior>`_ to opt out from telemetry."
msgstr "Сначала прочитайте Условия лицензионного соглашения с Microsoft, поскольку оно не похоже на обычные соглашения для ПО с открытым кодом, и во время установки система выдаст сообщение о том, что ПО может собирать информацию (\"This software may collect information about you and your use of the software, and send that to Microsoft.\"). Несмотря на это, можно `определить переменные окружения  <https://docs.microsoft.com/en-us/dotnet/core/tools/telemetry#behavior>`_, чтобы отказаться от участия в сборе телеметрических данных."

#: ../doc/1.7/book/connectors/__csharp.rst:29
msgid "Create a new console project."
msgstr "Создайте новый консольный проект."

#: ../doc/1.7/book/connectors/__csharp.rst:31
msgid ""
"$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"
msgstr ""
"$ cd ~\n"
"      $ mkdir progaudi.tarantool.test\n"
"      $ cd progaudi.tarantool.test\n"
"      $ dotnet new console"

#: ../doc/1.7/book/connectors/__csharp.rst:38
msgid "Add ``progaudi.tarantool`` reference."
msgstr "Добавьте ссылку на ``progaudi.tarantool``."

#: ../doc/1.7/book/connectors/__csharp.rst:40
msgid "$ dotnet add package progaudi.tarantool"
msgstr "$ dotnet add package progaudi.tarantool"

#: ../doc/1.7/book/connectors/__csharp.rst:44
msgid "Change code in ``Program.cs``."
msgstr "Измените код в ``Program.cs``."

#: ../doc/1.7/book/connectors/__csharp.rst:46
msgid ""
"$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"
msgstr ""
"$ cat <<EOT > Program.cs\n"
"      using System;\n"
"      using System.Threading.Tasks;\n"
"      using ProGaudi.Tarantool.Client;\n"
"      \n"
"      public class HelloWorld\n"
"      {\n"
"        static public void Main ()\n"
"        {\n"
"          Test().GetAwaiter().GetResult();\n"
"        }\n"
"        static async Task Test()\n"
"        {\n"
"          var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"          var schema = box.GetSchema();\n"
"          var space = await schema.GetSpace(\"examples\");\n"
"          await space.Insert((99999, \"BB\"));\n"
"        }\n"
"      }\n"
"      EOT"

#: ../doc/1.7/book/connectors/__csharp.rst:69
msgid "Build and run your application."
msgstr "Соберите и запустите приложение."

#: ../doc/1.7/book/connectors/__csharp.rst:71
msgid "Before trying to run, check that the server is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`."
msgstr "Перед запуском проверьте, что у экземпляра задан порт для прослушивания на``localhost:3301``, и в базе создан спейс ``examples``, как :ref:`описано выше <index-connector_setting>`."

#: ../doc/1.7/book/connectors/__csharp.rst:75
msgid ""
"$ dotnet restore\n"
"$ dotnet run"
msgstr ""
"$ dotnet restore\n"
"      $ dotnet run"

#: ../doc/1.7/book/connectors/__csharp.rst:80
msgid "The program will:"
msgstr "Программа:"

#: ../doc/1.7/book/connectors/__csharp.rst:82
msgid "connect using an application-specific definition of the space,"
msgstr "установит соединение, используя определение спейса для этой цели,"

#: ../doc/1.7/book/connectors/__csharp.rst:83
msgid "open a socket connection with the Tarantool server at `localhost:3301`,"
msgstr "откроет сокет для соединения с экземпляром по ``localhost:3301``,"

#: ../doc/1.7/book/connectors/__csharp.rst:84
msgid "send an INSERT request, and — if all is well — end without saying anything."
msgstr "отправит INSERT-запрос, а затем — если всё хорошо — закончит работу без каких-либо сообщений."

#: ../doc/1.7/book/connectors/__csharp.rst:86
msgid "If Tarantool is not running on localhost with listen port = 3301, or if user 'guest' does not have authorization to connect, or if the INSERT request fails for any reason, the program will print an error message, among other things (stacktrace, etc)."
msgstr "Если Tarantool не запущен на ``localhost`` на прослушивание по порту 3301, или у пользователя 'guest' нет прав на соединение, или запрос вставки по какой-либо причине не сработает, то программа выдаст сообщение об ошибке и другую информацию (трассировку стека и т.д.)."

#: ../doc/1.7/book/connectors/__csharp.rst:91
msgid "The example program only shows one request and does not show all that’s necessary for good practice. For that, please see the `progaudi.tarantool driver repository <https://github.com/progaudi/progaudi.tarantool>`_."
msgstr "В этой программе мы привели пример использования лишь одного запроса. Для  полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/tarantool-php>`_."

#: ../doc/1.7/book/connectors/__c.rst:3
msgid "C"
msgstr "C"

#: ../doc/1.7/book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr "В этом разделе даны два примера использования высокоуровневого API для Tarantool'а и языка C."

#: ../doc/1.7/book/connectors/__c.rst:9
msgid "Example 1"
msgstr "Пример 1"

#: ../doc/1.7/book/connectors/__c.rst:11
msgid "Here is a complete C program that inserts :code:`[99999,'B']` into space :code:`examples` via the high-level C API."
msgstr "Далее приводится пример полноценной программы на языке C, которая осуществляет вставку кортежа ``[99999,'B']`` в спейс :code:`examples` с помощью высокоуровневого API для языка C. "

#: ../doc/1.7/book/connectors/__c.rst:14
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"        #include <stdlib.h>\n"
"        \n"
"        #include <tarantool/tarantool.h>\n"
"        #include <tarantool/tnt_net.h>\n"
"        #include <tarantool/tnt_opt.h>\n"
"        \n"
"        void main() {\n"
"           struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = НАСТРОЙКА */\n"
"           tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"           if (tnt_connect(tnt) < 0) {                      /* См. ниже = СОЕДИНЕНИЕ */\n"
"               printf(\"Connection refused\\n\");\n"
"               exit(-1);\n"
"           }\n"
"           struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = СОЗДАНИЕ ЗАПРОСА */\n"
"           tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"           tnt_insert(tnt, 999, tuple);                     /* См. ниже = ОТПРАВКА ЗАПРОСА */\n"
"           tnt_flush(tnt);\n"
"           struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = ПОЛУЧЕНИЕ ОТВЕТА */\n"
"           tnt->read_reply(tnt, &reply);\n"
"           if (reply.code != 0) {\n"
"               printf(\"Insert failed %lu.\\n\", reply.code);\n"
"           }\n"
"           tnt_close(tnt);                                  /* См. ниже = ЗАВЕРШЕНИЕ */\n"
"           tnt_stream_free(tuple);\n"
"           tnt_stream_free(tnt);\n"
"        }"

#: ../doc/1.7/book/connectors/__c.rst:44
msgid "Paste the code into a file named :file:`example.c` and install ``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr "Скопируйте исходный код программы в файл с именем :file:`example.c` и установите коннектор ``tarantool-c``. Вот один из способов установки ``tarantool-c`` (под Ubuntu):"

#: ../doc/1.7/book/connectors/__c.rst:47
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"        $ cd ~/tarantool-c\n"
"        $ git submodule init\n"
"        $ git submodule update\n"
"        $ cmake .\n"
"        $ make\n"
"        $ make install"

#: ../doc/1.7/book/connectors/__c.rst:57 ../doc/1.7/book/connectors/__c.rst:282
msgid "To compile and link the program, say:"
msgstr "Чтобы скомпилировать и слинковать тестовую программу, выполните следующую  команду:"

#: ../doc/1.7/book/connectors/__c.rst:59
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"        $ export LD_LIBRARY_PATH=/usr/local/lib\n"
"        $ gcc -o example example.c -ltarantool"

#: ../doc/1.7/book/connectors/__c.rst:65
msgid "Before trying to run, check that a server instance is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :samp:`./example`. The program will connect to the Tarantool instance, and will send the request. If Tarantool is not running on localhost with listen address = 3301, the program will print “Connection refused”. If the insert fails, the program will print \"Insert failed\" and an error number (see all error codes in the source file `/src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."
msgstr "Перед запуском проверьте, что у экземпляра задан порт для прослушивания на``localhost:3301``, и в базе создан спейс ``examples``, как :ref:`описано выше <index-connector_setting>`. Чтобы запустить тестовую программу, выполните команду :samp:`./example`. Программа установит соединение с экземпляром и отправит запрос. Если Tarantool не запущен на localhost на прослушивание по порту 3301, то программа выдаст сообщение об ошибке “Connection refused”. Если вставка не сработает, программа выдаст сообщение об ошибке \"Insert failed\" и код ошибки (все коды ошибок см. в исходном файле `/src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."

#: ../doc/1.7/book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr "Далее следуют примечания, на которые мы ссылались в комментариях к исходному коду тестовой программы."

#: ../doc/1.7/book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr "**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../doc/1.7/book/connectors/__c.rst:81
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"        tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../doc/1.7/book/connectors/__c.rst:86
msgid "In this program, the stream will be named ``tnt``. Before connecting on the ``tnt`` stream, some options may have to be set. The most important option is TNT_OPT_URI. In this program, the :ref:`URI <index-uri>` is ``localhost:3301``, since that is where the Tarantool instance is supposed to be :ref:`listening <cfg_basic-listen>`."
msgstr "В нашей программе поток назван ``tnt``. Перед установкой соединения с потоком ``tnt`` нужно задать ряд опций. Самая важная из них — TNT_OPT_URI. Для этой опции указан :ref:`URI <index-uri>` ``localhost:3301``, т.е. адрес, по которому должно быть настроено :ref:`прослушивание <cfg_basic-listen>`на стороне экземпляра Tarantool'а."

#: ../doc/1.7/book/connectors/__c.rst:92 ../doc/1.7/book/connectors/__c.rst:107
#: ../doc/1.7/book/connectors/__c.rst:134
#: ../doc/1.7/book/connectors/__c.rst:153
#: ../doc/1.7/book/connectors/__c.rst:177
#: ../doc/1.7/book/connectors/__c.rst:195
msgid "Function description:"
msgstr "Описание функции:"

#: ../doc/1.7/book/connectors/__c.rst:94
msgid ""
"struct tnt_stream *tnt_net(struct tnt_stream *s)\n"
"int tnt_set(struct tnt_stream *s, int option, variant option-value)"
msgstr ""
"struct tnt_stream *tnt_net(struct tnt_stream *s)\n"
"      int tnt_set(struct tnt_stream *s, int option, variant option-value)"

#: ../doc/1.7/book/connectors/__c.rst:99
msgid "**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a URI, this example program can connect to a server instance."
msgstr "**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали его с конкретным URI, наша программа может устанавливать соединение с экземпляром."

#: ../doc/1.7/book/connectors/__c.rst:102
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"           { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../doc/1.7/book/connectors/__c.rst:109
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr "int tnt_connect(struct tnt_stream \\*s)"

#: ../doc/1.7/book/connectors/__c.rst:113
msgid "The connection might fail for a variety of reasons, such as: the server is not running, or the URI contains an invalid :ref:`password<authentication-passwords>`. If the connection fails, the return value will be -1."
msgstr "Попытка соединения может и не удаться по разным причинам, например если Tarantool-сервер не запущен или в URI-строке указан неверный :ref:`пароль <authentication-passwords>`. В случае неудачи функция вернет -1."

#: ../doc/1.7/book/connectors/__c.rst:117
msgid "**MAKE REQUEST:** Most requests require passing a structured value, such as the contents of a tuple."
msgstr "**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать структурированные данные, например содержимое кортежа."

#: ../doc/1.7/book/connectors/__c.rst:120
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"        tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../doc/1.7/book/connectors/__c.rst:125
#, python-format
msgid "In this program, the request will be an :ref:`INSERT<box_space-insert>`, and the tuple contents will be an integer and a string. This is a simple serial set of values, that is, there are no sub-structures or arrays. Therefore it is easy in this case to format what will be passed using the same sort of arguments that one would use with a C ``printf()`` function: ``%d`` for the integer, ``%s`` for the string, then the integer value, then a pointer to the string value."
msgstr "В данной программе мы используем запрос :ref:`INSERT<box_space-insert>`, а кортеж содержит целое число и строку.  Это простой набор значений без каких-либо вложенных структур или массивов. И передаваемые значения мы можем указать самым простым образом — аналогично тому, как это сделано в стандартной C-функции ``printf()``: ``%d`` для обозначения целого числа, ``%s`` для обозначения строки, затем числовое значение, затем указатель на строковое значение."

#: ../doc/1.7/book/connectors/__c.rst:136
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"

#: ../doc/1.7/book/connectors/__c.rst:140
msgid "**SEND REQUEST:** The database-manipulation requests are analogous to the requests in the box library."
msgstr "**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе делается аналогично тому, как это делается в Tarantool-библиотеке ``box``."

#: ../doc/1.7/book/connectors/__c.rst:143
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"        tnt_flush(tnt);"

#: ../doc/1.7/book/connectors/__c.rst:148
msgid "In this program, the choice is to do an INSERT request, so the program passes the ``tnt_stream`` that was used for connection (``tnt``) and the ``tnt_stream`` that was set up with :c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr "В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем поток ``tnt``, который ранее использовали для установки соединения, и поток :code:`tuple`, который также ранее настроили с помощью функции :c:func:`tarantoolc:tnt_object_format`."

#: ../doc/1.7/book/connectors/__c.rst:155
msgid ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"        ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"        ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                           uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                           struct tnt_stream \\*key)\n"
"        ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                           struct tnt_stream \\*key, struct tnt_stream \\*ops)"

#: ../doc/1.7/book/connectors/__c.rst:165
msgid "**GET REPLY:** For most requests, the client will receive a reply containing some indication whether the result was successful, and a set of tuples."
msgstr "**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, который содержит информацию о том, был ли данный запрос успешно выполнен,  а также содержит набор кортежей."

#: ../doc/1.7/book/connectors/__c.rst:168
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"        tnt->read_reply(tnt, &reply);\n"
"        if (reply.code != 0)\n"
"           { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../doc/1.7/book/connectors/__c.rst:175
msgid "This program checks for success but does not decode the rest of the reply."
msgstr "Данная программа проверяет, был ли запрос выполнен успешно, но никак не интерпретирует оставшуюся часть ответа."

#: ../doc/1.7/book/connectors/__c.rst:179
msgid ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"        tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"        void tnt_reply_free(struct tnt_reply \\*r)"

#: ../doc/1.7/book/connectors/__c.rst:185
msgid "**TEARDOWN:** When a session ends, the connection that was made with :c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that were made in the setup should be destroyed."
msgstr "**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, созданное с помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить  объекты, созданные на этапе настройки."

#: ../doc/1.7/book/connectors/__c.rst:189
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"        tnt_stream_free(tuple);\n"
"        tnt_stream_free(tnt);"

#: ../doc/1.7/book/connectors/__c.rst:197
msgid ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""
"void tnt_close(struct tnt_stream \\*s)\n"
"        void tnt_stream_free(struct tnt_stream \\*s)"

#: ../doc/1.7/book/connectors/__c.rst:204
msgid "Example 2"
msgstr "Пример 2"

#: ../doc/1.7/book/connectors/__c.rst:206
msgid "Here is a complete C program that selects, using index key ``[99999]``, from space ``examples`` via the high-level C API. To display the results, the program uses functions in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library which allow decoding of `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_  arrays."
msgstr "Далее приводится еще один пример полноценной программы на языке C, которая осуществляет выборку по индекс-ключу ``[99999]`` из спейса ``examples`` с помощью высокоуровневого Tarantool API для языка C. Для вывода результатов в этой программе используются функции из библиотеки `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_. Эти функции нужны для декодирования массивов значений в формате `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/1.7/book/connectors/__c.rst:212
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"        #include <stdlib.h>\n"
"        #include <tarantool/tarantool.h>\n"
"        #include <tarantool/tnt_net.h>\n"
"        #include <tarantool/tnt_opt.h>\n"
"        \n"
"        #define MP_SOURCE 1\n"
"        #include <msgpuck.h>\n"
"        \n"
"        void main() {\n"
"            struct tnt_stream *tnt = tnt_net(NULL);\n"
"            tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"            if (tnt_connect(tnt) < 0) {\n"
"                printf(\"Connection refused\\n\");\n"
"                exit(1);\n"
"            }\n"
"            struct tnt_stream *tuple = tnt_object(NULL);\n"
"            tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для  поиска */\n"
"            tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"            tnt_flush(tnt);\n"
"            struct tnt_reply reply; tnt_reply_init(&reply);\n"
"            tnt->read_reply(tnt, &reply);\n"
"            if (reply.code != 0) {\n"
"                printf(\"Select failed.\\n\");\n"
"                exit(1);\n"
"            }\n"
"            char field_type;\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type != MP_ARRAY) {\n"
"                printf(\"no tuple array\\n\");\n"
"                exit(1);\n"
"            }\n"
"            long unsigned int row_count;\n"
"            uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"            printf(\"tuple count=%u\\n\", tuple_count);\n"
"            unsigned int i, j;\n"
"            for (i = 0; i < tuple_count; ++i) {\n"
"                field_type = mp_typeof(*reply.data);\n"
"                if (field_type != MP_ARRAY) {\n"
"                    printf(\"no field array\\n\");\n"
"                    exit(1);\n"
"                }\n"
"                uint32_t field_count = mp_decode_array(&reply.data);\n"
"                printf(\"  field count=%u\\n\", field_count);\n"
"                for (j = 0; j < field_count; ++j) {\n"
"                    field_type = mp_typeof(*reply.data);\n"
"                    if (field_type == MP_UINT) {\n"
"                        uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                        printf(\"    value=%lu.\\n\", num_value);\n"
"                    } else if (field_type == MP_STR) {\n"
"                        const char *str_value;\n"
"                        uint32_t str_value_length;\n"
"                        str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                        printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"                    } else {\n"
"                        printf(\"wrong field type\\n\");\n"
"                        exit(1);\n"
"                    }\n"
"                }\n"
"            }\n"
"            tnt_close(tnt);\n"
"            tnt_stream_free(tuple);\n"
"            tnt_stream_free(tnt);\n"
"        }"

#: ../doc/1.7/book/connectors/__c.rst:279
msgid "Similarly to the first example, paste the code into a file named :file:`example2.c`."
msgstr "Аналогично первому примеру, сохраните исходный код программы в файле с именем :file:`example2.c`."

#: ../doc/1.7/book/connectors/__c.rst:284
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../doc/1.7/book/connectors/__c.rst:288
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../doc/1.7/book/connectors/__c.rst:290
msgid "The two example programs only show a few requests and do not show all that's necessary for good practice. See more in the `tarantool-c documentation at GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr "В этих двух программах мы привели пример использования лишь двух запросов. Для полноценной работы с Tarantool'ом с помощью C API, пожалуйста, обратитесь к документации из `проекта tarantool-c на GitHub <http://github.com/tarantool/tarantool-c>`_."

#: ../doc/1.7/book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../doc/1.7/book/connectors/__results.rst:6
msgid "For all connectors, calling a function via Tarantool causes a return in the MsgPack format. If the function is called using the connector's API, some conversions may occur. All scalar values are returned as tuples (with a MsgPack type-identifier followed by a value); all non-scalar values are returned as a group of tuples (with a MsgPack array-identifier followed by the scalar values). If the function is called via the binary protocol command layer -- \"eval\" -- rather than via the connector's API, no conversions occur."
msgstr "При работе с любым Tarantool-коннектором функции, вызванные с помощью Tarantool'а, возвращают значения в формате MsgPack. Если функция была вызвана через API коннектора, то формат возвращаемых значений будет следующим: скалярные значения возвращаются в виде кортежей (сначала идет идентификатор типа из формата MsgPack, а затем идет значение); все прочие  (не скалярные) значения возвращаются в виде групп кортежей (сначала идет  идентификатор массива в формате MsgPack, а затем идут скалярные значения). Но если функция была вызвана в рамках бинарного протокола (с помощью команды ``eval``), а не через API коннектора, то подобных изменений формата возвращаемых значений не происходит."

#: ../doc/1.7/book/connectors/__results.rst:14
msgid "In the following example, a Lua function will be created. Since it will be accessed externally by a :ref:`'guest' user<box_space-user>`, a :ref:`grant <box_schema-user_grant>` of an execute privilege will be necessary. The function returns an empty array, a scalar string, two booleans, and a short integer. The values are the ones described in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr "Далее приводится пример создания Lua-функции. Поскольку эту функцию будет  вызывать внешний пользователь :ref:`'guest' user<box_space-user>`, то нужно настроить привилегии на исполнение с помощью :ref:`grant <box_schema-user_grant>`. Эта функция возвращает пустой массив, строку-скаляр, два логических значения и короткое целое число. Значение будут теми же, что описаны в разделе про MsgPack в таблице :ref:`Стандартные типы в MsgPack-кодировке <msgpack- common_types_and_msgpack_encodings>`."

#: ../doc/1.7/book/connectors/__results.rst:21
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"        2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept requests\n"
"        ---\n"
"        ...\n"
"        tarantool> function f() return {},'a',false,true,127; end\n"
"        ---\n"
"        ...\n"
"        tarantool> box.schema.func.create('f')\n"
"        ---\n"
"        ...\n"
"        tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"        ---\n"
"        ..."

#: ../doc/1.7/book/connectors/__results.rst:37
msgid "Here is a C program which calls the function. Although C is being used for the example, the result would be precisely the same if the calling program was written in Perl, PHP, Python, Go, or Java."
msgstr "Далее идет пример программы на C, из который мы вызываем эту Lua-функцию.  Хотя в примере использован код на C, результат будет одинаковым, на каком бы языке ни была написана вызываемая программа: Perl, PHP, Python, Go или Java."

#: ../doc/1.7/book/connectors/__results.rst:41
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"        #include <stdlib.h>\n"
"        #include <tarantool/tarantool.h>\n"
"        #include <tarantool/tnt_net.h>\n"
"        #include <tarantool/tnt_opt.h>\n"
"        void main() {\n"
"          struct tnt_stream *tnt = tnt_net(NULL);            /* НАСТРОЙКА */\n"
"          tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"           if (tnt_connect(tnt) < 0) {                        /* СОЕДИНЕНИЕ */\n"
"               printf(\"Connection refused\\n\");\n"
"               exit(-1);\n"
"           }\n"
"           struct tnt_stream *tuple = tnt_object(NULL);       /* СОЗДАНИЕ ЗАПРОСА  */\n"
"           struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"           tnt_object_add_array(arg, 0);\n"
"           struct tnt_request *req1 = tnt_request_call(NULL); /* ВЫЗОВ function f() */\n"
"           tnt_request_set_funcz(req1, \"f\");\n"
"           tnt_request_set_tuple(req1, arg);\n"
"           uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"           tnt_flush(tnt);                                    /* ОТПРАВКА ЗАПРОСА  */\n"
"           struct tnt_reply reply;  tnt_reply_init(&reply);   /* ПОЛУЧЕНИЕ ОТВЕТА  */\n"
"           tnt->read_reply(tnt, &reply);\n"
"           if (reply.code != 0) {\n"
"             printf(\"Call failed %lu.\\n\", reply.code);\n"
"             exit(-1);\n"
"           }\n"
"           const unsigned char *p= (unsigned char*)reply.data;/* ВЫВОД ОТВЕТА */\n"
"           while (p < (unsigned char *) reply.data_end)\n"
"           {\n"
"             printf(\"%x \", *p);\n"
"             ++p;\n"
"           }\n"
"           printf(\"\\n\");\n"
"           tnt_close(tnt);                                    /* ЗАВЕРШЕНИЕ */\n"
"           tnt_stream_free(tuple);\n"
"           tnt_stream_free(tnt);\n"
"        }"

#: ../doc/1.7/book/connectors/__results.rst:79
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../doc/1.7/book/connectors/__results.rst:81
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../doc/1.7/book/connectors/__results.rst:85
msgid "The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for \"32-bit array header with value 5\" (see `MsgPack specification <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). The rest are as described in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr "Первые пять байт — ``dd 0 0 0 5`` — это фрагмент данных в формате MsgPack, означающий \"32-битный заголовок массива со значением 5\" (см. `спецификацию на формат MsgPack <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). Остальные значения описаны в таблице :ref:`Стандартные типы в MsgPack-кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/1.7/book/faq.rst:5
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../doc/1.7/book/faq.rst
msgid "Q"
msgstr "В"

#: ../doc/1.7/book/faq.rst:9
msgid "Why Tarantool?"
msgstr "В чем особенности Tarantool'а?"

#: ../doc/1.7/book/faq.rst
msgid "A"
msgstr "О"

#: ../doc/1.7/book/faq.rst:10
msgid "Tarantool is the latest generation of a family of in-memory data servers developed for web applications. It is the result of practical experience and trials within Mail.Ru since development began in 2008."
msgstr "Tarantool — представитель нового поколения семейства серверов для in-memory базы данных, разработанный для веб-приложений.  Он создан в компании Mail.Ru на основе практического опыта, полученного методом проб и ошибок с начала разработки в 2008 году."

#: ../doc/1.7/book/faq.rst:14
msgid "Why Lua?"
msgstr "Почему Lua?"

#: ../doc/1.7/book/faq.rst:15
msgid "Lua is a lightweight, fast, extensible multi-paradigm language. Lua also happens to be very easy to embed. Lua coroutines relate very closely to Tarantool fibers, and Lua architecture works well with Tarantool internals. Lua acts well as a stored program language for Tarantool, although connecting with other languages is also easy."
msgstr "Lua — это легкий, быстрый и расширяемый язык, позволяющий использовать различные парадигмы программирования. Lua также легко встраивается в различные приложения. Ко-рутины (coroutines) в Lua близко соотносятся с файберами (fibers) в Tarantool'е, а вся Lua-архитектура гладко ложится на его внутреннюю реализацию. Lua — это первый язык, на котором можно писать хранимые процедуры для Tarantool'а. В будущем список поддерживаемых языков планируется расширить."

#: ../doc/1.7/book/faq.rst:21
msgid "What's the key advantage of Tarantool?"
msgstr "В чем ключевое преимущество Tarantool'а?"

#: ../doc/1.7/book/faq.rst
msgid "Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET indexes, secondary indexes, composite indexes, transactions, triggers, asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr "Tarantool обеспечивает богатый набор функций базы данных (HASH-индексы, TREE-индексы, RTREE-индексы, BITSET-индексы, вторичные индексы, составные индексы, транзакции, триггеры. асинхронная репликация) в гибкой среде Lua-интерпретатора."

#: ../doc/1.7/book/faq.rst
msgid "These two properties make it possible to be a fast, atomic and reliable in-memory data server which handles non-trivial application-specific logic. The advantage over traditional SQL servers is in performance: low-overhead, lock-free architecture means Tarantool can serve an order of magnitude more requests per second, on comparable hardware. The advantage over NoSQL alternatives is in flexibility: Lua allows flexible processing of data stored in a compact, denormalized format."
msgstr "Благодаря этим характеристикам, он представляет собой быстрый и надежный in-memory сервер с легким доступом к базе данных, который обрабатывает нетривиальную проблемно-ориентированную логику. Преимущество по сравнению с традиционными SQL-серверами — в производительности: архитектура без блокировок с малой перегрузкой означает, что Tarantool может обслуживать на порядок больше запросов в секунду на аналогичном оборудовании. Преимущество NoSQL-аналогов — в гибкости: Lua допускает гибкую обработку данных, хранимых в компактном денормализированном формате."

#: ../doc/1.7/book/faq.rst:35
msgid "Who is developing Tarantool?"
msgstr "Кто разрабатывает Tarantool?"

#: ../doc/1.7/book/faq.rst:36
msgid "There is an engineering team employed by Mail.Ru -- check out our commit logs on `github.com/tarantool <http://github.com/tarantool/>`_. The development is fully open. Most of the connectors' authors, and the maintainers for different distributions, come from the wider community."
msgstr "Во-первых, этим занимается команда разработки в Mail.Ru — см. историю коммитов на `github.com/tarantool <http://github.com/tarantool/>`_. Вся разработка ведется открытым образом. Кроме того, активную роль играют члены сообщества разработчиков Tarantool'а. Их силами было создано большинство коннекторов и ведутся доработки под разные дистрибутивы."

#: ../doc/1.7/book/faq.rst:41
msgid "Are there problems associated with being an in-memory server?"
msgstr "Возникают ли проблемы из-за того, что Tarantool является in-memory решением?"

#: ../doc/1.7/book/faq.rst:42
msgid "The principal storage engine (memtx) is designed for RAM plus persistent storage. It is immune to data loss because there is a write-ahead log. Its memory-allocation and compression techniques ensure there is no waste. And if Tarantool runs out of memory, then it will stop accepting updates until more memory is available, but will continue to handle read and delete requests without difficulty. However, for databases which are much larger than the available RAM space, Tarantool has a second storage engine (vinyl) which is only limited by the available disk space."
msgstr "Основной движок баз данных в Tarantool'е работает с оперативной памятью, но при этом он гарантирует сохранность данных благодаря механизму WAL (write ahead log), т.е. журналу упреждающей записи. Также в Tarantool'е используются технологии сжатия и распределения данных, которые позволяют использовать все виды памяти наиболее эффективно. Если Tarantool сталкивается с нехваткой оперативной памяти, то он приостанавливает прием запросов на изменение данных до тех пор, пока не появится свободная память, но при этом с успехом продолжает обработку запросов на чтение и удаление данных. А для больших баз, где объем данных значительно превосходит имеющийся объем оперативной памяти, у Tarantool'а есть второй движок, чьи возможности ограничены лишь размером жесткого диска."

#: ../doc/1.7/book/faq.rst:51
msgid "Can I store (large) BLOBs in Tarantool?"
msgstr "Можно ли хранить (большие) объекты BLOB в Tarantool'е?"

#: ../doc/1.7/book/faq.rst:52
msgid "Starting with Tarantool 1.7, there is no \"hard\" limit for the maximal tuple size. Tarantool, however, is designed for high-velocity workload with a lot of small chunks. For example, when you change an existing tuple, Tarantool creates a new version of the tuple in memory. Thus, an optimal tuple size is within kilobytes."
msgstr "Начиная с Tarantool 1.7, нет \"жесткого\" ограничения на максимальный размер кортежа. Однако Tarantool предназначен для работы с множеством фрагментов на высокой скорости. Например, при изменении существующего кортежа Tarantool создает новую версию кортежа в памяти. Таким образом, оптимальный размер кортежа — несколько килобайтов."

#: ../doc/1.7/book/faq.rst:59
msgid "I delete data from vinyl, but disk usage stays the same. What gives?"
msgstr "Я удаляю данные из vinyl'а, но использование диска не изменяется. В чем дело?"

#: ../doc/1.7/book/faq.rst:60
msgid "Data you write to vinyl is persisted in append-only run files. These files are immutable, and to perform a delete, a deletion marker (tombstone) is written to a newer run file instead. On compaction, new and old run files are merged, and a new run file is produced. Independently, the checkpoint manager keeps track of all run files involved in a checkpoint, and deletes obsolete files once they are no longer needed."
msgstr "Данные, записываемые в vinyl, сохраняются в исполняемых файлах, обновление которых происходит только путем присоединения новых записей. Такие файлы нельзя изменить, а для удаления маркер удаления (удаленная запись) записывается в новый исполняемый файл. Для уплотнения данных новый и старый исполняемые файлы объединяются, и создается новый исполняемый файл. Независимо от этого, менеджер контрольных точек следит за всеми исполняемыми файлами в контрольной точке и удаляет устаревшие файлы, как только в них отпадает необходимость."

#: ../doc/1.7/book/getting_started/index.rst:5
msgid "Getting started"
msgstr "Руководство для начинающих"

#: ../doc/1.7/book/getting_started/index.rst:7
msgid "In this chapter, we explain how to install Tarantool, how to start it, and how to create a simple database."
msgstr "В этой главе объясняется, как установить и запустить Tarantool, а также как создать простую базу данных."

#: ../doc/1.7/book/getting_started/using_binary.rst:5
msgid "Using a binary package"
msgstr "Использование бинарного пакета"

#: ../doc/1.7/book/getting_started/using_binary.rst:7
msgid "For production purposes, we recommend `official binary packages <http://tarantool.org/download.html>`_. You can choose from two Tarantool versions: 1.9 (stable) or 2.0 (alpha). An automatic build system creates, tests and publishes packages for every push into a corresponding branch (``1.9`` or ``2.0``) at `Tarantool's GitHub repository <https://github.com/tarantool/tarantool>`_."
msgstr "Для промышленной разработки мы рекомендуем использовать `официальные бинарные пакеты <http://tarantool.org/download.html>`_. Можно выбрать одну из двух версий Tarantool’а: 1.9 (стабильная) и 2.0 (альфа). Автоматическая система сборки создает, тестирует и публикует пакеты после  каждого коммита в соответствующую ветку (``1.9`` или ``2.0``) `репозитория Tarantool’а на GitHub <https://github.com/tarantool/tarantool>`_."

#: ../doc/1.7/book/getting_started/using_binary.rst:14
msgid "To download and install the package that’s appropriate for your OS, start a shell (terminal) and enter the command-line instructions provided for your OS at Tarantool's `download page <http://tarantool.org/download.html>`_."
msgstr "Чтобы скачать и установить бинарный пакет для вашей операционной системы,  откройте терминал с командной строкой и введите инструкции, которые даны  для вашей операционной системы на `странице для скачивания <http://tarantool.org/download.html>`_."

#: ../doc/1.7/book/getting_started/using_binary.rst:20
msgid "Starting Tarantool"
msgstr "Запуск экземпляра Tarantool’а"

#: ../doc/1.7/book/getting_started/using_binary.rst:22
msgid "To start a Tarantool instance, say this:"
msgstr "Для запуска экземпляра Tarantool’а выполните эту команду:"

#: ../doc/1.7/book/getting_started/using_binary.rst:24
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""
"$ # если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"        $ /usr/bin/tarantool\n"
"        $ # если вы скачали бинарный пакет в формате TAR\n"
"        $ # и разархивировали его в директорию ~/tarantool, введите:\n"
"        $ ~/tarantool/bin/tarantool"

#: ../doc/1.7/book/getting_started/using_binary.rst:31
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr "Tarantool запускается в интерактивном режиме и показывает приглашение командной строки:"

#: ../doc/1.7/book/getting_started/using_binary.rst:33
msgid "tarantool>"
msgstr "tarantool>"

#: ../doc/1.7/book/getting_started/using_binary.rst:37
#: ../doc/1.7/book/getting_started/using_docker.rst:84
msgid "Now you can enter requests on the command line."
msgstr "Теперь вы можете вводить запросы в командной строке."

#: ../doc/1.7/book/getting_started/using_binary.rst:41
#: ../doc/1.7/book/getting_started/using_docker.rst:88
msgid "On production machines, Tarantool's interactive mode is for system administration only. But we use it for most examples in this manual, because the interactive mode is convenient for learning."
msgstr "На боевых серверах интерактивный режим Tarantool’а предназначен только для системных администраторов. Мы же используем его в большинстве примеров в данном руководстве, потому что интерактивный режим хорошо подходит для обучения."

#: ../doc/1.7/book/getting_started/using_binary.rst:47
#: ../doc/1.7/book/getting_started/using_docker.rst:94
msgid "Creating a database"
msgstr "Создание базы данных"

#: ../doc/1.7/book/getting_started/using_binary.rst:49
msgid "Here is how to create a simple test database after installing."
msgstr "Далее объясняется, как создать простую тестовую базу данных после установки Tarantool'а."

#: ../doc/1.7/book/getting_started/using_binary.rst:51
msgid "Create a new directory (it’s just for tests, so you can delete it when the tests are over):"
msgstr "Создайте новую директорию (она понадобится только для тестовых целей, и ее можно будет удалить по окончании экспериментов):"

#: ../doc/1.7/book/getting_started/using_binary.rst:54
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"        $ cd ~/tarantool_sandbox"

#: ../doc/1.7/book/getting_started/using_binary.rst:59
msgid "To start Tarantool's database module and make the instance accept TCP requests on port 3301, say this:"
msgstr "Чтобы запустить модуль Tarantool’а для работы с базой данных и сделать так, чтобы запущенный экземпляр принимал TCP-запросы на порту 3301, выполните эту команду:"

#: ../doc/1.7/book/getting_started/using_binary.rst:66
#: ../doc/1.7/book/getting_started/using_docker.rst:98
msgid "First, create the first :ref:`space <index-box_space>` (named 'tester'):"
msgstr "Сначала создайте первый :ref:`спейс <index-box_space>` (с именем 'tester'):"

#: ../doc/1.7/book/getting_started/using_binary.rst:68
msgid "tarantool> s = box.schema.space.create('tester')"
msgstr "tarantool> s = box.schema.space.create('tester')"

#: ../doc/1.7/book/getting_started/using_binary.rst:72
#: ../doc/1.7/book/getting_started/using_docker.rst:104
msgid "Format the created space by specifying field names and types:"
msgstr "Форматируйте созданный спейс, указав имена и типы полей:"

#: ../doc/1.7/book/getting_started/using_binary.rst:74
msgid ""
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })"
msgstr ""
"tarantool> s:format({\n"
"               > {name = 'id', type = 'unsigned'},\n"
"               > {name = 'band_name', type = 'string'},\n"
"               > {name = 'year', type = 'unsigned'}\n"
"               > })"

#: ../doc/1.7/book/getting_started/using_binary.rst:82
#: ../doc/1.7/book/getting_started/using_docker.rst:114
msgid "Create the first :ref:`index <index-box_index>` (named 'primary'):"
msgstr "Создайте первый :ref:`индекс <index-box_index>` (с именем 'primary’):"

#: ../doc/1.7/book/getting_started/using_binary.rst:84
msgid ""
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })"
msgstr ""
"tarantool> s:create_index('primary', {\n"
"               > type = 'hash',\n"
"               > parts = {'id'}\n"
"               > })"

#: ../doc/1.7/book/getting_started/using_binary.rst:91
#: ../doc/1.7/book/getting_started/using_docker.rst:123
msgid "This is a primary index based on the 'id' field of each tuple."
msgstr "Это первичный индекс по полю 'id' в каждом кортеже."

#: ../doc/1.7/book/getting_started/using_binary.rst:93
#: ../doc/1.7/book/getting_started/using_docker.rst:125
msgid "Insert three :ref:`tuples <index-box_tuple>` (our name for \"records\") into the space:"
msgstr "Вставьте в созданный спейс три :ref:`кортежа <index-box_tuple>` (наш термин для «записей»):"

#: ../doc/1.7/book/getting_started/using_binary.rst:96
msgid ""
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}"
msgstr ""
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"      tarantool> s:insert{2, 'Scorpions', 2015}\n"
"      tarantool> s:insert{3, 'Ace of Base', 1993}"

#: ../doc/1.7/book/getting_started/using_binary.rst:102
#: ../doc/1.7/book/getting_started/using_docker.rst:134
msgid "To select a tuple using the 'primary' index, say:"
msgstr "Для выборки кортежей по первичному индексу выполните команду:"

#: ../doc/1.7/book/getting_started/using_binary.rst:104
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/1.7/book/getting_started/using_binary.rst:108
#: ../doc/1.7/book/getting_started/using_docker.rst:140
msgid "The terminal screen now looks like this:"
msgstr "Теперь вывод в окне терминала выглядит следующим образом:"

#: ../doc/1.7/book/getting_started/using_binary.rst:110
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"      ---\n"
"      ...\n"
"      tarantool> s:format({\n"
"               > {name = 'id', type = 'unsigned'},\n"
"               > {name = 'band_name', type = 'string'},\n"
"               > {name = 'year', type = 'unsigned'}\n"
"               > })\n"
"      ---\n"
"      ...\n"
"      tarantool> s:create_index('primary', {\n"
"               > type = 'hash',\n"
"               > parts = {'id'}\n"
"               > })\n"
"      ---\n"
"      - unique: true\n"
"        parts:\n"
"        - type: unsigned\n"
"          is_nullable: false\n"
"          fieldno: 1\n"
"        id: 0\n"
"        space_id: 512\n"
"        name: primary\n"
"        type: HASH\n"
"      ...\n"
"      tarantool> s:insert{1, 'Roxette', 1986}\n"
"      ---\n"
"      - [1, 'Roxette', 1986]\n"
"      ...\n"
"      tarantool> s:insert{2, 'Scorpions', 2015}\n"
"      ---\n"
"      - [2, 'Scorpions', 2015]\n"
"      ...\n"
"      tarantool> s:insert{3, 'Ace of Base', 1993}\n"
"      ---\n"
"      - [3, 'Ace of Base', 1993]\n"
"      ...\n"
"      tarantool> s:select{3}\n"
"      ---\n"
"      - - [3, 'Ace of Base', 1993]\n"
"      ..."

#: ../doc/1.7/book/getting_started/using_binary.rst:154
#: ../doc/1.7/book/getting_started/using_docker.rst:186
msgid "To add a secondary index based on the 'band_name' field, say:"
msgstr "Для добавления вторичного индекса по полю 'band_name' используйте эту команду:"

#: ../doc/1.7/book/getting_started/using_binary.rst:156
msgid ""
"tarantool> s:create_index('secondary', {\n"
"         > type = 'hash',\n"
"         > parts = {'band_name'}\n"
"         > })"
msgstr ""
"tarantool> s:create_index('secondary', {\n"
"               > type = 'hash',\n"
"               > parts = {'band_name'}\n"
"               > })"

#: ../doc/1.7/book/getting_started/using_binary.rst:163
#: ../doc/1.7/book/getting_started/using_docker.rst:195
msgid "To select tuples using the 'secondary' index, say:"
msgstr "Для выборки кортежей по вторичному индексу выполните команду:"

#: ../doc/1.7/book/getting_started/using_binary.rst:165
msgid ""
"tarantool> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"tarantool> s.index.secondary:select{'Scorpions'}\n"
"      ---\n"
"      - - [2, 'Scorpions', 2015]\n"
"      ..."

#: ../doc/1.7/book/getting_started/using_binary.rst:172
msgid "Now, to prepare for the example in the next section, try this:"
msgstr "Теперь, чтобы подготовиться к примеру в следующем разделе, попробуйте следующее:"

#: ../doc/1.7/book/getting_started/using_binary.rst:174
msgid "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../doc/1.7/book/getting_started/using_binary.rst:180
msgid "Connecting remotely"
msgstr "Установка удаленного подключения"

#: ../doc/1.7/book/getting_started/using_binary.rst:182
msgid "In the request ``box.cfg{listen = 3301}`` that we made earlier, the ``listen`` value can be any form of a :ref:`URI <index-uri>` (uniform resource identifier). In this case, it’s just a local port: port 3301. You can send requests to the listen URI via:"
msgstr "В запросе ``box.cfg{listen = 3301}``, который мы отправили ранее, параметр ``listen`` может принимать в качестве значения :ref:`URI <index-uri>` (универсальный идентификатор ресурса) любой формы. В нашем случае это просто локальный порт 3301. Вы можете отправлять запросы на указанный  URI, используя:"

#: ../doc/1.7/book/getting_started/using_binary.rst:187
msgid "``telnet``,"
msgstr "``telnet``,"

#: ../doc/1.7/book/getting_started/using_binary.rst:188
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ":ref:`коннектор <index-box_connectors>`,"

#: ../doc/1.7/book/getting_started/using_binary.rst:189
msgid "another instance of Tarantool (using the :ref:`console <console-module>` module), or"
msgstr "другой экземпляр Tarantool'а (с помощью модуля :ref:`console <console- module>`), либо"

#: ../doc/1.7/book/getting_started/using_binary.rst:190
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr "утилиту :ref:`tarantoolctl <tarantoolctl>`."

#: ../doc/1.7/book/getting_started/using_binary.rst:192
msgid "Let’s try (4)."
msgstr "Давайте попробуем вариант с ``tarantoolctl``."

#: ../doc/1.7/book/getting_started/using_binary.rst:194
msgid "Switch to another terminal. On Linux, for example, this means starting another instance of a Bash shell. You can switch to any working directory in the new terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr "Переключитесь на другой терминал. Например, в Linux-системе для этого нужно запустить еще один экземпляр Bash. В новом терминале можно сменить текущую рабочую директорию на любую другую, необязательно использовать ``~/tarantool_sandbox``."

#: ../doc/1.7/book/getting_started/using_binary.rst:198
msgid "Start the ``tarantoolctl`` utility:"
msgstr "Запустите утилиту ``tarantoolctl``:"

#: ../doc/1.7/book/getting_started/using_binary.rst:200
msgid "$ tarantoolctl connect '3301'"
msgstr "$ tarantoolctl connect '3301'"

#: ../doc/1.7/book/getting_started/using_binary.rst:204
msgid "This means \"use ``tarantoolctl connect`` to connect to the Tarantool instance that’s listening on ``localhost:3301``\"."
msgstr "Данная команда означает «использовать утилиту ``tarantoolctl`` для подключения к Tarantool-серверу, который слушает по адресу ``localhost:3301``»."

#: ../doc/1.7/book/getting_started/using_binary.rst:207
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../doc/1.7/book/getting_started/using_binary.rst:209
msgid "localhost:3301> box.space.tester:select{2}"
msgstr "localhost:3301> box.space.tester:select{2}"

#: ../doc/1.7/book/getting_started/using_binary.rst:213
msgid "This means \"send a request to that Tarantool instance, and display the result\". The result in this case is one of the tuples that was inserted earlier. Your terminal screen should now look like this:"
msgstr "Это означает «послать запрос тому Tarantool-серверу и вывести результат на экран». Результатом в данном случае будет один из кортежей, что вы вставляли ранее. В окне терминала теперь должно отображаться примерно следующее:"

#: ../doc/1.7/book/getting_started/using_binary.rst:217
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"$ tarantoolctl connect 3301\n"
"      /usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"      localhost:3301> box.space.tester:select{2}\n"
"      ---\n"
"      - - [2, 'Scorpions', 2015]\n"
"      ..."

#: ../doc/1.7/book/getting_started/using_binary.rst:226
msgid "You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` indefinitely, on either Tarantool instance."
msgstr "Вы можете посылать запросы ``box.space...:insert{}`` и ``box.space...:select{}`` неограниченное количество раз на любом из двух запущенных экземпляров Tarantool’а."

#: ../doc/1.7/book/getting_started/using_binary.rst:229
msgid "When the testing is over:"
msgstr "Закончив тестирование, выполните следующие шаги:"

#: ../doc/1.7/book/getting_started/using_binary.rst:231
msgid "To drop the space: ``s:drop()``"
msgstr "Для удаления спейса: ``s:drop()``"

#: ../doc/1.7/book/getting_started/using_binary.rst:232
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr "Для остановки ``tarantoolctl``:  ctrl+C или ctrl+D"

#: ../doc/1.7/book/getting_started/using_binary.rst:233
msgid "To stop Tarantool (an alternative): the standard Lua function `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr "Для остановки Tarantool’а (альтернативный вариант): стандартная Lua-функция `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf- os.exit>`_"

#: ../doc/1.7/book/getting_started/using_binary.rst:235
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr "Для остановки Tarantool’а (из другого терминала): ``sudo pkill -f tarantool``"

#: ../doc/1.7/book/getting_started/using_binary.rst:236
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr "Для удаления директории-песочницы: ``rm -r ~/tarantool_sandbox``"

#: ../doc/1.7/book/getting_started/using_docker.rst:5
msgid "Using a Docker image"
msgstr "Использование Docker-образа"

#: ../doc/1.7/book/getting_started/using_docker.rst:7
msgid "For trial and test purposes, we recommend using `official Tarantool images for Docker <https://github.com/tarantool/docker>`_. An official image contains a particular Tarantool version (1.6, 1.9 or 2.0) and all popular external modules for Tarantool. Everything is already installed and configured in Linux. These images are the easiest way to install and use Tarantool."
msgstr "Для практики и тестирования мы рекомендуем использовать `официальные образы Tarantool’а для Docker <https://github.com/tarantool/docker>`_. Официальный образ содержит определенную версию Tarantool’а (1.6, 1.9 или 2.0) и все популярные внешние модули для Tarantool’а. Все необходимое уже установлено и настроено на платформе Linux. Данные образы - это самый простой способ установить и запустить Tarantool."

#: ../doc/1.7/book/getting_started/using_docker.rst:16
msgid "If you're new to Docker, we recommend going over `this tutorial <https://docs.docker.com/engine/getstarted/step_one/>`_ before proceeding with this chapter."
msgstr "Если вы никогда раньше не работали с Docker, рекомендуем сперва прочитать `эту обучающую статью <https://docs.docker.com/engine/getstarted/step_one/>`_."

#: ../doc/1.7/book/getting_started/using_docker.rst:24
msgid "Launching a container"
msgstr "Запуск контейнера"

#: ../doc/1.7/book/getting_started/using_docker.rst:26
msgid "If you don't have Docker installed, please follow the official `installation guide <https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-docker>`_ for your OS."
msgstr "Если Docker не установлен на вашей машине, следуйте официальным `инструкциям по установке <https://docs.docker.com/engine/getstarted/step_one/#/step-1-get- docker>`_ для вашей ОС."

#: ../doc/1.7/book/getting_started/using_docker.rst:30
msgid "To start a fully functional Tarantool instance, run a container with minimal options:"
msgstr "Для использования полнофункционального экземпляра Tarantool’а запустите контейнер с минимальными настройками:"

#: ../doc/1.7/book/getting_started/using_docker.rst:33
msgid ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:1.7"
msgstr ""
"$ docker run \\\n"
"          --name mytarantool \\\n"
"          -d -p 3301:3301 \\\n"
"          -v /data/dir/on/host:/var/lib/tarantool \\\n"
"          tarantool/tarantool:1.7"

#: ../doc/1.7/book/getting_started/using_docker.rst:41
msgid "This command runs a new container named 'mytarantool'. Docker starts it from an official image named 'tarantool/tarantool:1.7', with Tarantool version 1.7 and all external modules already installed."
msgstr "Эта команда запускает новый контейнер с именем 'mytarantool'. Docker запускает его из официального образа 'tarantool/tarantool:1.7' с предустановленным Tarantool’ом 1.7 и всеми внешними модулями."

#: ../doc/1.7/book/getting_started/using_docker.rst:45
msgid "Tarantool will be accepting incoming connections on ``localhost:3301``. You may start using it as a key-value storage right away."
msgstr "Tarantool будет принимать входящие подключения по адресу ``localhost:3301``. Можно сразу начать его использовать как key-value хранилище."

#: ../doc/1.7/book/getting_started/using_docker.rst:48
msgid "Tarantool :ref:`persists data <index-box_persistence>` inside the container. To make your test data available after you stop the container, this command also mounts the host's directory ``/data/dir/on/host`` (you need to specify here an absolute path to an existing local directory) in the container's directory ``/var/lib/tarantool`` (by convention, Tarantool in a container uses this directory to persist data). So, all changes made in the mounted directory on the container's side are applied to the host's disk."
msgstr "Tarantool :ref:`сохраняет данные <index-box_persistence>` внутри контейнера. Чтобы ваше тестовые данные остались доступны после остановки контейнера, эта команда также монтирует директорию ``/data/dir/on/host`` (здесь необходимо указать абсолютный путь до существующей локальной директории), расположенную на машине, в директорию ``/var/lib/tarantool``  (Tarantool традиционно использует эту директорию в контейнере для сохранения данных), расположенную в контейнере. Таким образом все изменения в смонтированной директории, внесенные на стороне контейнера, также отражаются в расположенной на пользовательском диске директории."

#: ../doc/1.7/book/getting_started/using_docker.rst:57
msgid "Tarantool's database module in the container is already :ref:`configured <box_introspection-box_cfg>` and started. You needn't do it manually, unless you use Tarantool as an :ref:`application server <app_server>` and run it with an application."
msgstr "Модуль Tarantool’а для работы с базой данных уже :ref:`настроен <box_introspection-box_cfg>` и запущен в контейнере. Ручная настройка не требуется, если только вы не используете Tarantool как :ref:`сервер приложений <app_server>` и не запускаете его вместе с приложением."

#: ../doc/1.7/book/getting_started/using_docker.rst:64
msgid "Attaching to Tarantool"
msgstr "Подключение к экземпляру Tarantool’а"

#: ../doc/1.7/book/getting_started/using_docker.rst:66
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr "Для подключения к запущенному в контейнере экземпляру Tarantool’а, выполните эту команду:"

#: ../doc/1.7/book/getting_started/using_docker.rst:68
msgid "$ docker exec -i -t mytarantool console"
msgstr "$ docker exec -i -t mytarantool console"

#: ../doc/1.7/book/getting_started/using_docker.rst:72
msgid "This command:"
msgstr "Эта команда:"

#: ../doc/1.7/book/getting_started/using_docker.rst:74
msgid "Instructs Tarantool to open an interactive console port for incoming connections."
msgstr "Требует от Tarantool’а открыть порт с интерактивной консолью для входящих  подключений."

#: ../doc/1.7/book/getting_started/using_docker.rst:75
msgid "Attaches to the Tarantool server inside the container under 'admin' user via a standard Unix socket."
msgstr "Подключается через стандартный Unix-сокет к Tarantool-серверу, запущенному внутри контейнера, из-под пользователя 'admin’."

#: ../doc/1.7/book/getting_started/using_docker.rst:78
msgid "Tarantool displays a prompt:"
msgstr "Tarantool показывает приглашение командной строки:"

#: ../doc/1.7/book/getting_started/using_docker.rst:80
msgid "tarantool.sock>"
msgstr "tarantool.sock>"

#: ../doc/1.7/book/getting_started/using_docker.rst:96
msgid "While you're attached to the console, let's create a simple test database."
msgstr "Подключившись к консоли, давайте создадим простую тестовую базу данных."

#: ../doc/1.7/book/getting_started/using_docker.rst:100
msgid "tarantool.sock> s = box.schema.space.create('tester')"
msgstr "tarantool.sock> s = box.schema.space.create('tester')"

#: ../doc/1.7/book/getting_started/using_docker.rst:106
msgid ""
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:format({\n"
"                    > {name = 'id', type = 'unsigned'},\n"
"                    > {name = 'band_name', type = 'string'},\n"
"                    > {name = 'year', type = 'unsigned'}\n"
"                    > })"

#: ../doc/1.7/book/getting_started/using_docker.rst:116
msgid ""
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:create_index('primary', {\n"
"                    > type = 'hash',\n"
"                    > parts = {'id'}\n"
"                    > })"

#: ../doc/1.7/book/getting_started/using_docker.rst:128
msgid ""
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}"
msgstr ""
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"      tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"      tarantool.sock> s:insert{3, 'Ace of Base', 1993}"

#: ../doc/1.7/book/getting_started/using_docker.rst:136
msgid "tarantool.sock> s:select{3}"
msgstr "tarantool.sock> s:select{3}"

#: ../doc/1.7/book/getting_started/using_docker.rst:142
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"      ---\n"
"      ...\n"
"      tarantool.sock> s:format({\n"
"                    > {name = 'id', type = 'unsigned'},\n"
"                    > {name = 'band_name', type = 'string'},\n"
"                    > {name = 'year', type = 'unsigned'}\n"
"                    > })\n"
"      ---\n"
"      ...\n"
"      tarantool.sock> s:create_index('primary', {\n"
"                    > type = 'hash',\n"
"                    > parts = {'id'}\n"
"                    > })\n"
"      ---\n"
"      - unique: true\n"
"        parts:\n"
"        - type: unsigned\n"
"          is_nullable: false\n"
"          fieldno: 1\n"
"        id: 0\n"
"        space_id: 512\n"
"        name: primary\n"
"        type: HASH\n"
"      ...\n"
"      tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"      ---\n"
"      - [1, 'Roxette', 1986]\n"
"      ...\n"
"      tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"      ---\n"
"      - [2, 'Scorpions', 2015]\n"
"      ...\n"
"      tarantool.sock> s:insert{3, 'Ace of Base', 1993}\n"
"      ---\n"
"      - [3, 'Ace of Base', 1993]\n"
"      ...\n"
"      tarantool.sock> s:select{3}\n"
"      ---\n"
"      - - [3, 'Ace of Base', 1993]\n"
"      ..."

#: ../doc/1.7/book/getting_started/using_docker.rst:188
msgid ""
"tarantool.sock> s:create_index('secondary', {\n"
"              > type = 'hash',\n"
"              > parts = {'band_name'}\n"
"              > })"
msgstr ""
"tarantool.sock> s:create_index('secondary', {\n"
"                    > type = 'hash',\n"
"                    > parts = {'band_name'}\n"
"                    > })"

#: ../doc/1.7/book/getting_started/using_docker.rst:197
msgid ""
"tarantool.sock> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""
"tarantool.sock> s.index.secondary:select{'Scorpions'}\n"
"      ---\n"
"      - - [2, 'Scorpions', 2015]\n"
"      ..."

#: ../doc/1.7/book/getting_started/using_docker.rst:206
msgid "Stopping a container"
msgstr "Остановка контейнера"

#: ../doc/1.7/book/getting_started/using_docker.rst:208
msgid "When the testing is over, stop the container politely:"
msgstr "После завершения тестирования для корректной остановки контейнера выполните эту команду:"

#: ../doc/1.7/book/getting_started/using_docker.rst:210
msgid "$ docker stop mytarantool"
msgstr "$ docker stop mytarantool"

#: ../doc/1.7/book/getting_started/using_docker.rst:214
msgid "This was a temporary container, and its disk/memory data were flushed when you stopped it. But since you mounted a data directory from the host in the container, Tarantool's data files were persisted to the host's disk. Now if you start a new container and mount that data directory in it, Tarantool will recover all data from disk and continue working with the persisted data."
msgstr "Это был временный контейнер, поэтому после остановки содержимое его диска/памяти обнулилось. Но так как вы монтировали локальную директорию в  контейнер, все данные Tarantool’а сохранились на диске вашей машины. Если вы запустите новый контейнер и смонтируете в него ту же директорию с  данными, Tarantool восстановит все данные с диска и продолжит с ними работать."

#: ../doc/1.7/book/index.rst:5
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../doc/1.7/book/intro.rst:3
msgid "Preface"
msgstr "Предисловие"

#: ../doc/1.7/book/intro.rst:5
msgid "Welcome to Tarantool! This is the User's Guide. We recommend reading it first, and consulting :ref:`Reference <reference>` materials for more detail afterwards, if needed."
msgstr "Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство пользователя\". Мы советуем начинать именно с него, а затем переходить к :ref:`\"Справочникам\" <reference>`, если вам понадобятся более подробные  сведения."

#: ../doc/1.7/book/intro.rst:11
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../doc/1.7/book/intro.rst:13
msgid "To get started, you can install and launch Tarantool using :ref:`a Docker container <getting_started-using_docker>`, :ref:`a binary package <getting_started-using_binary>`, or the online Tarantool server at http://try.tarantool.org. Either way, as the first tryout, you can follow the introductory exercises from :ref:`Chapter 2 \"Getting started\" <getting_started>`. If you want more hands-on experience, proceed to :ref:`Tutorials <tutorials>` after you are through with Chapter 2."
msgstr "Для начала можно установить и запустить Tarantool, используя :ref:`Docker-контейнер <getting_started-using_docker>`, :ref:`бинарный пакет <getting_started-using_binary>` или онлайн-сервер Tarantool'а http://try.tarantool.org. В любом случае для пробы можно сделать вводные упражнения из :ref:`главы 2 \"Руководство для начинающих\" <getting_started>`. Если хотите получить практический опыт, переходите к :ref:`Практическим заданиям <tutorials>` после работы с главой 2."

#: ../doc/1.7/book/intro.rst:22
msgid ":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool as a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" <app_server>` is about using Tarantool as an application server."
msgstr "В :ref:`главе 3 \"Функциональность СУБД\" <database-chapter>` рассказано о возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер приложений\" <app_server>` — о возможностях Tarantool'а как сервера приложений Lua."

#: ../doc/1.7/book/intro.rst:26
msgid ":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 \"Replication\" <replication>` are primarily for administrators."
msgstr ":ref:`Глава 5 \"Администрирование серверной части\" <admin>` и :ref:`Глава 6 \"Репликация\" <replication>` предназначены в первую очередь для системных администраторов."

#: ../doc/1.7/book/intro.rst:29
msgid ":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for users who are connecting from a different language such as C or Perl or Python — other users will find no immediate need for this chapter."
msgstr ":ref:`Глава 7 \"Коннекторы\" <index-box_connectors>` актуальна только для тех пользователей, которые хотят устанавливать соединение с Tarantool'ом с помощью программ на других языках программирования (например C, Perl или Python) — для прочих пользователей эта глава неактуальна."

#: ../doc/1.7/book/intro.rst:33
msgid ":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked questions about Tarantool."
msgstr ":ref:`Глава 8 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые часто задаваемые вопросы о Tarantool'е."

#: ../doc/1.7/book/intro.rst:36
msgid "For experienced users, there are also :ref:`Reference <reference>` materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive set of comments in the source code."
msgstr "Опытным же пользователям будут полезны :ref:`\"Справочники\" <reference>`, :ref:`\"Руководство участника проекта\" <contrib_guide>` и комментарии в исходном коде."

#: ../doc/1.7/book/intro.rst:42
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../doc/1.7/book/intro.rst:44
msgid "Please report bugs or make feature requests at http://github.com/tarantool/tarantool/issues."
msgstr "Оставить сообщение о найденных дефектах или сделать запрос на новые функции можно тут: http://github.com/tarantool/tarantool/issues"

#: ../doc/1.7/book/intro.rst:46
msgid "You can contact developers directly in `telegram <http://telegram.me/tarantool>`_ or in a Tarantool discussion group (`English <https://groups.google.com/forum/#!forum/tarantool>`_ or `Russian <https://googlegroups.com/group/tarantool-ru>`_)."
msgstr "Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram <http://telegram.me/tarantool>`_ или на форумах (`англоязычном <https://groups.google.com/forum/#!forum/tarantool>`_ или `русскоязычном <https://googlegroups.com/group/tarantool-ru>`_)."

#: ../doc/1.7/book/intro.rst:53
msgid "Conventions used in this manual"
msgstr "Условные обозначения, используемые в руководстве"

#: ../doc/1.7/book/intro.rst:55
msgid "Square brackets [ and ] enclose optional syntax."
msgstr "В квадратные скобки [ и ] включается синтаксис необязательных элементов."

#: ../doc/1.7/book/intro.rst:57
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr "Две точки подряд .. означают, что предыдущие токены могут повторяться."

#: ../doc/1.7/book/intro.rst:59
msgid "A vertical bar | means the preceding and following tokens are mutually exclusive alternatives."
msgstr "Вертикальная черта | означает, что предыдущий и последующий токены представляют собой взаимоисключающие альтернативы."

#: ../doc/1.7/book/replication/index.rst:5
#: ../doc/1.7/reference/configuration/index.rst:223
msgid "Replication"
msgstr "Репликация"

#: ../doc/1.7/book/replication/index.rst:7
msgid "Replication allows multiple Tarantool instances to work on copies of the same databases. The databases are kept in sync because each instance can communicate its changes to all the other instances."
msgstr "Механизм репликации позволяет сразу многим экземплярам Tarantool'а работать с копиями одних и тех же баз данных. При этом все базы остаются в синхронизированном состоянии благодаря тому, что каждый экземпляр может сообщать другим экземплярам о совершенных им изменениях."

#: ../doc/1.7/book/replication/repl_add_instances.rst:5
msgid "Adding instances"
msgstr "Добавление экземпляров"

#: ../doc/1.7/book/replication/repl_add_instances.rst:11
msgid "Adding a replica"
msgstr "Добавление реплики"

#: ../doc/1.7/book/replication/repl_add_instances.rst:16
msgid "To add a second **replica** instance to the **master-replica** set from our :ref:`bootstrapping example <replication-master_replica_bootstrap>`, we need an analog of the instance file that we created for the first replica in that set:"
msgstr "Чтобы добавить вторую **реплику** в набор реплик с конфигурацией **мастер-реплика** из нашего :ref:`примера настройки <replication-master_replica_bootstrap>`, необходим аналог файла экземпляра, который мы создали для первой реплики в этом наборе:"

#: ../doc/1.7/book/replication/repl_add_instances.rst:20
msgid ""
"-- instance file for replica #2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = ('replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- replica #1 URI\n"
"                 'replicator:password@192.168.0.103:3301'), -- replica #2 URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"
msgstr ""
"-- файл экземпляра для реплики №2\n"
"        box.cfg{\n"
"          listen = 3301,\n"
"          replication = ('replicator:password@192.168.0.101:3301',  -- URI мастера\n"
"                         'replicator:password@192.168.0.102:3301',  -- URI реплики№1\n"
"                         'replicator:password@192.168.0.103:3301'), -- URI реплики№2\n"
"          read_only = true\n"
"        }\n"
"        box.once(\"schema\", function()\n"
"           box.schema.user.create('replicator', {password = 'password'})\n"
"           box.schema.user.grant('replicator', 'replication’) -- предоставить роль для репликации\n"
"           box.schema.space.create(\"test\")\n"
"           box.space.test:create_index(\"primary\")\n"
"           print('box.once executed on replica #2')\n"
"        end)"

#: ../doc/1.7/book/replication/repl_add_instances.rst:38
msgid "Here we add replica #2 URI to :ref:`replication <cfg_replication-replication>` parameter, so now it contains three URIs."
msgstr "Здесь мы добавляем URI реплики №2 в параметр :ref:`replication <cfg_replication-replication>`, так что теперь он содержит три URI."

#: ../doc/1.7/book/replication/repl_add_instances.rst:41
msgid "After we launch the new replica instance, it gets connected to the master instance and retrieves the master's write ahead log and snapshot files:"
msgstr "После запуска новая реплика подключается к мастер-серверу и получает от него журнал упреждающей записи и файлы снимков:"

#: ../doc/1.7/book/replication/repl_add_instances.rst:44
msgid ""
"$ # launching replica #2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping replica from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"
msgstr ""
"$ # запуск реплики №2\n"
"        $ tarantool replica2.lua\n"
"        2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version 1.7.4-52-g980d30092\n"
"        2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"        2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping 268435456 bytes for tuple arena...\n"
"        2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"        2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> authenticated\n"
"        2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping replica from 192.168.0.101:3301\n"
"        2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> initial data received\n"
"        2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> final data received\n"
"        2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"        2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"        2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint  done\n"
"        2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept requests\n"
"        2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' configuration option to true\n"
"        2017-06-14 14:54:33.936 [46945] main C> entering the event loop"

#: ../doc/1.7/book/replication/repl_add_instances.rst:63
msgid "Since we're adding a read-only instance, there is no need to dynamically update ``replication`` parameter on the other running instances. This update would be required if we :ref:`added a master instance <replication-add_master>`."
msgstr "Поскольку мы добавляем экземпляр только для чтения (read-only), нет необходимости в динамическом обновлении параметра ``replication`` на других работающих экземплярах. Такое обновление необходимо, если бы мы :ref:`добавляли мастера <replication-add_master>`."

#: ../doc/1.7/book/replication/repl_add_instances.rst:67
msgid "However, we recommend to specify replica #3 URI in all instance files of the replica set. This will keep all the files consistent with each other and with the current replication topology, and so will help to avoid configuration errors in case of further reconfigurations and replica set restart."
msgstr "Тем не менее, рекомендуем указать URI реплики №3 во всех файлах экземпляра в наборе реплик. Это поможет сохранить единообразие файлов и согласовать их с текущей топологией репликации, а также не допустить ошибок конфигурации в случае последующего обновления конфигурации и перезапуска набора реплик."

#: ../doc/1.7/book/replication/repl_add_instances.rst:76
msgid "Adding a master"
msgstr "Добавление мастера"

#: ../doc/1.7/book/replication/repl_add_instances.rst:81
msgid "To add a third master instance to the **master-master** set from our :ref:`bootstrapping example <replication-master_master_bootstrap>`, we need an analog of the instance files that we created to bootstrap the other master instances in that set:"
msgstr "Чтобы добавить третьего мастера в набор реплик с конфигурацией **мастер-мастер** из нашего :ref:`примера настройки <replication-master_master_bootstrap>`, необходим аналог файлов экземпляров, которые мы создали для настройки других мастеров в этом наборе:"

#: ../doc/1.7/book/replication/repl_add_instances.rst:86
msgid ""
"-- instance file for master #3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master#1 URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- master#2 URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- master#3 URI\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant \"replication\" role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"
msgstr ""
"-- файл экземпляра для мастера№3\n"
"        box.cfg{\n"
"          listen      = 3301,\n"
"          replication = {'replicator:password@192.168.0.101:3301',  -- URI мастера №1\n"
"                         'replicator:password@192.168.0.102:3301',  -- URI мастера №2\n"
"                         'replicator:password@192.168.0.103:3301'}, -- URI мастера №3\n"
"          read_only   = true, -- temporarily read-only\n"
"        }\n"
"        box.once(\"schema\", function()\n"
"           box.schema.user.create('replicator', {password = 'password'})\n"
"           box.schema.user.grant('replicator', 'replication’) -- предоставить роль для репликации\n"
"           box.schema.space.create(\"test\")\n"
"           box.space.test:create_index(\"primary\")\n"
"        end)"

#: ../doc/1.7/book/replication/repl_add_instances.rst:103
msgid "Here we make the following changes:"
msgstr "Здесь мы вносим следующие изменения:"

#: ../doc/1.7/book/replication/repl_add_instances.rst:105
msgid "Add master#3 URI to :ref:`replication <cfg_replication-replication>` parameter."
msgstr "Добавить URI мастера №3 в параметр :ref:`replication <cfg_replication-replication>`."

#: ../doc/1.7/book/replication/repl_add_instances.rst:107
msgid "Temporarily specify :ref:`read_only=true <cfg_basic-read_only>` to disable data-change operations on the instance. After launch, master #3 will act as a replica until it retrieves all data from the other masters in the replica set."
msgstr "Временно укажите :ref:`read_only=true <cfg_basic-read_only>`, чтобы отключить операции по изменению данных на этом экземпляре. После запуска мастер №3 будет работать в качестве реплики, пока не получит все данные от других мастеров в наборе реплик."

#: ../doc/1.7/book/replication/repl_add_instances.rst:111
msgid "After we launch the third master instance, it gets connected to the other master instances and retrieves their write ahead logs and snapshot files:"
msgstr "После запуска третий мастер-сервер подключается к другим мастер-серверам и получает от них журналы упреждающей записи и файлы снимков:"

#: ../doc/1.7/book/replication/repl_add_instances.rst:114
msgid ""
"$ # launching master #3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping replica from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 I> authenticated"
msgstr ""
"$ # запуск мастера №3\n"
"        $ tarantool master3.lua\n"
"        2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version 1.7.4-52-g980d30092\n"
"        2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"        2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456  bytes for tuple arena...\n"
"        2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to [::]:3301\n"
"        2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"        2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"        2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"        2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> authenticated\n"
"        2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping replica from 192.168.0.102:3301\n"
"        2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> initial data received\n"
"        2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> final data received\n"
"        2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test- repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"        2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"        2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint done\n"
"        2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept requests\n"
"        2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' configuration option to true\n"
"        2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"        2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 I> authenticated"

#: ../doc/1.7/book/replication/repl_add_instances.rst:137
msgid "Next, we add master#3 URI to ``replication`` parameter on the existing two masters. Replication-related parameters are dynamic, so we only need to make a ``box.cfg{}`` request on each of the running instances:"
msgstr "Затем добавляем URI мастера №3 в параметр ``replication`` на существующих мастерах. В конфигурации репликации используются динамические параметры, поэтому необходимо только выполнить запрос ``box.cfg{}`` на каждом работающем экземпляре:"

#: ../doc/1.7/book/replication/repl_add_instances.rst:141
msgid ""
"# adding master #3 URI to replication sources\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."
msgstr ""
"# добавление URI мастера №3 в источники репликации\n"
"      tarantool> box.cfg{replication =\n"
"               > {'replicator:password@192.168.0.101:3301',\n"
"               > 'replicator:password@192.168.0.102:3301',\n"
"               > 'replicator:password@192.168.0.103:3301'}}\n"
"      ---\n"
"      ..."

#: ../doc/1.7/book/replication/repl_add_instances.rst:151
msgid "When master #3 catches up with the other masters' state, we can disable read-only mode for this instance:"
msgstr "Когда мастер №3 получает все необходимые изменения от других мастеров, можно отключить режим только для чтения:"

#: ../doc/1.7/book/replication/repl_add_instances.rst:154
msgid ""
"# making master #3 a real master\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."
msgstr ""
"# определение мастера №3 настоящим мастером\n"
"        tarantool> box.cfg{read_only=false}\n"
"        ---\n"
"        ..."

#: ../doc/1.7/book/replication/repl_add_instances.rst:161
msgid "We also recommend to specify master #3 URI in all instance files in order to keep all the files consistent with each other and with the current replication topology."
msgstr "Также рекомендуется указать URI мастера №3 во всех файлах экземпляра, чтобы сохранить единообразие файлов и согласовать их с текущей топологией репликации."

#: ../doc/1.7/book/replication/repl_architecture.rst:5
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../doc/1.7/book/replication/repl_architecture.rst:11
msgid "Replication mechanism"
msgstr "Механизм репликации"

#: ../doc/1.7/book/replication/repl_architecture.rst:13
msgid "A pack of instances which operate on copies of the same databases make up a **replica set**. Each instance in a replica set has a role, **master** or **replica**."
msgstr "Набор экземпляров, которые работают на копиях одной базы данных, составляют **набор реплик**. У каждого экземпляра в наборе реплик есть роль: **мастер** или **реплика**."

#: ../doc/1.7/book/replication/repl_architecture.rst:17
msgid "A replica gets all updates from the master by continuously fetching and applying its :ref:`write ahead log (WAL)<internals-wal>`. Each record in the WAL represents a single Tarantool data-change request such as :ref:`INSERT<box_space-insert>`, :ref:`UPDATE<box_space-update>` or :ref:`DELETE<box_space-delete>`, and is assigned a monotonically growing log sequence number (**LSN**). In essence, Tarantool replication is **row-based**: each data-change request is fully deterministic and operates on a single :ref:`tuple<index-box_tuple>`. However, unlike a classical row-based log, which contains entire copies of the changed rows, Tarantool's WAL contains copies of the requests. For example, for UPDATE requests, Tarantool only stores the primary key of the row and the update operations, to save space."
msgstr "Реплика получает все обновления от мастера, постоянно запрашивая и применяя данные :ref:`журнала упреждающей записи (WAL)<internals-wal>`. Каждая запись в WAL представляет собой отдельный запрос на изменение данных в Tarantool’е, например, :ref:`INSERT<box_space-insert>`, :ref:`UPDATE<box_space-update>` или :ref:`DELETE<box_space-delete>`. Такой записи присваивается монотонно возрастающее число, представляющее регистрационный номер в журнале (**LSN**). По сути, репликация в Tarantool’е является **построчной**: каждая команда на изменение данных полностью детерминирована и относится к отдельному :ref:`кортежу<index-box_tuple>`. Однако в отличие от типичного построчного журнала, который содержит копии измененных строк полностью, WAL в Tarantool'е включает в себя копии запросов. Например, для запросов типа UPDATE (обновление) Tarantool сохранит только первичный ключ строки и операции обновления для экономии места."

#: ../doc/1.7/book/replication/repl_architecture.rst:28
msgid "Invocations of **stored programs** are not written to the WAL. Instead, records of the actual **data-change requests, performed by the Lua code**, are written to the WAL. This ensures that possible non-determinism of Lua does not cause replication to go out of sync."
msgstr "Вызовы **хранимых процедур** не регистрируются в журнале упреждающей записи. Между тем, события по запросам **изменения фактических данных, которые выполняют Lua-скрипты**, регистрируются в журнале. Таким образом, возможное недетерминированное выполнение Lua гарантированно не приведет к рассинхронизации."

#: ../doc/1.7/book/replication/repl_architecture.rst:33
msgid "Data definition operations on **temporary spaces**, such as creating/dropping, adding indexes, truncating, etc., are written to the WAL, since information about temporary spaces is stored in non-temporary system spaces, such as :ref:`box.space._space <box_space-space>`. Data change operations on temporary spaces are not written to the WAL and are not replicated."
msgstr "Операции по определению данных во **временных спейсах**, такие как создание/удаление, добавление индексов, усечение и т.д., регистрируются в журнале, поскольку информация о временных спейсах хранится в постоянных системных спейсах, например :ref:`box.space._space <box_space-space>`. Операции по изменению данных во временных спейсах не регистрируются в журнале и не реплицируются."

#: ../doc/1.7/book/replication/repl_architecture.rst:39
msgid "To create a valid initial state, to which WAL changes can be applied, every instance of a replica set requires a start set of :ref:`checkpoint files <index-box_persistence>`, such as .snap files for memtx and .run files for vinyl. A replica joining an existing replica set, chooses an existing master and automatically downloads the initial state from it. This is called an **initial join**."
msgstr "Чтобы создать подходящее начальное состояние, к которому можно применить изменения из WAL-файла, для каждого экземпляра из набора реплик должен быть исходный набор :ref:`файлов контрольной точки <index-box_persistence>` — .snap-файлы для memtx и .run-файлы для vinyl. Когда реплика включается в существующий набор реплик, она выбирает существующего мастера и автоматически загружает с него начальное состояние. Это называется **начальным включением**."

#: ../doc/1.7/book/replication/repl_architecture.rst:46
msgid "When an entire replica set is bootstrapped for the first time, there is no master which could provide the initial checkpoint. In such case, replicas connect to each other, elect a master, which then creates the starting set of checkpoint files, and distributes it across all other replicas. This is called an **automatic bootstrap** of a replica set."
msgstr "При первой настройке целого набора реплик нет мастера, который предоставил бы начальную контрольную точку. В таком случае реплики подключаются друг к другу, выбирают мастера, который затем создает начальный набор файлов контрольной точки и отправляет его всем репликам. Это называется **самонастройкой** набора реплик."

#: ../doc/1.7/book/replication/repl_architecture.rst:52
msgid "When a replica contacts a master (there can be many masters) for the first time, it becomes part of a replica set. On subsequent occasions, it should always contact a master in the same replica set. Once connected to the master, the replica requests all changes that happened after the latest local LSN (there can be many LSNs -- each master has its own LSN)."
msgstr "Когда реплика впервые подключается к мастеру (может быть много мастеров), она становится частью набора реплик. В последующих случаях она всегда должна подключаться к мастеру в этом наборе реплик. После подключения к мастеру реплика запрашивает все изменения, произошедшие с момента последнего локального LSN (может быть много LSN — у каждого мастера свой LSN)."

#: ../doc/1.7/book/replication/repl_architecture.rst:58
msgid "Each replica set is identified by a globally unique identifier, called **replica set UUID**. The identifier is created by the master which creates the very first checkpoint, and is part of the checkpoint file. It is stored in system space :ref:`box.space._schema <box_space-schema>`. For example:"
msgstr "Каждый набор реплик можно определить по глобально-уникальному идентификатору, который называется **UUID набора реплик**. Идентификатор создается мастером во время создания самой первой контрольной точки и является частью файла контрольной точки. Он хранится в системном спейсе :ref:`box.space._schema <box_space-schema>`. Пример:"

#: ../doc/1.7/book/replication/repl_architecture.rst:63
msgid ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""
"tarantool> box.space._schema:select{'cluster'}\n"
"       ---\n"
"       - - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"       ..."

#: ../doc/1.7/book/replication/repl_architecture.rst:70
msgid "Additionally, each instance in a replica set is assigned its own UUID, when it joins the replica set. It is called an **instance UUID** and is a globally unique identifier. This UUID is used to ensure that instances do not join a different replica set, e.g. because of a configuration error. A unique instance identifier is also necessary to apply rows originating from different masters only once, that is, implement multi-master replication. This is why each row in the write ahead log, in addition to its log sequence number, stores the instance identifier of the instance on which it was created. But using UUID as such an identifier would take too much space in the write ahead log, thus a shorter integer number is assigned to the instance when it joins a replica set. This number is then used to refer to the instance in the write ahead log. It is called **instance id**. All identifiers are stored in system space :ref:`box.space._cluster <box_space-cluster>`. For example:"
msgstr "Кроме того, каждому экземпляру в наборе реплик присваивается свой UUID, когда он включается в набор реплик. Такой глобально-уникальный идентификатор называется *UUID экземпляра**. Этот UUID используется для того, чтобы экземпляры не подключались к различным наборам реплик, например, из-за ошибки конфигурации. Уникальный идентификатор экземпляра также необходим для однократного применения строк от разных мастеров, то есть при многомастерной репликации. Вот почему каждая строка в журнале упреждающей записи, помимо номер записи в журнале, хранит идентификатор экземпляра, где запись была создана. Но использование UUID в качестве такого идентификатора заняло бы слишком много места в журнале упреждающей записи, поэтому экземпляру присваивается целое число при включении в набор реплик. Это число, которое называется **ID экземпляра**, затем используется для ссылок на экземпляр в журнале упреждающей записи. Все идентификаторы хранятся в системном спейсе :ref:`box.space._cluster <box_space-cluster>`. Например:"

#: ../doc/1.7/book/replication/repl_architecture.rst:91
msgid "Here the instance ID is ``1`` (unique within the replica set), and the instance UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally unique)."
msgstr "Здесь ID экземпляра — ``1`` (уникальный номер в рамках набора реплик), а UUID экземпляра — ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (глобально уникальный)."

#: ../doc/1.7/book/replication/repl_architecture.rst:94
msgid "Using shorter numeric identifiers is also handy to track the state of the entire replica set. For example, :ref:`box.info.vclock <box_introspection-box_info>` describes the state of replication in regard to each connected peer."
msgstr "Использование более коротких числовых идентификаторов также полезно для отслеживания состояния всего набора реплик. Например, :ref:`box.info.vclock <box_introspection-box_info>` описывает состояние репликации в отношении каждого подключенного узла."

#: ../doc/1.7/book/replication/repl_architecture.rst:98
msgid ""
"tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""
"tarantool> box.info.vclock\n"
"      ---\n"
"      - {1: 827, 2: 584}\n"
"      ..."

#: ../doc/1.7/book/replication/repl_architecture.rst:105
msgid "Here ``vclock`` contains log sequence numbers (827 and 584) for instances with short identifiers 1 and 2."
msgstr "Здесь ``vclock`` содержит номера записей в журнале (827 и 584) для экземпляров с короткими идентификаторами 1 и 2."

#: ../doc/1.7/book/replication/repl_architecture.rst:108
msgid "Starting in Tarantool 1.7.7, it is possible for administrators to assign the instance UUID and the replica set UUID values, rather than let the system generate them -- see the description of the :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>` configuration parameter."
msgstr "Начиная с Tarantool 1.7.7, появилась возможность для администраторов назначать UUID экземпляра и UUID набора реплик вместо сгенерированных системой значений — см. описание конфигурационного параметра :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`."

#: ../doc/1.7/book/replication/repl_architecture.rst:117
msgid "Replication setup"
msgstr "Настройка репликации"

#: ../doc/1.7/book/replication/repl_architecture.rst:119
msgid "To enable replication, you need to specify two parameters in a ``box.cfg{}`` request:"
msgstr "Чтобы включить репликацию, необходимо указать два параметра в запросе ``box.cfg{}``:"

#: ../doc/1.7/book/replication/repl_architecture.rst:122
msgid ":ref:`replication <cfg_replication-replication>` parameter which defines the replication source(s), and"
msgstr "параметр :ref:`replication <cfg_replication-replication>`, который определяет источники репликации, и"

#: ../doc/1.7/book/replication/repl_architecture.rst:124
msgid ":ref:`read_only <cfg_basic-read_only>` parameter which is ``true`` for a replica and ``false`` for a master."
msgstr "параметр :ref:`read_only <cfg_basic-read_only>` со значением ``true`` для реплики и ``false`` для мастера."

#: ../doc/1.7/book/replication/repl_architecture.rst:127
msgid "Both these parameters are \"dynamic\". This allows a replica to become a master and vice versa on the fly with the help of a ``box.cfg{}`` request."
msgstr " \"Динамические\" параметры репликации можно менять на лету, что позволяет назначать реплику на роль мастера и наоборот. Для этого используется запрос ``box.cfg{}``."

#: ../doc/1.7/book/replication/repl_architecture.rst:130
msgid "Further we're giving a detailed example of :ref:`bootstrapping a replica set <replication-bootstrap>`."
msgstr "Далее подробно рассмотрим пример :ref:`настройки набора реплик <replication-bootstrap>`."

#: ../doc/1.7/book/replication/repl_architecture.rst:137
msgid "Replication roles: master and replica"
msgstr "Роли в репликации: мастер и реплика"

#: ../doc/1.7/book/replication/repl_architecture.rst:139
msgid "Replication role (master or replica) is set in :ref:`read_only <cfg_basic-read_only>` configuration parameter. The recommended role for **all-but-one** instances in a replica set is \"read-only\" (replica)."
msgstr "Конфигурационный параметр :ref:`read_only <cfg_basic-read_only>` определяет роль в репликации (мастер или реплика). Рекомендованная роль для **всех экземпляров, кроме одного**, в наборе реплик — \"read-only\" (реплика)."

#: ../doc/1.7/book/replication/repl_architecture.rst:143
msgid "In a master-replica configuration, every change that happens on the master will be visible on the replicas, but not vice versa."
msgstr "В конфигурации мастер-реплика каждое изменение, сделанное на мастере, будет отображаться на репликах, но не наоборот."

#: ../doc/1.7/book/replication/repl_architecture.rst:149
msgid "A simple two-instance replica set with the master on one machine and the replica on a different machine provides two benefits:"
msgstr "Простой набор реплик с двумя экземплярами, один из которых является мастером и расположен на одной машине, а другой — реплика — расположен на другой машине, дает два преимущества:"

#: ../doc/1.7/book/replication/repl_architecture.rst:152
msgid "**failover**, because if the master goes down then the replica can take over, and"
msgstr "**восстановление после отказа**, поскольку в случае отказа мастера реплика может взять работу на себя, и"

#: ../doc/1.7/book/replication/repl_architecture.rst:154
msgid "**load balancing**, because clients can connect to either the master or the replica for read requests."
msgstr "**балансировка нагрузки**, потому что клиенты во время запросов чтения могут подключаться к мастеру или к реплике."

#: ../doc/1.7/book/replication/repl_architecture.rst:157
msgid "In a **master-master** configuration (also called \"multi-master\"), every change that happens on either instance will be visible on the other one."
msgstr "В конфигурации **мастер-мастер** (которая также называется \"многомастерной\") каждое изменение на любом экземпляре будет также отображаться на другом."

#: ../doc/1.7/book/replication/repl_architecture.rst:163
msgid "The failover benefit in this case is still present, and the load-balancing benefit is enhanced, because any instance can handle both read and write requests. Meanwhile, for multi-master configurations, it is necessary to understand the **replication guarantees** provided by the asynchronous protocol that Tarantool implements."
msgstr "Восстановление после отказа в таком случае также будет преимуществом, а балансировка нагрузки улучшится, поскольку любой экземпляр может обрабатывать запросы и на чтение, и на запись. В то же время, при многомастерной конфигурации необходимо понимать **гарантии репликации**, которые обеспечивает асинхронный протокол, внедренный в Tarantool."

#: ../doc/1.7/book/replication/repl_architecture.rst:169
msgid "Tarantool multi-master replication guarantees that each change on each master is propagated to all instances and is applied only once. Changes from the same instance are applied in the same order as on the originating instance. Changes from different instances, however, can mix and apply in a different order on different instances. This may lead to replication going out of sync in certain cases."
msgstr "Многомастерная репликация Tarantool'а гарантирует, что каждое изменение на каждом мастере передается на все экземпляры и применяется только один раз. Изменения с одного экземпляра применяются в том же порядке, что и на исходном экземпляре. Однако изменения с разных экземпляров могут смешиваться и применяться в различном порядке на разных экземплярах. В определенных случаях это может привести к рассинхронизации."

#: ../doc/1.7/book/replication/repl_architecture.rst:176
msgid "For example, assuming the database is only appended to (i.e. it contains only insertions), it is safe to set each instance to a master. If there are also deletions, but it is not mission critical that deletion happens in the same order on all replicas (e.g. the DELETE is used to prune expired data), a master-master configuration is also safe."
msgstr "Например, принимая, что проводятся только операции добавления данных в базу (т.е. она содержит только вставки), можно с уверенностью назначить все экземпляры мастерами. Если данные также удаляются, но порядок операций удаления на разных репликах не играет важной роли (например, DELETE используется для отсечения устаревших данных), то конфигурация мастер-мастер также безопасна."

#: ../doc/1.7/book/replication/repl_architecture.rst:182
msgid "UPDATE operations, however, can easily go out of sync. For example, assignment and increment are not commutative, and may yield different results if applied in different order on different instances."
msgstr "Однако операции обновления UPDATE могут с легкостью привести к рассинхронизации. Например, операции присваивания и увеличения не обладают коммутативностью и могут привести к различным результатам, если применять их в различном порядке на разных экземплярах."

#: ../doc/1.7/book/replication/repl_architecture.rst:186
msgid "More generally, it is only safe to use Tarantool master-master replication if all database changes are **commutative**: the end result does not depend on the order in which the changes are applied. You can start learning more about conflict-free replicated data types `here <https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>`_."
msgstr "В общем смысле, безопасно использовать репликацию мастер-мастер в Tarantool'е, если все изменения в базе данных являются **коммутативными**: конечный результат не зависит от порядка, в котором применяются изменения. Дополнительную информацию о бесконфликтных типах реплицируемых данных можно получить `здесь <https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>`_."

#: ../doc/1.7/book/replication/repl_architecture.rst:196
msgid "Replication topologies: cascade, ring and full mesh"
msgstr "Топологии репликации: каскадная, кольцевая и полная ячеистая"

#: ../doc/1.7/book/replication/repl_architecture.rst:198
msgid "Replication topology is set in :ref:`replication <cfg_replication-replication>` configuration parameter. The recommended topology is a **full mesh**, because it makes potential failover easy."
msgstr "Топология репликации определяется в конфигурационном параметре :ref:`replication <cfg_replication-replication>`. Рекомендована **полная ячеистая** конфигурация, поскольку она облегчает возможное восстановление после сбоя."

#: ../doc/1.7/book/replication/repl_architecture.rst:202
msgid "Some database products offer **cascading replication** topologies: creating a replica on a replica. Tarantool does not recommend such setup."
msgstr "Некоторые СУБД предлагают топологии **каскадной репликации**: создание реплики на реплике. Tarantool не рекомендует такие настройки."

#: ../doc/1.7/book/replication/repl_architecture.rst:208
msgid "The problem with a cascading replica set is that some instances have no connection to other instances and may not receive changes from them. One essential change that must be propagated across all instances in a replica set is an entry in ``box.space._cluster`` system space with replica set UUID. Without knowing a replica set UUID, a master refuses to accept connections from such instances when replication topology changes. Here is how this can happen:"
msgstr "Недостаток каскадного набора реплик заключается в том, что некоторые экземпляры не подключаются к другим экземплярам, поэтому не могут получать от них изменения. Одно важное изменение, которое следует передавать на все экземпляры в наборе реплик — запись в системный спейс ``box.space._cluster`` с UUID набора реплик. Не зная UUID набора реплик, мастер отклоняет подключения от таких экземпляров при изменении топологии репликации. Вот как это может произойти:"

#: ../doc/1.7/book/replication/repl_architecture.rst:218
msgid "We have a chain of three instances. Instance #1 contains entries for instances #1 and #2 in its ``_cluster`` space. Instances #2 and #3 contain entries for instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr "У нас есть цепочка из трех экземпляров. Экземпляр №1 содержит записи для экземпляров №1 и №2 в спейсе ``_cluster``. Экземпляры №2 и №3 содержат записи для экземпляров №1, №2 и №3 в своих спейсах ``_cluster``."

#: ../doc/1.7/book/replication/repl_architecture.rst:225
msgid "Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as its new master, but the master refuses the connection since it has no entry for instance #3."
msgstr "Теперь экземпляр №2 неисправен. Экземпляр №3 пытается подключиться к экземпляру №1, как к новому мастеру, но мастер отклоняет подключение, поскольку не содержит запись для экземпляра №3."

#: ../doc/1.7/book/replication/repl_architecture.rst:229
msgid "**Ring replication** topology is, however, supported:"
msgstr "Тем не менее, **кольцевая топология** поддерживается:"

#: ../doc/1.7/book/replication/repl_architecture.rst:234
msgid "So, if you need a cascading topology, you may first create a ring to ensure all instances know each other’s UUID, and then disconnect the chain in the place you desire."
msgstr "Поэтому если необходима каскадная топология, можно первоначально создать кольцо, чтобы все экземпляры знали UUID друг друга, а затем разъединить цепочку в необходимом месте."

#: ../doc/1.7/book/replication/repl_architecture.rst:238
msgid "A stock recommendation for a master-master replication topology, however, is a **full mesh**:"
msgstr "Как бы то ни было, для репликации мастер-мастер рекомендуется **полная ячеистая** топология:"

#: ../doc/1.7/book/replication/repl_architecture.rst:244
msgid "You then can decide where to locate instances of the mesh -- within the same data center, or spread across a few data centers. Tarantool will automatically ensure that each row is applied only once on each instance. To remove a degraded instance from a mesh, simply change ``replication`` configuration parameter."
msgstr "В таком случае можно решить, где расположить экземпляры ячейки — в том же центре обработки данных или разместить в нескольких центрах. Tarantool будет автоматически следить за тем, что каждая строка применяется однократно на каждом экземпляре. Чтобы удалить экземпляр из ячейки после отказа, просто измените конфигурационный параметр ``replication``."

#: ../doc/1.7/book/replication/repl_architecture.rst:249
msgid "This ensures full cluster availability in case of a local failure, e.g. one of the instances failing in one of the data centers, as well as in case of an entire data center failure."
msgstr "Таким образом можно обеспечить доступность всего кластера в случае локального отказа, например отказа одного экземпляра в одном центре обработки данных, а также в случае отказа всего центра обработки данных."

#: ../doc/1.7/book/replication/repl_architecture.rst:253
msgid "The maximal number of replicas in a mesh is 32."
msgstr "Максимальное количество реплик в ячейке — 32."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:5
msgid "Bootstrapping a replica set"
msgstr "Настройка набора реплик"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:11
msgid "Master-replica bootstrap"
msgstr "Настройка репликации мастер-реплика"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:13
msgid "Let's first bootstrap a simple **master-replica** set containing two instances, each located on its own machine. For easier administration, we make the :ref:`instance files <admin-instance_file>` almost identical."
msgstr "Сначала настроим простой набор **мастер-реплика** с двумя экземплярами, каждый из которых находится на отдельном сервере. Для удобства администрирования сделаем :ref:`файлы экземпляров <admin-instance_file>` практически одинаковыми."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:20
msgid "Here is an example of the master's instance file:"
msgstr "Ниже пример файла экземпляра для мастера:"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:22
msgid ""
"-- instance file for the master\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master')\n"
"end)"
msgstr ""
"-- файл экземпляра для мастера\n"
"       box.cfg{\n"
"         listen = 3301,\n"
"         replication = {'replicator:password@192.168.0.101:3301',  -- URI мастера\n"
"                        'replicator:password@192.168.0.102:3301'}, -- URI реплики\n"
"         read_only = false\n"
"       }\n"
"       box.once(\"schema\", function()\n"
"          box.schema.user.create('replicator', {password = 'password'})\n"
"          box.schema.user.grant('replicator', 'replication') -- настроить роль для репликации\n"
"          box.schema.space.create(\"test\")\n"
"          box.space.test:create_index(\"primary\")\n"
"          print('box.once executed on master')\n"
"       end)"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:41
msgid ":ref:`listen <cfg_basic-listen>` parameter from ``box.cfg{}`` defines a URI (port 3301 in our example), on which the master can accept connections from replicas."
msgstr "параметр :ref:`listen <cfg_basic-listen>` из ``box.cfg{}`` определяет URI (порт 3301 в нашем примере), на котором мастер может принимать подключения от реплик."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:44
msgid ":ref:`replication <cfg_replication-replication>` parameter defines the URIs at which all instances in the replica set can accept connections. It includes the replica's URI as well, although the replica is not a replication source right now."
msgstr "параметр :ref:`replication <cfg_replication-replication>` определяет URI, на которых все экземпляры в наборе реплик могут принимать подключения. Он включает в себя также URI реплики, хотя реплики в данном случае не является источником репликации."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:51
msgid "For security reasons, we recommend to prevent unauthorized replication sources by associating a password with every user that has a replication :ref:`role <authentication-roles>`. That way, the :ref:`URI <index-uri>` for ``replication`` parameter must have the long form ``username:password@host:port``."
msgstr "Для целей безопасности рекомендуем не допускать репликацию из неавторизованных источников с помощью установки пароля для каждого пользователя, у которого есть :ref:`роль <authentication-roles>` для репликации. Таким образом, :ref:`URI <index-uri>` для параметра ``replication``  должен иметь развернутый вид ``username:password@host:port``."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:57
msgid ":ref:`read_only <cfg_basic-read_only>` parameter enables data-change operations on the instance and makes this Tarantool instance act as a master, not as a replica. *That's the only parameter in our instance files that will differ.*"
msgstr "параметр :ref:`read_only <cfg_basic-read_only>` разрешает операции по изменению данных на экземпляре и заставляет данный экземпляр Tarantool'а работать в качестве мастера, а не реплики. *Это единственный параметр, который отличается в наших файлах экземпляров.*"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:61
msgid ":ref:`box.once() <box-once>` function contains database initialization logic that should be executed only once during the replica set lifetime."
msgstr "функция :ref:`box.once() <box-once>` содержит логику инициализации базы данных, которая должна выполняться однократно в течение срока работы набора реплик."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:64
msgid "In this example, we create a space with a primary index, and a user for replication purposes. We also say ``print('box.once executed on master')`` to see later in console whether ``box.once()`` is executed."
msgstr "В данном примере создаем спейс с первичным индексом и пользователя для целей репликации. Также выполним команду ``print('box.once executed on master')``, чтобы позднее увидеть в консоли, будет ли выполнена функция ``box.once()``."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:70
msgid "Replication requires privileges. We can grant privileges for accessing spaces directly to the user who will start the instance. However, it is more usual to grant privileges for accessing spaces to a :ref:`role <authentication-roles>`, and then grant the role to the user who will start the replica."
msgstr "Репликация требует настройки привилегий. Привилегии для доступа к спейсам можно задать напрямую для пользователя, под чьим именем запущен экземпляр. Но обычно привилегии на доступ к спейсам задаются с помощью :ref:`роли <authentication-roles>`, которая затем присваивается пользователю, под чьим именем запущена реплика."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:76
msgid "Here we use Tarantool's predefined role named \"replication\" which by default grants \"read\" privileges for all database objects (\"universe\"), and we can further set up privileges for this role as required."
msgstr "Здесь мы используем предварительно определенную роль Tarantool'а под названием \"replication\", которая по умолчанию предоставляет привилегии на \"чтение\" всех объектов в базе данных (\"universe\"), а также сможем в дальнейшем настроить необходимые привилегии для этой роли."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:80
msgid "In the replica's instance file, we only set read-only parameter to \"true\", and say ``print('box.once executed on replica')`` to make sure that box.once() is not executed more than once. Otherwise the replica's instance file is fully identical to the master's instance file."
msgstr "В файле экземпляра для реплики устанавливаем значение \"true\" для параметра read-only и выполняем команду ``print('box.once executed on replica')``, чтобы убедиться, что box.once() будет выполняться только однократно. В других отношениях файл экземпляра для реплики полностью совпадает с файлом экземпляра для мастера."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:85
msgid ""
"-- instance file for the replica\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica')\n"
"end)"
msgstr ""
"-- файл экземпляра для реплики\n"
"      box.cfg{\n"
"        listen = 3301,\n"
"        replication = {'replicator:password@192.168.0.101:3301',  -- URI мастера\n"
"                       'replicator:password@192.168.0.102:3301'}, -- URI реплики\n"
"        read_only = true\n"
"      }\n"
"      box.once(\"schema\", function()\n"
"         box.schema.user.create('replicator', {password = 'password'})\n"
"         box.schema.user.grant('replicator', 'replication') -- настроить роль для репликации\n"
"         box.schema.space.create(\"test\")\n"
"         box.space.test:create_index(\"primary\")\n"
"         print('box.once executed on replica')\n"
"      end)"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:104
msgid "The replica does not inherit the master’s configuration parameters, such as those making the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` run on the master. To get the same behavior, please set the relevant parameters explicitly so that they are the same on both master and replica."
msgstr "Реплика не берет конфигурационные параметры с мастера, например настройки запуска :ref:`фоновой программы для работы с контрольными точками <book_cfg_checkpoint_daemon>` на мастере. Чтобы получить те же настройки на реплике, нужно задать их явным образом."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:109
msgid "Now we can launch the two instances. The master..."
msgstr "Теперь можно запустить два экземпляра. Мастер..."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:111
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> can't connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. coio.cc:105 !> SystemError connect, called on fd 14, aka 192.168.0.102:56736: Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an empty data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot `/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"
msgstr ""
"$ # запуск мастера\n"
"      $ tarantool master.lua\n"
"      2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version 1.7.4-52-g980d30092\n"
"      2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"      2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 bytes for tuple arena...\n"
"      2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to [::]:3301\n"
"      2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> can't connect to master\n"
"      2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. coio.cc:105 !> SystemError connect, called on fd 14, aka 192.168.0.102:56736: Connection refused\n"
"      2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> will retry every 1 second\n"
"      2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"      2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"      2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an empty data directory\n"
"      2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot `/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"      2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"      2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint done\n"
"      2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept requests\n"
"      2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I> failed to authenticate\n"
"      2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"      box.once executed on master\n"
"      2017-06-14 14:12:19.920 [18933] main C> entering the event loop"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:134
msgid "... (yep, ``box.once()`` got executed on the master) -- and the replica:"
msgstr "... (да, функция``box.once()`` была выполнена на мастере) — и реплику:"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:136
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to [::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"
msgstr ""
"$ # запуск реплики\n"
"      $ tarantool replica.lua\n"
"      2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version 1.7.4-52-g980d30092\n"
"      2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"      2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456 bytes for tuple arena...\n"
"      2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to [::]:3311\n"
"      2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"      2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3302\n"
"      2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I> failed to authenticate\n"
"      2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:149
msgid "In both logs, there are messages saying that the replica got bootstrapped from the master:"
msgstr "В обоих журналах есть сообщения о том, что реплика получила настройки от мастера:"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:151
msgid ""
"$ # bootstrapping the replica (from the master's log)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I> authenticated"
msgstr ""
"$ # настройка реплики (из журнала мастера)\n"
"      <...>\n"
"      2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"      2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"      2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"      2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master_dir/00000000000000000000.xlog'\n"
"      2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I> authenticated"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:161
msgid ""
"$ # bootstrapping the replica (from the replica's log)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I> authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping replica from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> final data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"
msgstr ""
"$ # настройка реплики (из журнала реплики)\n"
"      <...>\n"
"      2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I> authenticated\n"
"      2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping replica from 192.168.0.101:3301\n"
"      2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> initial data received\n"
"      2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> final data received\n"
"      2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"      2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"      2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint done\n"
"      2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept requests\n"
"      2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' configuration option to true\n"
"      2017-06-14 14:12:20.520 [18934] main C> entering the event loop"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:176
msgid "Notice that ``box.once()`` was executed only at the master, although we added ``box.once()`` to both instance files."
msgstr "Обратите внимание, что функция ``box.once()`` была выполнена только на мастере, хотя мы добавили ``box.once()`` в оба файла экземпляра."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:179
msgid "We could as well launch the replica first:"
msgstr "Также можно было сначала запустить реплику."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:181
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> can't connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. coio.cc:105 !> SystemError connect, called on fd 13, aka 192.168.0.101:56820: Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301"
msgstr ""
"$ # запуск реплики\n"
"      $ tarantool replica.lua\n"
"      2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version 1.7.4-52-g980d30092\n"
"      2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"      2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456 bytes for tuple arena...\n"
"      2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to [::]:3301\n"
"      2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> can't connect to master\n"
"      2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. coio.cc:105 !> SystemError connect, called on fd 13, aka 192.168.0.101:56820: Connection refused\n"
"      2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> will retry every 1 second\n"
"      2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:194
msgid "... and the master later:"
msgstr "... а затем уже мастера:"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:196
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an empty data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot `/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I> authenticated"
msgstr ""
"$ # запуск мастера\n"
"      $ tarantool master.lua\n"
"      2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version 1.7.4-52-g980d30092\n"
"      2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"      2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 bytes for tuple arena...\n"
"      2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to [::]:3301\n"
"      2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"      2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"      2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an empty data directory\n"
"      2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot `/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"      2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"      2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint done\n"
"      2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept requests\n"
"      2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I> failed to authenticate\n"
"      2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"      box.once executed on master\n"
"      2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"      2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"      2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"      2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"      2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"      2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I> authenticated"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:221
msgid "In this case, the replica would wait for the master to become available, so the launch order doesn't matter. Our ``box.once()`` logic would also be executed only once, at the master."
msgstr "В данном случае реплика ожидает доступности мастера, поэтому порядок запуска не имеет значения. Наша функция ``box.once()`` также будет выполняться однократно, только на мастере."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:225
msgid ""
"$ # the replica has eventually connected to the master\n"
"$ # and got bootstrapped (from the replica's log)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping replica from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I> initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I> final data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"
msgstr ""
"$ # реплика в итоге подключена к мастеру\n"
"      $ # и получила настройки (из журнала реплики)\n"
"      2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"      2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> authenticated\n"
"      2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping replica from 192.168.0.199:3310\n"
"      2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I> initial data received\n"
"      2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I> final data received\n"
"      2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"      2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"      2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint done\n"
"      2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept requests\n"
"      2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' configuration option to true\n"
"      2017-06-14 14:35:43.795 [18952] main C> entering the event loop"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:245
msgid "Controlled failover"
msgstr "Контролируемое восстановление после сбоя"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:247
msgid "To perform a **controlled failover**, that is, swap the roles of the master and replica, all we need to do is to set ``read_only=true`` at the master, and ``read_only=false`` at the replica. The **order of actions** is important here. If a system is running in production, we don’t want concurrent writes happen both at the replica and the master. Nor do we want the new replica to accept any writes until it has finished fetching all replication data from the old master. To compare replica and master state, we can use :ref:`box.info.signature <box_introspection-box_info>`."
msgstr "Чтобы провести **контролируемое восстановление после сбоя**, то есть поменять роли мастера и реплики, нужно лишь настроить параметры ``read_only=true`` на мастере и ``read_only=false`` на реплике. **Порядок действий** в данном случае имеет значение. Если система принята в эксплуатацию, нам не нужна параллельная запись на реплике и на мастере. Нежелательно также, чтобы новая реплика принимала запись, пока не получит все реплицируемые данные со старого мастера. Чтобы сопоставить состояние реплики и мастера, можно использовать :ref:`box.info.signature <box_introspection-box_info>`."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:256
msgid "Set ``read_only=true`` at the master."
msgstr "Настройте ``read_only=true`` на мастере."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:258
msgid ""
"# at the master\n"
"tarantool> box.cfg{read_only=true}"
msgstr ""
"# на мастере\n"
"      tarantool> box.cfg{read_only=true}"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:263
msgid "Record the master’s current position with ``box.info.signature``, containing the sum of all LSNs in the master’s vector clock."
msgstr "Зарегистрируйте текущее состояние мастера с помощью ``box.info.signature``, которое содержит общее количество всех LSN в векторных часах мастера."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:266
msgid ""
"# at the master\n"
"tarantool> box.info.signature"
msgstr ""
"# на мастере\n"
"        tarantool> box.info.signature"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:271
msgid "Wait until the replica’s signature is the same as the master’s."
msgstr "Подождите, пока сигнатура реплики не совпадет с сигнатурой мастера."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:273
msgid ""
"# at the replica\n"
"tarantool> box.info.signature"
msgstr ""
"# на реплике\n"
"        tarantool> box.info.signature"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:278
msgid "Set ``read_only=false`` at the replica to enable write operations."
msgstr "Настройте `read_only=false`` на реплике, чтобы запустить операции записи данных."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:280
msgid ""
"# at the replica\n"
"tarantool> box.cfg{read_only=false}"
msgstr ""
"# на реплике\n"
"      tarantool> box.cfg{read_only=false}"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:285
msgid "These 4 steps ensure that the replica doesn’t accept new writes until it’s done fetching writes from the master."
msgstr "Эти шаги нужны для того, чтобы реплика гарантированно не принимала новые записи, пока не получит данные от мастера."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:292
msgid "Master-master bootstrap"
msgstr "Настройка репликации мастер-мастер"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:294
msgid "Now let's bootstrap a two-instance **master-master** set. For easier administration, we make master#1 and master#2 instance files fully identical."
msgstr "Теперь настроим набор с двумя экземплярами **мастер-мастер**. Для удобства управления сделаем файлы экземпляра для мастера №1 и мастера №2 практически одинаковыми."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:300
msgid "We re-use the master's instance file from the :ref:`master-replica example <replication-master_replica_bootstrap>` above."
msgstr "Переиспользуем файл экземпляра для мастера из вышеописанного :ref:`примера мастер-реплика <replication-master_replica_bootstrap>`."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:303
msgid ""
"-- instance file for any of the two masters\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master1 URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- master2 URI\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master #1')\n"
"end)"
msgstr ""
"-- файл экземпляра для любого из двух мастеров\n"
"      box.cfg{\n"
"        listen      = 3301,\n"
"        replication = {'replicator:password@192.168.0.101:3301',  -- URI мастера 1\n"
"                       'replicator:password@192.168.0.102:3301'}, -- URI мастера 2\n"
"        read_only   = false\n"
"      }\n"
"      box.once(\"schema\", function()\n"
"         box.schema.user.create('replicator', {password = 'password'})\n"
"         box.schema.user.grant('replicator', 'replication') -- настроить роль для репликации\n"
"         box.schema.space.create(\"test\")\n"
"         box.space.test:create_index(\"primary\")\n"
"         print('box.once executed on master #1')\n"
"      end)"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:320
msgid "In :ref:`replication <cfg_replication-replication>` parameter, we define the URIs of both masters in the replica set and say ``print('box.once executed on master #1')`` to see when and where the ``box.once()`` logic is executed."
msgstr "В параметре :ref:`replication <cfg_replication-replication>` определим URI обоих мастеров в наборе реплик и выполним команду ``print('box.once executed on master #1')``, чтобы увидеть, когда и где будет выполнена логика функции ``box.once()``."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:325
msgid "Now we can launch the two masters. Again, the launch order doesn't matter. The ``box.once()`` logic will also be executed only once, at the master which is elected as the replica set leader at bootstrap."
msgstr "Теперь можно запустить оба мастера. Повторимся, что порядок запуска не имеет значения. Логика ``box.once()`` также будет выполняться лишь однократно на мастере, который будет выбран лидером в наборе реплик при настройке."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:329
msgid ""
"$ # launching master #1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 coio.cc:107 !> SystemError connect, called on fd 14, aka 192.168.0.102:57110: Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> will retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping replica from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"
msgstr ""
"$ # запуск мастера №1\n"
"      $ tarantool master1.lua\n"
"      2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version 1.7.4-52-g980d30092\n"
"      2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"      2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456 bytes for tuple arena...\n"
"      2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to [::]:3301\n"
"      2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> can't connect to master\n"
"      2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 coio.cc:107 !> SystemError connect, called on fd 14, aka 192.168.0.102:57110: Connection refused\n"
"      2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> will retry every 1 second\n"
"      2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"      2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"      2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 I> authenticated\n"
"      2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping replica from 192.168.0.102:3301\n"
"      2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 I> initial data received\n"
"      2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 I> final data received\n"
"      2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"      2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"      2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint done\n"
"      2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept requests\n"
"      box.once executed on master #1\n"
"      2017-06-14 15:39:08.077 [47021] main C> entering the event loop"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:353
msgid ""
"$ # launching master #2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an empty data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 I> authenticated"
msgstr ""
"$ # запуск мастера №2\n"
"      $ tarantool master2.lua\n"
"      2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version 1.7.4-52-g980d30092\n"
"      2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"      2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456 bytes for tuple arena...\n"
"      2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to [::]:3301\n"
"      2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"      2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"      2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an empty data directory\n"
"      2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"      2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"      2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint done\n"
"      2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept requests\n"
"      2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"      2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"      2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.xlog'\n"
"      2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"      2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.xlog'\n"
"      2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 I> authenticated"

#: ../doc/1.7/book/replication/repl_duplicates.rst:5
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../doc/1.7/book/replication/repl_duplicates.rst:7
msgid "Tarantool guarantees that every update is applied only once at every replica. However, due to asynchronous nature of the replication, the order of updates is not guaranteed. Further we analyse this problem in more details, provide examples of replication going out of sync, and suggest solutions."
msgstr "Tarantool гарантирует, что все обновления применяются однократно на каждой реплике. Однако, поскольку репликация носит асинхронный характер, порядок обновлений не гарантируется. Далее мы проанализируем данную проблему более подробно с примерами рассинхронизации репликации и предложим соответствующие решения."

#: ../doc/1.7/book/replication/repl_duplicates.rst:16
msgid "Replication stops"
msgstr "Остановка репликации"

#: ../doc/1.7/book/replication/repl_duplicates.rst:18
msgid "In a replica set of two masters, suppose master #1 tries to do something that master #2 has already done. For example, try to simultaneously insert a tuple with the same unique key:"
msgstr "Предположим, что в наборе реплик с двумя мастерами мастер №1 пытается сделать что-то, что уже было сделано мастером №2. Например, попробуйте одновременно вставить кортеж с одинаковым уникальным ключом:"

#: ../doc/1.7/book/replication/repl_duplicates.rst:22
msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr "tarantool> box.space.tester:insert{1, 'data'}"

#: ../doc/1.7/book/replication/repl_duplicates.rst:26
msgid "This would cause an error saying ``Duplicate key exists in unique index 'primary' in space 'tester'`` and the replication would be stopped."
msgstr "Это вызовет сообщение об ошибке дубликата ключа (``Duplicate key exists in unique index 'primary' in space 'tester'``), и репликация остановится."

#: ../doc/1.7/book/replication/repl_duplicates.rst:29
msgid ""
"$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop"
msgstr ""
"$ # сообщения об ошибках от мастера №1\n"
"      2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"      2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"      Duplicate key exists in unique index 'primary' in space 'tester'\n"
"      2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"      2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop\n"
"      \n"
"      $ # сообщения об ошибках от мастера №2\n"
"      2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"      2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"      Duplicate key exists in unique index 'primary' in space 'tester'\n"
"      2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"      2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop"

#: ../doc/1.7/book/replication/repl_duplicates.rst:45
msgid "If we check replication statuses with ``box.info``, we'll see that replication at master #1 is stopped (``1.upstream.status = stopped``). Additionally, no data is replicated from that master (section ``1.downstream`` is missing in the report), because the downstream has encountered the same error:"
msgstr "Если мы проверим статус репликации с помощью ``box.info``, то увидим, что репликация на мастере №1 остановлена (``1.upstream.status = stopped``). Кроме того, данные с этого мастера не реплицируются (группа ``1.downstream`` отсутствует в отчете), поскольку встречается та же ошибка:"

#: ../doc/1.7/book/replication/repl_duplicates.rst:50
msgid ""
"# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space 'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""
"# статусы репликации (отчет от мастера №3)\n"
"      tarantool> box.info\n"
"      ---\n"
"      - version: 1.7.4-52-g980d30092\n"
"        id: 3\n"
"        ro: false\n"
"        vclock: {1: 9, 2: 1000000, 3: 3}\n"
"        uptime: 557\n"
"        lsn: 3\n"
"        vinyl: []\n"
"        cluster:\n"
"          uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"        pid: 30445\n"
"        status: running\n"
"        signature: 1000012\n"
"        replication:\n"
"          1:\n"
"            id: 1\n"
"            uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"            lsn: 9\n"
"            upstream:\n"
"              peer: replicator@192.168.0.101:3301\n"
"              lag: 0.00050592422485352\n"
"              status: stopped\n"
"              idle: 445.8626639843\n"
"              message: Duplicate key exists in unique index 'primary' in space 'tester'\n"
"          2:\n"
"            id: 2\n"
"            uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"            lsn: 1000000\n"
"            upstream:\n"
"              status: follow\n"
"              idle: 201.99915885925\n"
"              peer: replicator@192.168.0.102:3301\n"
"              lag: 0.0015020370483398\n"
"            downstream:\n"
"              vclock: {1: 8, 2: 1000000, 3: 3}\n"
"          3:\n"
"            id: 3\n"
"            uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"            lsn: 3\n"
"        uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      ..."

#: ../doc/1.7/book/replication/repl_duplicates.rst:96
msgid "When replication is later manually resumed:"
msgstr "Когда позднее репликация возобновлена вручную:"

#: ../doc/1.7/book/replication/repl_duplicates.rst:98
msgid ""
"# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""
"# возобновление остановленной репликации (на всех мастерах)\n"
"      tarantool> original_value = box.cfg.replication\n"
"      tarantool> box.cfg{replication={}}\n"
"      tarantool> box.cfg{replication=original_value}"

#: ../doc/1.7/book/replication/repl_duplicates.rst:105
msgid "... the faulty row in the write ahead log files is skipped."
msgstr "... запись с ошибкой в журнале упреждающей записи пропущена."

#: ../doc/1.7/book/replication/repl_duplicates.rst:111
msgid "Replication runs out of sync"
msgstr "Рассинхронизация репликации"

#: ../doc/1.7/book/replication/repl_duplicates.rst:113
msgid "In a master-master cluster of two instances, suppose we make the following operation:"
msgstr "Предположим, что мы выполняем следующую операцию в кластере из двух экземпляров с конфигурацией мастер-мастер:"

#: ../doc/1.7/book/replication/repl_duplicates.rst:116
msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"

#: ../doc/1.7/book/replication/repl_duplicates.rst:120
msgid "When we get this operation applied on both instances in the replica set:"
msgstr "Когда эта операция применяется на обоих экземплярах в наборе реплик:"

#: ../doc/1.7/book/replication/repl_duplicates.rst:122
msgid ""
"# at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""
"# на мастере №1\n"
"        tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"        # на мастере №2\n"
"        tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"

#: ../doc/1.7/book/replication/repl_duplicates.rst:129
msgid "... we can have the following results, depending on the order of execution:"
msgstr "... можно получить следующие результаты в зависимости порядка выполнения:"

#: ../doc/1.7/book/replication/repl_duplicates.rst:131
msgid "each master’s row contains the uuid from master #1,"
msgstr "каждая строка мастера содержит UUID из мастера №1,"

#: ../doc/1.7/book/replication/repl_duplicates.rst:132
msgid "each master’s row contains the uuid from master #2,"
msgstr "каждая строка мастера содержит UUID из мастера №2,"

#: ../doc/1.7/book/replication/repl_duplicates.rst:133
msgid "master #1 has the uuid of master #2, and vice versa."
msgstr "у мастера №1 UUID мастера №2, и наоборот."

#: ../doc/1.7/book/replication/repl_duplicates.rst:139
msgid "Commutative changes"
msgstr "Коммутативные изменения"

#: ../doc/1.7/book/replication/repl_duplicates.rst:141
msgid "The cases described in previous paragraphs represent examples of **non-commutative** operations, i.e. operations, which result depends on the execution order. On the contrary, for **commutative operations**, the execution order doesn’t matter."
msgstr "Случаи, описанные в предыдущих абзацах, представляют собой примеры **некоммутативных** операций, т.е. операций, результат которых зависит от порядка их выполнения. Для **коммутативных операций** порядок выполнения значения не имеет."

#: ../doc/1.7/book/replication/repl_duplicates.rst:146
msgid "Consider for example the following command:"
msgstr "Рассмотрим, например, следующую команду:"

#: ../doc/1.7/book/replication/repl_duplicates.rst:148
msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"

#: ../doc/1.7/book/replication/repl_duplicates.rst:152
msgid "This operation is commutative: we get the same result no matter in which order the update is applied on the other masters."
msgstr "Эта операция коммутативна: получаем одинаковый результат, независимо от порядка, в котором обновление применяется на других мастерах."

#: ../doc/1.7/book/replication/repl_monitoring.rst:5
msgid "Monitoring a replica set"
msgstr "Мониторинг набора реплик"

#: ../doc/1.7/book/replication/repl_monitoring.rst:7
msgid "To learn what instances belong in the replica set, and obtain statistics for all these instances, use :ref:`box.info.replication <box_info_replication>` request:"
msgstr "Чтобы узнать, какие экземпляры входят в набор реплик и получить статистику по всем этим экземплярам, используйте запрос :ref:`box.info.replication <box_info_replication>`:"

#: ../doc/1.7/book/replication/repl_monitoring.rst:10
msgid ""
"tarantool> box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0\n"
"      downstream:\n"
"     vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        peer: replicator@192.168.0.103:3301\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."
msgstr ""
"tarantool> box.info.replication\n"
"      ---\n"
"        replication:\n"
"          1:\n"
"            id: 1\n"
"            uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"            lsn: 88\n"
"          2:\n"
"            id: 2\n"
"            uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"            lsn: 31\n"
"            upstream:\n"
"              status: follow\n"
"              idle: 43.187747001648\n"
"              peer: replicator@192.168.0.102:3301\n"
"              lag: 0\n"
"            downstream:\n"
"           vclock: {1: 31}\n"
"          3:\n"
"            id: 3\n"
"            uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"            lsn: 54\n"
"            upstream:\n"
"              status: follow\n"
"              idle: 43.187621831894\n"
"              peer: replicator@192.168.0.103:3301\n"
"              lag: 2\n"
"            downstream:\n"
"              vclock: {1: 54}\n"
"      ..."

#: ../doc/1.7/book/replication/repl_monitoring.rst:43
msgid "This report is for a master-master replica set of three instances, each having its own instance id, UUID and log sequence number."
msgstr "Данный отчет сгенерирован для набора реплик из трех экземпляров с конфигурацией мастер-мастер, у каждого из которых есть свой собственный ID экземпляра, UUID и номер записи в журнале."

#: ../doc/1.7/book/replication/repl_monitoring.rst:49
msgid "The request was issued at master #1, and the reply includes statistics for the other two masters, given in regard to master #1."
msgstr "Запрос был выполнен с мастера №1, и ответ включает в себя статистику по двум другим мастерам относительно мастера №1."

#: ../doc/1.7/book/replication/repl_monitoring.rst:52
msgid "The primary indicators of replication health are:"
msgstr "Основные индикаторы работоспособности репликации:"

#: ../doc/1.7/book/replication/repl_monitoring.rst:54
msgid ":ref:`idle <box_info_replication_upstream_idle>`, the time (in seconds) since the instance received the last event from a master."
msgstr ":ref:`бездействие <box_info_replication_upstream_idle>`, время (в секундах) с момента получения последнего события от мастера."

#: ../doc/1.7/book/replication/repl_monitoring.rst:57
msgid "A replica sends heartbeat messages to the master every second, and the master is programmed to reconnect automatically if it doesn’t see heartbeat messages more often than :ref:`replication_timeout <cfg_replication-replication_timeout>` seconds."
msgstr "Реплика отправляет сообщения контрольного сигнала на мастер каждую секунду, и мастер запрограммирован на автоматическое переподключение, если он не получает сообщения контрольного сигнала дольше количества секунд, указанного в :ref:`replication_timeout <cfg_replication-replication_timeout>`."

#: ../doc/1.7/book/replication/repl_monitoring.rst:62
msgid "Therefore, in a healthy replication setup, ``idle`` should never exceed ``replication_timeout``: if it does, either your replication is lagging seriously behind, because the master is running ahead of the replica, or the network link between the instances is down."
msgstr "Таким образом, в работоспособном состоянии значение ``idle`` никогда не должно превышать значение ``replication_timeout``: в противном случае, либо репликация сильно отстает, поскольку мастер опережает реплику, либо отсутствует сетевое подключение между экземплярами."

#: ../doc/1.7/book/replication/repl_monitoring.rst:67
msgid ":ref:`lag <box_info_replication_upstream_lag>`, the time difference between the local time at the instance, recorded when the event was received, and the local time at another master recorded when the event was written to the :ref:`write ahead log <internals-wal>` on that master."
msgstr ":ref:`отставание <box_info_replication_upstream_lag>`, разница во времени между локальным временем на экземпляре, зарегистрированным при получении события, и локальное время на другом мастере, зарегистрированное при записи события в :ref:`журнал упреждающей записи <internals-wal>` на этом мастере."

#: ../doc/1.7/book/replication/repl_monitoring.rst:72
msgid "Since ``lag`` calculation uses operating system clock from two different machines, don’t be surprised if it’s negative: a time drift may lead to the remote master clock being consistently behind the local instance's clock."
msgstr "Поскольку при расчете ``отставания`` используются часы операционной системы с двух разных машин, не удивляйтесь, получив отрицательное число: смещение во времени может привести к постоянному запаздыванию времени на удаленном мастере относительно часов на локальном экземпляре."

#: ../doc/1.7/book/replication/repl_monitoring.rst:76
msgid "For multi-master configurations, this is the maximal lag."
msgstr "Для многомастерной конфигурации это максимально возможное отставание."

#: ../doc/1.7/book/replication/repl_recover.rst:5
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../doc/1.7/book/replication/repl_recover.rst:7
msgid "\"Degraded state\" is a situation when the master becomes unavailable -- due to hardware or network failure, or due to a programming bug."
msgstr "\"Сбой\" — это ситуация, когда мастер становится недоступен вследствие проблем с оборудованием, сетевых неполадок или программной ошибки."

#: ../doc/1.7/book/replication/repl_recover.rst:13
msgid "In a master-replica set, if a master disappears, error messages appear on the replicas stating that the connection is lost:"
msgstr "В конфигурации мастер-реплика, если мастер пропадает, на репликах выводятся сообщения об ошибке с указанием потери соединения:"

#: ../doc/1.7/book/replication/repl_recover.rst:16
msgid ""
"$ # messages from a replica's log\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> can't read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. coio.cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka 192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I> the replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C> exiting the relay loop"
msgstr ""
"$ # сообщения из журнала реплики\n"
"      2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> can't read row\n"
"      2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. coio.cc:349 !> SystemError\n"
"      unexpected EOF when reading from socket, called on fd 17, aka 192.168.0.101:57815,\n"
"      peer of 192.168.0.101:3301: Broken pipe\n"
"      2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> will retry every 1 second\n"
"      2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I> the replica has closed its socket, exiting\n"
"      2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C> exiting the relay loop"

#: ../doc/1.7/book/replication/repl_recover.rst:27
msgid "... and the master's status is reported as \"disconnected\":"
msgstr "... а статус мастера выводится как \"отключенный\":"

#: ../doc/1.7/book/replication/repl_recover.rst:29
msgid ""
"# report from replica #1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00026607513427734\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."
msgstr ""
"# отчет от реплики №1\n"
"        tarantool> box.info.replication\n"
"        ---\n"
"        - 1:\n"
"            id: 1\n"
"            uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"            lsn: 542\n"
"            upstream:\n"
"              peer: replicator@192.168.0.101:3301\n"
"              lag: 0.00026607513427734\n"
"              status: disconnected\n"
"              idle: 182.36929893494\n"
"              message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"          2:\n"
"            id: 2\n"
"            uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"            lsn: 0\n"
"          3:\n"
"            id: 3\n"
"            uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"            lsn: 0\n"
"            downstream:\n"
"              vclock: {1: 542}\n"
"        ..."

#: ../doc/1.7/book/replication/repl_recover.rst:56
msgid ""
"# report from replica #2\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00027203559875488\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      peer: replicator@192.168.0.102:3301\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."
msgstr ""
"# отчет от реплики №2\n"
"        tarantool> box.info.replication\n"
"        ---\n"
"        - 1:\n"
"            id: 1\n"
"            uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"            lsn: 542\n"
"            upstream:\n"
"              peer: replicator@192.168.0.101:3301\n"
"              lag: 0.00027203559875488\n"
"              status: disconnected\n"
"              idle: 186.76988101006\n"
"              message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"          2:\n"
"            id: 2\n"
"            uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"            lsn: 0\n"
"            upstream:\n"
"              status: follow\n"
"              idle: 186.76960110664\n"
"              peer: replicator@192.168.0.102:3301\n"
"              lag: 0.00020599365234375\n"
"          3:\n"
"            id: 3\n"
"            uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"            lsn: 0\n"
"        ..."

#: ../doc/1.7/book/replication/repl_recover.rst:86
msgid "To declare that one of the replicas must now take over as a new master:"
msgstr "Чтобы объявить, что одна из реплик должна стать новым мастером:"

#: ../doc/1.7/book/replication/repl_recover.rst:88
msgid "Make sure that the old master is gone for good:"
msgstr "Убедитесь, что старый мастер окончательно недоступен:"

#: ../doc/1.7/book/replication/repl_recover.rst:90
msgid "change network routing rules to avoid any more packets being delivered to the master, or"
msgstr "измените правила маршрутизации в сети, чтобы больше не отправлять пакеты на мастер, или"

#: ../doc/1.7/book/replication/repl_recover.rst:92
msgid "shut down the master instance, if you have access to the machine, or"
msgstr "отключите мастер-экземпляр, если у вас есть доступ к машине, или"

#: ../doc/1.7/book/replication/repl_recover.rst:93
msgid "power off the container or the machine."
msgstr "отключите питание контейнера или машины."

#: ../doc/1.7/book/replication/repl_recover.rst:95
msgid "Say ``box.cfg{read_only=false, listen=URI}`` on the replica, and ``box.cfg{replication=URI}`` on the other replicas in the set."
msgstr "Выполните ``box.cfg{read_only=false, listen=URI}`` на реплике и ``box.cfg{replication=URI}`` на других репликах в наборе."

#: ../doc/1.7/book/replication/repl_recover.rst:100
msgid "If there are updates on the old master that were not propagated before the old master went down, :ref:`re-apply them manually <admin-disaster_recovery-master_replica>` to the new master using ``tarantoolctl cat`` and ``tarantoolctl play`` commands."
msgstr "Если на старом мастере есть обновления, не переданные до выхода старого мастера из строя, :ref:`примените их вручную <admin-disaster_recovery-master_replica>` на новом мастере с помощью команд ``tarantoolctl cat`` и``tarantoolctl play``."

#: ../doc/1.7/book/replication/repl_recover.rst:105
msgid "There is no automatic way for a replica to detect that the master is gone forever, since sources of failure and replication environments vary significantly. So the detection of degraded state requires an external observer."
msgstr "Реплика не может автоматически определить, что мастер не будет доступен в будущем, поскольку причины отказа и среды репликации могут существенно отличаться друг от друга. Поэтому обнаруживать сбой должен человек."

#: ../doc/1.7/book/replication/repl_remove_instances.rst:5
msgid "Removing instances"
msgstr "Удаление экземпляров"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:7
msgid "To politely remove an instance from a replica set, follow these steps:"
msgstr "Чтобы правильно удалить экземпляр из набора реплик, выполните следующие действия:"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:9
msgid "On the instance, run ``box.cfg{}`` with a blank replication source:"
msgstr "Выполните ``box.cfg{}`` с пустым источником репликации на экземпляре:"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:11
msgid ""
"tarantool> box.cfg{replication=''}\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{replication=''}\n"
"      ---\n"
"      ..."

#: ../doc/1.7/book/replication/repl_remove_instances.rst:17
msgid "The other instances in the replica set will carry on. If later the removed instance rejoins, it will receive all the updates that the other instances made while it was away."
msgstr "Остальные экземпляры продолжают работать. Если выбывший экземпляр снова возвращается в кластер, то он получит информацию о всех изменениях, которые произошли на остальных экземплярах за время его отсутствия."

#: ../doc/1.7/book/replication/repl_remove_instances.rst:21
msgid "If the instance is decommissioned forever, delete the instance's record from the following locations:"
msgstr "Если экземпляр больше не будет использоваться, удалите записи об экземпляре из следующих мест:"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:24
msgid ":ref:`replication <cfg_replication-replication>` parameter at all running instances in the replica set:"
msgstr "параметр :ref:`replication <cfg_replication-replication>` на всех работающих экземплярах в наборе реплик:"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:27
msgid "tarantool> box.cfg{replication=...}"
msgstr "tarantool> box.cfg{replication=...}"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:31
msgid ":ref:`box.space._cluster <box_space-cluster>` on any master instance in the replica set. For example, a record with instance id = 3:"
msgstr ":ref:`box.space._cluster <box_space-cluster>` на любом мастере в наборе реплик. Например, запись с ID экземпляра = 3:"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:34
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."
msgstr ""
"tarantool> box.space._cluster:select{}\n"
"      ---\n"
"      - - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"        - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"        - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"      ...\n"
"      tarantool> box.space._cluster:delete(3)\n"
"      ---\n"
"      - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"      ..."

#: ../doc/1.7/book/replication/repl_reseed.rst:5
msgid "Reseeding a replica"
msgstr "Перезагрузка реплики"

#: ../doc/1.7/book/replication/repl_reseed.rst:7
msgid "If any of a replica's .xlog/.snap/.run files are corrupted or deleted, you can \"re-seed\" the replica:"
msgstr "Если один из файлов формата .xlog/.snap/.run на реплике поврежден или удален, можно \"перезагрузить\" реплику данными:"

#: ../doc/1.7/book/replication/repl_reseed.rst:10
msgid "Stop the replica and destroy all local database files (the ones with extensions .xlog/.snap/.run/.inprogress)."
msgstr "Остановите реплику и удалите все локальные файлы базы данных (с расширениями .xlog/.snap/.run/.inprogress)."

#: ../doc/1.7/book/replication/repl_reseed.rst:13
msgid "Delete the replica's record from the following locations:"
msgstr "Удалите запись о реплике из следующих мест:"

#: ../doc/1.7/book/replication/repl_reseed.rst:15
msgid "``replication`` parameter at all running instances in the replica set."
msgstr "параметр ``replication`` на всех работающих экземплярах в наборе реплик."

#: ../doc/1.7/book/replication/repl_reseed.rst:16
msgid "``box.space._cluster`` on the master instance."
msgstr "``box.space._cluster`` на мастер-экземпляре."

#: ../doc/1.7/book/replication/repl_reseed.rst:18
msgid "See section :ref:`Removing instances <replication-remove_instances>` for details."
msgstr "Для получения подробной информации см. Раздел :ref:`Удаление экземпляров <replication-remove_instances>`."

#: ../doc/1.7/book/replication/repl_reseed.rst:21
msgid "Restart the replica with the same instance file to contact the master again. The replica will then catch up with the master by retrieving all the master’s tuples."
msgstr "Перезапустите реплику с тем же файлом экземпляра для повторного подключения к мастеру. Реплика синхронизируется с мастером после получения всех кортежей."

#: ../doc/1.7/book/replication/repl_reseed.rst:27
msgid "Remember that this procedure works only if the master’s WAL files are present."
msgstr "Следует отметить, что эта процедура сработает только в том случае, если на мастере есть WAL-файлы."

#: ../doc/1.7/dev_guide/build_contribute_index.rst:3
msgid "Build and contribute"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:5
msgid "Building documentation"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:7
msgid "Tarantool documentation is built using a simplified markup system named ``Sphinx`` (see http://sphinx-doc.org). You can build a local version of this documentation and you can contribute to Tarantool's version."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:11
msgid "You need to install these packages:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:13
msgid "``git`` (a program for downloading source repositories)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:14
msgid "``CMake`` version 2.8 or later (a program for managing the build process)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:15
msgid "``Python`` version greater than 2.6 -- preferably 2.7 -- and less than 3.0 (Sphinx is a Python-based tool)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:17
msgid "``LaTeX`` (a system for document preparation; the installable package name usually begins with the word 'texlive' or 'tetex', on Ubuntu the name is 'texlive-latex-base')"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:20
msgid "``ImageMagick`` (a system for image conversion; on MacOS install it using ``brew``)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:23
msgid "You need to install these Python modules:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:25
msgid "`pip <https://pypi.python.org/pypi/pip>`_, any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:26
msgid "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ version 1.4.4 or later"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:30
msgid "If you encounter the \"Missing SPHINX_EXECUTABLE\" error message on Mac, manually export the PATH variable:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:33
msgid "export PATH=$PATH:/User/user_name/Library/Python/2.7/bin"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:37
msgid "`sphinx-intl <https://pypi.python.org/pypi/sphinx-intl>`_ version 0.9.9"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:41
msgid "If you encounter the \"Missing SPHINX_INTL_DIR\" error message on Mac, manually export the SPHINX_INTL_DIR variable:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:44
msgid "export SPHINX_INTL_DIR=/User/user_name/Library/Python/2.7/bin"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:48
msgid "`lupa <https://pypi.python.org/pypi/lupa>`_ -- any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:52
msgid "You should specify ``--user`` flag on Mac while installing Python modules for correct installation."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:55
msgid "See more details about installation in the :ref:`build-from-source <building_from_source>` section of this documentation."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:58
msgid "Use ``git`` to download the latest source code of this documentation from the GitHub repository ``tarantool/doc``, branch 1.7. For example, to download to a local directory named ``~/tarantool-doc``:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:62
msgid "$ git clone https://github.com/tarantool/doc.git ~/tarantool-doc"
msgstr "$ git clone https://github.com/tarantool/doc.git ~/tarantool-doc"

#: ../doc/1.7/dev_guide/building_documentation.rst:66
msgid "Use ``CMake`` to initiate the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:68
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make clean         # unnecessary, added for good luck\n"
"$ rm CMakeCache.txt  # unnecessary, added for good luck\n"
"$ cmake .            # initiate"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:75
msgid "Build a local version of the documentation."
msgstr "Создайте локальную версию документации."

#: ../doc/1.7/dev_guide/building_documentation.rst:77
msgid "Run the ``make`` command with an appropriate option to specify which documentation version to build."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:80
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make sphinx-html           # multi-page English version\n"
"$ make sphinx-singlehtml     # one-page English version\n"
"$ make sphinx-html-ru        # multi-page Russian version\n"
"$ make sphinx-singlehtml-ru  # one-page Russian version\n"
"$ make all                   # all versions plus the entire web-site"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:89
msgid "Documentation will be created in subdirectories of ``/output``:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:91
msgid "``/output/en`` (files of the English version)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:92
msgid "``/output/ru`` (files of the Russian version)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:94
msgid "The entry point for each version is the ``index.html`` file in the appropriate directory."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:97
msgid "Set up a web server."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:99
msgid "One way is to say ``make sphinx-webserver``. This will set up and run the web server on port ``8000``:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:102
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make sphinx-html       # as an example, build the multi-page English documentation\n"
"$ make sphinx-webserver  # set up and run the web server"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:108
msgid "In case port ``8000`` is already in use, you can specify any other port number that is bigger than ``1000`` in the ``tarantool-doc/CMakeLists.txt`` file (search it for the ``sphinx-webserver`` target) and rebuild cmake files:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:113
msgid ""
"$ cd ~/tarantool-doc\n"
"$ git clean -qfxd        # clean up old cmake files\n"
"$ cmake .                # rebuild cmake files\n"
"$ make sphinx-html       # as an example, build the multi-page English documentation\n"
"$ make sphinx-webserver  # set up and run the web server on the custom port"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:121
msgid "Or you can release the port:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:123
msgid ""
"$ sudo lsof -i :8000  # get the process ID (PID)\n"
"COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\n"
"Python 19516 user 3u IPv4 0xe7f8gc6be1b43c7 0t0 TCP *:irdmi (LISTEN)\n"
"$ sudo kill -9 19516  # kill the process"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:130
msgid "The other way is to run the built-in web server in Python. Make sure to run it from the documentation ``output`` folder:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:133
msgid ""
"$ cd ~/tarantool-doc/output\n"
"$ python -m SimpleHTTPServer 8000"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:138
msgid "In case port ``8000`` is already in use, you can specify any other port number that is bigger than ``1000``."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:141
msgid "Open your browser and enter ``127.0.0.1:8000/en/doc/1.7/`` into the address box (or ``127.0.0.1:8000/ru/doc/1.7/`` if you built the Russian documentation). Mind the trailing slash \"/\" in the address string."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:145
msgid "If your local documentation build is valid, the manual will appear in the browser."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:148
msgid "To contribute to documentation, use the `REST <http://docutils.sourceforge.net/docs/user/rst/quickstart.html>`_ format for drafting and submit your updates as a `pull request <https://help.github.com/articles/creating-a-pull-request/>`_ via GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:154
msgid "To comply with the writing and formatting style, use the :ref:`guidelines <documentation_guidelines>` provided in the documentation, common sense and existing documents."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:160
msgid "If you suggest creating a new documentation section (a whole new page), it has to be saved to the relevant section at GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:163
msgid "If you want to contribute to localizing this documentation (for example into Russian), add your translation strings to ``.po`` files stored in the corresponding locale directory (for example ``/locale/ru/LC_MESSAGES/`` for Russian). See more about localizing with Sphinx at http://www.sphinx-doc.org/en/stable/intl.html"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:5
msgid "Building from source"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:7
msgid "For downloading Tarantool source and building it, the platforms can differ and the preferences can differ. But strategically the steps are always the same."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:10
msgid "Get tools and libraries that will be necessary for building and testing."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:13
msgid "The absolutely necessary ones are:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:15
msgid "A program for downloading source repositories. |br| For all platforms, this is ``git``. It allows downloading the latest complete set of source files from the Tarantool repository on GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:19
msgid "A C/C++ compiler. |br| Ordinarily, this is ``gcc`` and ``g++`` version 4.6 or later. On Mac OS X, this is ``Clang`` version 3.2+."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:22
msgid "A program for managing the build process. |br| For all platforms, this is ``CMake`` version 2.8+."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:25
msgid "`ReadLine <http://www.gnu.org/software/readline/>`_ library, any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:26
msgid "`ncurses <https://www.gnu.org/software/ncurses/>`_ library, any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:27
msgid "`OpenSSL <https://www.openssl.org>`_ library, version 1.0.1+"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:28
msgid "`cURL <https://curl.haxx.se/>`_ library, version 0.725+"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:29
msgid "`LibYAML <http://pyyaml.org/wiki/LibYAML>`_ library, version 0.1.4+"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:30
msgid "`ICU <http://site.icu-project.org/download>`_ library, recent version"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:32
msgid "Python and modules. |br| Python interpreter is not necessary for building Tarantool itself, unless you intend to use the \"Run the test suite\" option in step 5. For all platforms, this is ``python`` version 2.7+ (but not 3.x). You need the following Python modules:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:37
msgid "`pyyaml <https://pypi.python.org/pypi/PyYAML>`_ version 3.10"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:38
msgid "`argparse <https://pypi.python.org/pypi/argparse>`_ version 1.1"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:39
msgid "`msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_ version 0.4.6"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:40
msgid "`gevent <https://pypi.python.org/pypi/gevent>`_ version 1.1.2"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:41
msgid "`six <https://pypi.python.org/pypi/six>`_ version 1.8.0"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:43
msgid "To install all required dependencies, follow the instructions for your OS:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:45
msgid "For Debian/Ubuntu, say:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:47
msgid ""
"$ apt install -y build-essential cmake coreutils sed \\\n"
"      libreadline-dev libncurses5-dev libyaml-dev libssl-dev \\\n"
"      libcurl4-openssl-dev libunwind-dev libicu-dev \\\n"
"      python python-pip python-setuptools python-dev \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:55
msgid "For RHEL/CentOS/Fedora, say:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:57
msgid ""
"$ yum install -y gcc gcc-c++ cmake coreutils sed \\\n"
"      readline-devel ncurses-devel libyaml-devel openssl-devel \\\n"
"      libcurl-devel libunwind-devel libicu-devel \\\n"
"      python python-pip python-setuptools python-devel \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:65
msgid "For Mac OS X (instructions below are for OS X El Capitan):"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:67
msgid "If you're using Homebrew as your package manager, say:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:69
msgid ""
"$ brew install cmake autoconf binutils zlib \\\n"
"       readline ncurses libyaml openssl curl libunwind-headers icu4c \\\n"
"       && pip install python-daemon \\\n"
"       msgpack-python pyyaml configargparse six gevent"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:76
msgid "Alternatively, download Apple's default Xcode toolset:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:78
msgid ""
"$ xcode-select --install\n"
"$ xcode-select -switch /Applications/Xcode.app/Contents/Developer"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:83
msgid "For FreeBSD (instructions below are for FreeBSD 10.1 release), say:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:85
msgid ""
"$ pkg install -y sudo git cmake gmake gcc coreutils \\\n"
"      readline ncurses libyaml openssl curl libunwind icu \\\n"
"      python27 py27-pip py27-setuptools py27-daemon \\\n"
"      py27-msgpack-python py27-yaml py27-argparse py27-six py27-gevent"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:92
msgid "If some Python modules are not available in a repository, it is best to set up the modules by getting a tarball and doing the setup with ``python setup.py`` like this:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:96
msgid ""
"$ # On some machines, this initial command may be necessary:\n"
"$ wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python\n"
"\n"
"$ # Python module for parsing YAML (pyYAML), for test suite:\n"
"$ # (If wget fails, check at http://pyyaml.org/wiki/PyYAML\n"
"$ # what the current version is.)\n"
"$ cd ~\n"
"$ wget http://pyyaml.org/download/pyyaml/PyYAML-3.10.tar.gz\n"
"$ tar -xzf PyYAML-3.10.tar.gz\n"
"$ cd PyYAML-3.10\n"
"$ sudo python setup.py install"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:110
msgid "Finally, use Python ``pip`` to bring in Python packages that may not be up-to-date in the distro repositories. (On CentOS 7, it will be necessary to install ``pip`` first, with :code:`sudo yum install epel-release` followed by :code:`sudo yum install python-pip`.)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:116
msgid ""
"$ pip install -r \\\n"
"      https://raw.githubusercontent.com/tarantool/test-run/master/requirements.txt \\\n"
"      --user"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:122
msgid "This step is only necessary once, the first time you do a download."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:124
msgid "Use ``git`` to download the latest Tarantool source code from the GitHub repository ``tarantool/tarantool``, branch 1.7, to a local directory named ``~/tarantool``, for example:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:128
msgid "$ git clone --recursive https://github.com/tarantool/tarantool.git -b 1.7 ~/tarantool"
msgstr "$ git clone --recursive https://github.com/tarantool/tarantool.git -b 1.7 ~/tarantool"

#: ../doc/1.7/dev_guide/building_from_source.rst:132
msgid "On rare occasions, the submodules need to be updated again with the command:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:135
msgid "$ git submodule update --init --recursive"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:139
msgid "Use CMake to initiate the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:141
msgid ""
"$ cd ~/tarantool\n"
"$ make clean         # unnecessary, added for good luck\n"
"$ rm CMakeCache.txt  # unnecessary, added for good luck\n"
"$ cmake .            # start initiating with build type=Debug"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:148
msgid "On some platforms, it may be necessary to specify the C and C++ versions, for example:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:151
msgid "$ CC=gcc-4.8 CXX=g++-4.8 cmake ."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:155
msgid "The CMake option for specifying build type is :samp:`-DCMAKE_BUILD_TYPE={type}`, where :samp:`{type}` can be:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:158
msgid "``Debug`` -- used by project maintainers"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:159
msgid "``Release`` -- used only if the highest performance is required"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:160
msgid "``RelWithDebInfo`` -- used for production, also provides debugging capabilities"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:162
msgid "The CMake option for hinting that the result will be distributed is :code:`-DENABLE_DIST=ON`. If this option is on, then later ``make install`` will install ``tarantoolctl`` files in addition to ``tarantool`` files."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:166
msgid "Use ``make`` to complete the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:168
msgid "$ make"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:174
msgid "For FreeBSD, use ``gmake`` instead."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:176
msgid "This creates the 'tarantool' executable in the ``src/`` directory."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:178
msgid "Next, it's highly recommended to say ``make install`` to install Tarantool to the ``/usr/local`` directory and keep your system clean. However, it is possible to run the Tarantool executable without installation."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:182
msgid "Run the test suite."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:184
msgid "This step is optional. Tarantool's developers always run the test suite before they publish new versions. You should run the test suite too, if you make any changes in the code. Assuming you downloaded to ``~/tarantool``, the principal steps are:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:189
msgid ""
"$ # make a subdirectory named `bin`\n"
"$ mkdir ~/tarantool/bin\n"
"\n"
"$ # link Python to bin (this may require superuser privileges)\n"
"$ ln /usr/bin/python ~/tarantool/bin/python\n"
"\n"
"$ # get to the test subdirectory\n"
"$ cd ~/tarantool/test\n"
"\n"
"$ # run tests using Python\n"
"$ PATH=~/tarantool/bin:$PATH ./test-run.py"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:203
msgid "The output should contain reassuring reports, for example:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:205
msgid ""
"======================================================================\n"
"TEST                                            RESULT\n"
"------------------------------------------------------------\n"
"box/bad_trigger.test.py                         [ pass ]\n"
"box/call.test.py                                [ pass ]\n"
"box/iproto.test.py                              [ pass ]\n"
"box/xlog.test.py                                [ pass ]\n"
"box/admin.test.lua                              [ pass ]\n"
"box/auth_access.test.lua                        [ pass ]\n"
"... etc."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:218
msgid "To prevent later confusion, clean up what's in the ``bin`` subdirectory:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:220
msgid ""
"$ rm ~/tarantool/bin/python\n"
"$ rmdir ~/tarantool/bin"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:225
msgid "Make RPM and Debian packages."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:227
msgid "This step is optional. It's only for people who want to redistribute Tarantool. We highly recommend to use official packages from the `tarantool.org <https://tarantool.org/download.html>`_ web-site. However, you can build RPM and Debian packages using `PackPack <https://github.com/packpack/packpack>`_ or using the ``dpkg-buildpackage`` or ``rpmbuild`` tools. Please consult ``dpkg`` or ``rpmbuild`` documentation for details."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:235
msgid "Verify your Tarantool installation."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:237
msgid ""
"$ # if you installed tarantool locally after build\n"
"$ tarantool\n"
"$ # - OR -\n"
"$ # if you didn't install tarantool locally after build\n"
"$ ./src/tarantool"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:245
msgid "This starts Tarantool in the interactive mode."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:247
msgid "See also:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:249
msgid "`Tarantool README.md <https://github.com/tarantool/tarantool/blob/1.7/README.md>`_"
msgstr "`Tarantool README.md <https://github.com/tarantool/tarantool/blob/1.7/README.md>`_"

#: ../doc/1.7/dev_guide/c_style_guide.rst:3
msgid "C Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:5
msgid "The project's coding style is based on a version of the Linux kernel coding style."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:7
msgid "The latest version of the Linux style can be found at: http://www.kernel.org/doc/Documentation/CodingStyle"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:10
msgid "Since it is open for changes, the version of style that we follow, one from 2007-July-13, will be also copied later in this document."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:13
msgid "There are a few additional guidelines, either unique to Tarantool or deviating from the Kernel guidelines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:16
msgid "Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 \"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-invent the kernel macros\" do not apply, since they are specific to Linux kernel programming environment."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:21
msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:25
msgid "General guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:27
msgid "We use Git for revision control. The latest development is happening in the default branch (currently ``2.0``). Our git repository is hosted on github, and can be checked out with ``git clone git://github.com/tarantool/tarantool.git`` (anonymous read-only access)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:32
msgid "If you have any questions about Tarantool internals, please post them on the developer discussion list, https://groups.google.com/forum/#!forum/tarantool. However, please be warned: Launchpad silently deletes posts from non-subscribed members, thus please be sure to have subscribed to the list prior to posting. Additionally, some engineers are always present on #tarantool channel on irc.freenode.net."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:40
msgid "Commenting style"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:42
msgid "Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than `\\tag`. The main tags in use are @param, @retval, @return, @see, @note and @todo."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:45
msgid "Every function, except perhaps a very short and obvious one, should have a comment. A sample function comment may look like below:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:48
msgid ""
"/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @reval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:63
msgid "Public structures and important structure members should be commented as well."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:67
msgid "Header files"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:69
msgid "Use header guards. Put the header guard in the first line in the header, before the copyright or declarations. Use all-uppercase name for the header guard. Derive the header guard name from the file name, and append _INCLUDED to get a macro name. For example, core/log_io.h -> CORE_LOG_IO_H_INCLUDED. In ``.c`` (implementation) file, include the respective declaration header before all other headers, to ensure that the header is self- sufficient. Header \"header.h\" is self-sufficient if the following compiles without errors:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:77
msgid "#include \"header.h\""
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:83
msgid "Allocating memory"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:85
msgid "Prefer the supplied slab (salloc) and pool (palloc) allocators to malloc()/free() for any performance-intensive or large  memory allocations. Repetitive use of malloc()/free() can lead to memory fragmentation and should therefore be avoided."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:89
msgid "Always free all allocated memory, even allocated  at start-up. We aim at being valgrind leak-check clean, and in most cases it's just as easy to free() the allocated memory as it is to write a valgrind suppression. Freeing all allocated memory is also dynamic-load friendly: assuming a plug-in can be dynamically loaded and unloaded multiple times, reload should not lead to a memory leak."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:97
msgid "Other"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:99
msgid "Select GNU C99 extensions are acceptable. It's OK to mix declarations and statements, use true and false."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:102
msgid "The not-so-current list of all GCC C extensions can be found at: http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:107
msgid "Linux kernel coding style"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:109
msgid "This is a short document describing the preferred coding style for the linux kernel.  Coding style is very personal, and I won't _force_ my views on anybody, but this is what goes for anything that I have to be able to maintain, and I'd prefer it for most other things too.  Please at least consider the points made here."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:115
msgid "First off, I'd suggest printing out a copy of the GNU coding standards, and NOT read it.  Burn them, it's a great symbolic gesture."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:118
msgid "Anyway, here goes:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:122
msgid "Chapter 1: Indentation"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:124
msgid "Tabs are 8 characters, and thus indentations are also 8 characters. There are heretic movements that try to make indentations 4 (or even 2!) characters deep, and that is akin to trying to define the value of PI to be 3."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:129
msgid "Rationale: The whole idea behind indentation is to clearly define where a block of control starts and ends.  Especially when you've been looking at your screen for 20 straight hours, you'll find it a lot easier to see how the indentation works if you have large indentations."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:134
msgid "Now, some people will claim that having 8-character indentations makes the code move too far to the right, and makes it hard to read on a 80-character terminal screen.  The answer to that is that if you need more than 3 levels of indentation, you're screwed anyway, and should fix your program."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:140
msgid "In short, 8-char indents make things easier to read, and have the added benefit of warning you when you're nesting your functions too deep. Heed that warning."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:144
msgid "The preferred way to ease multiple indentation levels in a switch statement is to align the \"switch\" and its subordinate \"case\" labels in the same column instead of \"double-indenting\" the \"case\" labels. e.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:148
msgid ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:168
msgid "Don't put multiple statements on a single line unless you have something to hide:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:171
msgid ""
"if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:176
msgid "Don't put multiple assignments on a single line either. Kernel coding style is super simple. Avoid tricky expressions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:179
msgid "Outside of comments, documentation and except in Kconfig, spaces are never used for indentation, and the above example is deliberately broken."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:182
msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:187
msgid "Chapter 2: Breaking long lines and strings"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:189
msgid "Coding style is all about readability and maintainability using commonly available tools."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:192
msgid "The limit on the length of lines is 80 columns and this is a strongly preferred limit."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:195
msgid "Statements longer than 80 columns will be broken into sensible chunks. Descendants are always substantially shorter than the parent and are placed substantially to the right. The same applies to function headers with a long argument list. Long strings are as well broken into shorter strings. The only exception to this is where exceeding 80 columns significantly increases readability and does not hide information."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:202
#, python-format
msgid ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:216
msgid "Chapter 3: Placing Braces and Spaces"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:218
msgid "The other issue that always comes up in C styling is the placement of braces.  Unlike the indent size, there are few technical reasons to choose one placement strategy over the other, but the preferred way, as shown to us by the prophets Kernighan and Ritchie, is to put the opening brace last on the line, and put the closing brace first, thusly:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:224
msgid ""
"if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:230
msgid "This applies to all non-function statement blocks (if, switch, for, while, do). e.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:233
msgid ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:246
msgid "However, there is one special case, namely functions: they have the opening brace at the beginning of the next line, thus:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:249
msgid ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:256
msgid "Heretic people all over the world have claimed that this inconsistency is ...  well ...  inconsistent, but all right-thinking people know that (a) K&R are _right_ and (b) K&R are right.  Besides, functions are special anyway (you can't nest them in C)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:261
msgid "Note that the closing brace is empty on a line of its own, _except_ in the cases where it is followed by a continuation of the same statement, ie a \"while\" in a do-statement or an \"else\" in an if-statement, like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:266
msgid ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:272
msgid "and"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:274
msgid ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:284
msgid "Rationale: K&R."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:286
msgid "Also, note that this brace-placement also minimizes the number of empty (or almost empty) lines, without any loss of readability.  Thus, as the supply of new-lines on your screen is not a renewable resource (think 25-line terminal screens here), you have more empty lines to put comments on."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:292
msgid "Do not unnecessarily use braces where a single statement will do."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:294
msgid ""
"if (condition)\n"
"    action();"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:299
msgid "This does not apply if one branch of a conditional statement is a single statement. Use braces in both branches."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:302
msgid ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:313
msgid "Chapter 3.1:  Spaces"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:315
msgid "Linux kernel style for use of spaces depends (mostly) on function-versus-keyword usage.  Use a space after (most) keywords.  The notable exceptions are sizeof, typeof, alignof, and __attribute__, which look somewhat like functions (and are usually used with parentheses in Linux, although they are not required in the language, as in: \"sizeof info\" after \"struct fileinfo info;\" is declared)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:322
msgid "So use a space after these keywords: if, switch, case, for, do, while but not with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:325
msgid "s = sizeof(struct file);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:329
msgid "Do not add spaces around (inside) parenthesized expressions. This example is **bad**:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:332
msgid "s = sizeof( struct file );"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:336
msgid "When declaring pointer data or a function that returns a pointer type, the preferred use of '*' is adjacent to the data name or function name and not adjacent to the type name.  Examples:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:340
msgid ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:346
msgid "Use one space around (on each side of) most binary and ternary operators, such as any of these:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:349
msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:351
msgid "but no space after unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:353
msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:355
msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:357
#: ../doc/1.7/dev_guide/c_style_guide.rst:361
msgid "++  --"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:359
msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:363
msgid "and no space around the '.' and \"->\" structure member operators."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:365
msgid "Do not leave trailing whitespace at the ends of lines.  Some editors with \"smart\" indentation will insert whitespace at the beginning of new lines as appropriate, so you can start typing the next line of code right away. However, some such editors do not remove the whitespace if you end up not putting a line of code there, such as if you leave a blank line.  As a result, you end up with lines containing trailing whitespace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:372
msgid "Git will warn you about patches that introduce trailing whitespace, and can optionally strip the trailing whitespace for you; however, if applying a series of patches, this may make later patches in the series fail by changing their context lines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:380
msgid "Chapter 4: Naming"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:382
msgid "C is a Spartan language, and so should your naming be.  Unlike Modula-2 and Pascal programmers, C programmers do not use cute names like ThisVariableIsATemporaryCounter.  A C programmer would call that variable \"tmp\", which is much easier to write, and not the least more difficult to understand."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:388
msgid "HOWEVER, while mixed-case names are frowned upon, descriptive names for global variables are a must.  To call a global function \"foo\" is a shooting offense."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:392
msgid "GLOBAL variables (to be used only if you _really_ need them) need to have descriptive names, as do global functions.  If you have a function that counts the number of active users, you should call that \"count_active_users()\" or similar, you should _not_ call it \"cntusr()\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:397
msgid "Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged - the compiler knows the types anyway and can check those, and it only confuses the programmer.  No wonder MicroSoft makes buggy programs."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:402
msgid "LOCAL variable names should be short, and to the point.  If you have some random integer loop counter, it should probably be called \"i\". Calling it \"loop_counter\" is non-productive, if there is no chance of it being mis-understood.  Similarly, \"tmp\" can be just about any type of variable that is used to hold a temporary value."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:408
msgid "If you are afraid to mix up your local variable names, you have another problem, which is called the function-growth-hormone-imbalance syndrome. See chapter 6 (Functions)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:415
msgid "Chapter 5: Typedefs"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:417
msgid "Please don't use things like \"vps_t\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:419
msgid "It's a _mistake_ to use typedef for structures and pointers. When you see a"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:421
msgid "vps_t a;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:425
msgid "in the source, what does it mean?"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:427
msgid "In contrast, if it says"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:429
msgid "struct virtual_container *a;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:433
msgid "you can actually tell what \"a\" is."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:435
msgid "Lots of people think that typedefs \"help readability\". Not so. They are useful only for:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:438
msgid "totally opaque objects (where the typedef is actively used to _hide_ what the object is)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:441
msgid "Example: \"pte_t\" etc. opaque objects that you can only access using the proper accessor functions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:444
msgid "NOTE! Opaqueness and \"accessor functions\" are not good in themselves. The reason we have them for things like pte_t etc. is that there really is absolutely _zero_ portably accessible information there."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:448
msgid "Clear integer types, where the abstraction _helps_ avoid confusion whether it is \"int\" or \"long\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:451
msgid "u8/u16/u32 are perfectly fine typedefs, although they fit into category (d) better than here."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:454
msgid "NOTE! Again - there needs to be a _reason_ for this. If something is \"unsigned long\", then there's no reason to do"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:457
msgid "typedef unsigned long myflags_t;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:461
msgid "but if there is a clear reason for why it under certain circumstances might be an \"unsigned int\" and under other configurations might be \"unsigned long\", then by all means go ahead and use a typedef."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:465
msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:468
msgid "New types which are identical to standard C99 types, in certain exceptional circumstances."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:471
msgid "Although it would only take a short amount of time for the eyes and brain to become accustomed to the standard types like 'uint32_t', some people object to their use anyway."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:475
msgid "Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed equivalents which are identical to standard types are permitted -- although they are not mandatory in new code of your own."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:480
msgid "When editing existing code which already uses one or the other set of types, you should conform to the existing choices in that code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:483
msgid "Types safe for use in userspace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:485
msgid "In certain structures which are visible to userspace, we cannot require C99 types and cannot use the 'u32' form above. Thus, we use __u32 and similar types in all structures which are shared with userspace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:490
msgid "Maybe there are other cases too, but the rule should basically be to NEVER EVER use a typedef unless you can clearly match one of those rules."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:493
msgid "In general, a pointer, or a struct that has elements that can reasonably be directly accessed should **never** be a typedef."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:499
msgid "Chapter 6: Functions"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:501
msgid "Functions should be short and sweet, and do just one thing.  They should fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, as we all know), and do one thing and do that well."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:505
msgid "The maximum length of a function is inversely proportional to the complexity and indentation level of that function.  So, if you have a conceptually simple function that is just one long (but simple) case-statement, where you have to do lots of small things for a lot of different cases, it's OK to have a longer function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:511
msgid "However, if you have a complex function, and you suspect that a less-than-gifted first-year high-school student might not even understand what the function is all about, you should adhere to the maximum limits all the more closely.  Use helper functions with descriptive names (you can ask the compiler to in-line them if you think it's performance-critical, and it will probably do a better job of it than you would have done)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:519
msgid "Another measure of the function is the number of local variables.  They shouldn't exceed 5-10, or you're doing something wrong.  Re-think the function, and split it into smaller pieces.  A human brain can generally easily keep track of about 7 different things, anything more and it gets confu/sed.  You know you're brilliant, but maybe you'd like to understand what you did 2 weeks from now."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:526
msgid "In source files, separate functions with one blank line.  If the function is exported, the EXPORT* macro for it should follow immediately after the closing function brace line.  E.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:530
msgid ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:538
msgid "In function prototypes, include parameter names with their data types. Although this is not required by the C language, it is preferred in Linux because it is a simple way to add valuable information for the reader."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:544
msgid "Chapter 7: Centralized exiting of functions"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:546
msgid "Albeit deprecated by some people, the equivalent of the goto statement is used frequently by compilers in form of the unconditional jump instruction."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:549
msgid "The goto statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:552
msgid "The rationale is:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:554
msgid "unconditional statements are easier to understand and follow"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:555
msgid "nesting is reduced"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:556
msgid "errors by not updating individual exit points when making modifications are prevented"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:558
msgid "saves the compiler work to optimize redundant code away ;)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:560
msgid ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:585
msgid "Chapter 8: Commenting"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:587
msgid "Comments are good, but there is also a danger of over-commenting. NEVER try to explain HOW your code works in a comment: it's much better to write the code so that the _working_ is obvious, and it's a waste of time to explain badly written code. с Generally, you want your comments to tell WHAT your code does, not HOW. Also, try to avoid putting comments inside a function body: if the function is so complex that you need to separately comment parts of it, you should probably go back to chapter 6 for a while.  You can make small comments to note or warn about something particularly clever (or ugly), but try to avoid excess.  Instead, put the comments at the head of the function, telling people what it does, and possibly WHY it does it."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:601
msgid "When commenting the kernel API functions, please use the kernel-doc format. See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts/kernel-doc for details."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:605
msgid "Linux style for comments is the C89 ``\"/\\* ... \\*/\"`` style. Don't use C99-style ``\"// ...\"`` comments."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:608
msgid "The preferred style for long (multi-line) comments is:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:610
msgid ""
"/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:621
msgid "It's also important to comment data, whether they are basic types or derived types.  To this end, use just one data declaration per line (no commas for multiple data declarations).  This leaves you room for a small comment on each item, explaining its use."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:628
msgid "Chapter 9: You've made a mess of it"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:630
msgid "That's OK, we all do.  You've probably been told by your long-time Unix user helper that \"GNU emacs\" automatically formats the C sources for you, and you've noticed that yes, it does do that, but the defaults it uses are less than desirable (in fact, they are worse than random typing - an infinite number of monkeys typing into GNU emacs would never make a good program)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:637
msgid "So, you can either get rid of GNU emacs, or change it to use saner values.  To do the latter, you can stick the following in your .emacs file:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:640
msgid ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:671
msgid "This will make emacs go better with the kernel coding style for C files below ~/src/linux-trees."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:674
msgid "But even if you fail in getting emacs to do sane formatting, not everything is lost: use \"indent\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:677
msgid "Now, again, GNU indent has the same brain-dead settings that GNU emacs has, which is why you need to give it a few command line options. However, that's not too bad, because even the makers of GNU indent recognize the authority of K&R (the GNU people aren't evil, they are just severely misguided in this matter), so you just give indent the options \"-kr -i8\" (stands for \"K&R, 8 character indents\"), or use \"scripts/Lindent\", which indents in the latest style."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:685
msgid "\"indent\" has a lot of options, and especially when it comes to comment re-formatting you may want to take a look at the man page.  But remember: \"indent\" is not a fix for bad programming."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:692
msgid "Chapter 10: Kconfig configuration files"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:694
msgid "For all of the Kconfig* configuration files throughout the source tree, the indentation is somewhat different.  Lines under a \"config\" definition are indented with one tab, while help text is indented an additional two spaces. Example:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:699
msgid ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:710
msgid "Features that might still be considered unstable should be defined as dependent on \"EXPERIMENTAL\":"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:713
msgid ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:720
msgid "while seriously dangerous features (such as write support for certain filesystems) should advertise this prominently in their prompt string:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:723
msgid ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:730
msgid "For full documentation on the configuration files, see the file Documentation/kbuild/kconfig-language.txt."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:736
msgid "Chapter 11: Data structures"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:738
msgid "Data structures that have visibility outside the single-threaded environment they are created and destroyed in should always have reference counts.  In the kernel, garbage collection doesn't exist (and outside the kernel garbage collection is slow and inefficient), which means that you absolutely _have_ to reference count all your uses."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:744
msgid "Reference counting means that you can avoid locking, and allows multiple users to have access to the data structure in parallel - and not having to worry about the structure suddenly going away from under them just because they slept or did something else for a while."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:749
msgid "Note that locking is _not_ a replacement for reference counting. Locking is used to keep data structures coherent, while reference counting is a memory management technique.  Usually both are needed, and they are not to be confused with each other."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:754
msgid "Many data structures can indeed have two levels of reference counting, when there are users of different \"classes\".  The subclass count counts the number of subclass users, and decrements the global count just once when the subclass count goes to zero."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:759
msgid "Examples of this kind of \"multi-level-reference-counting\" can be found in memory management (\"struct mm_struct\": mm_users and mm_count), and in filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:763
msgid "Remember: if another thread can find your data structure, and you don't have a reference count on it, you almost certainly have a bug."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:768
msgid "Chapter 12: Macros, Enums and RTL"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:770
msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:772
msgid "#define CONSTANT 0x12345"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:776
msgid "Enums are preferred when defining several related constants."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:778
msgid "CAPITALIZED macro names are appreciated but macros resembling functions may be named in lower case."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:781
msgid "Generally, inline functions are preferable to macros resembling functions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:783
msgid "Macros with multiple statements should be enclosed in a do - while block:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:785
msgid ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:793
msgid "Things to avoid when using macros:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:795
msgid "macros that affect control flow:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:797
msgid ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:805
msgid "is a _very_ bad idea.  It looks like a function call but exits the \"calling\" function; don't break the internal parsers of those who will read the code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:808
msgid "macros that depend on having a local variable with a magic name:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:810
msgid "#define FOO(val) bar(index, val)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:814
msgid "might look like a good thing, but it's confusing as hell when one reads the code and it's prone to breakage from seemingly innocent changes."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:817
msgid "macros with arguments that are used as l-values: FOO(x) = y; will bite you if somebody e.g. turns FOO into an inline function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:820
msgid "forgetting about precedence: macros defining constants using expressions must enclose the expression in parentheses. Beware of similar issues with macros using parameters."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:824
msgid ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:829
msgid "The cpp manual deals with macros exhaustively. The gcc internals manual also covers RTL which is used frequently with assembly language in the kernel."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:834
msgid "Chapter 13: Printing kernel messages"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:836
msgid "Kernel developers like to be seen as literate. Do mind the spelling of kernel messages to make a good impression. Do not use crippled words like \"dont\"; use \"do not\" or \"don't\" instead.  Make the messages concise, clear, and unambiguous."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:841
msgid "Kernel messages do not have to be terminated with a period."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:843
#, python-format
msgid "Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:845
msgid "There are a number of driver model diagnostic macros in <linux/device.h> which you should use to make sure messages are matched to the right device and driver, and are tagged with the right level:  dev_err(), dev_warn(), dev_info(), and so forth.  For messages that aren't associated with a particular device, <linux/kernel.h> defines pr_debug() and pr_info()."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:851
msgid "Coming up with good debugging messages can be quite a challenge; and once you have them, they can be a huge help for remote troubleshooting.  Such messages should be compiled out when the DEBUG symbol is not defined (that is, by default they are not included).  When you use dev_dbg() or pr_debug(), that's automatic.  Many subsystems have Kconfig options to turn on -DDEBUG. A related convention uses VERBOSE_DEBUG to add dev_vdbg() messages to the ones already enabled by DEBUG."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:861
msgid "Chapter 14: Allocating memory"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:863
msgid "The kernel provides the following general purpose memory allocators: kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Please refer to the API documentation for further information about them."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:867
msgid "The preferred form for passing a size of a struct is the following:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:869
msgid "p = kmalloc(sizeof(*p), ...);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:873
msgid "The alternative form where struct name is spelled out hurts readability and introduces an opportunity for a bug when the pointer variable type is changed but the corresponding sizeof that is passed to a memory allocator is not."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:877
msgid "Casting the return value which is a void pointer is redundant. The conversion from void pointer to any other pointer type is guaranteed by the C programming language."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:883
msgid "Chapter 15: The inline disease"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:885
msgid "There appears to be a common misperception that gcc has a magic \"make me faster\" speedup option called \"inline\". While the use of inlines can be appropriate (for example as a means of replacing macros, see Chapter 12), it very often is not. Abundant use of the inline keyword leads to a much bigger kernel, which in turn slows the system as a whole down, due to a bigger icache footprint for the CPU and simply because there is less memory available for the pagecache. Just think about it; a pagecache miss causes a disk seek, which easily takes 5 milliseconds. There are a LOT of cpu cycles that can go into these 5 milliseconds."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:895
msgid "A reasonable rule of thumb is to not put inline at functions that have more than 3 lines of code in them. An exception to this rule are the cases where a parameter is known to be a compiletime constant, and as a result of this constantness you *know* the compiler will be able to optimize most of your function away at compile time. For a good example of this later case, see the kmalloc() inline function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:902
msgid "Often people argue that adding inline to functions that are static and used only once is always a win since there is no space tradeoff. While this is technically correct, gcc is capable of inlining these automatically without help, and the maintenance issue of removing the inline when a second user appears outweighs the potential value of the hint that tells gcc to do something it would have done anyway."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:911
msgid "Chapter 16: Function return values and names"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:913
msgid "Functions can return values of many different kinds, and one of the most common is a value indicating whether the function succeeded or failed.  Such a value can be represented as an error-code integer (-Exxx = failure, 0 = success) or a \"succeeded\" boolean (0 = failure, non-zero = success)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:919
msgid "Mixing up these two sorts of representations is a fertile source of difficult-to-find bugs.  If the C language included a strong distinction between integers and booleans then the compiler would find these mistakes for us... but it doesn't.  To help prevent such bugs, always follow this convention:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:961
msgid ""
"If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:931
msgid "For example, \"add work\" is a command, and the add_work() function returns 0 for success or -EBUSY for failure.  In the same way, \"PCI device present\" is a predicate, and the pci_dev_present() function returns 1 if it succeeds in finding a matching device or 0 if it doesn't."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:936
msgid "All EXPORTed functions must respect this convention, and so should all public functions.  Private (static) functions need not, but it is recommended that they do."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:940
msgid "Functions whose return value is the actual result of a computation, rather than an indication of whether the computation succeeded, are not subject to this rule.  Generally they indicate failure by returning some out-of-range result.  Typical examples would be functions that return pointers; they use NULL or the ERR_PTR mechanism to report failure."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:949
msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:951
msgid "The header file include/linux/kernel.h contains a number of macros that you should use, rather than explicitly coding some variant of them yourself. For example, if you need to calculate the length of an array, take advantage of the macro"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:956
msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:960
msgid "Similarly, if you need to calculate the size of some structure member, use"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:962
msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:966
msgid "There are also min() and max() macros that do strict type checking if you need them.  Feel free to peruse that header file to see what else is already defined that you shouldn't reproduce in your code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:972
msgid "Chapter 18:  Editor modelines and other cruft"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:974
msgid "Some editors can interpret configuration information embedded in source files, indicated with special markers.  For example, emacs interprets lines marked like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:978
msgid "-*- mode: c -*-"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:982
msgid "Or like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:984
msgid ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:992
msgid "Vim interprets markers that look like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:994
msgid "/* vim:set sw=8 noet */"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:998
msgid "Do not include any of these in source files.  People have their own personal editor configurations, and your source files should not override them.  This includes markers for indentation and mode configuration.  People may use their own custom mode, or may have some other magic method for making indentation work correctly."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1006
msgid "Appendix I: References"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1008
msgid "`The C Programming Language, Second Edition <https://en.wikipedia.org/wiki/The_C_Programming_Language>`_ by Brian W. Kernighan and Dennis M. Ritchie. |br| Prentice Hall, Inc., 1988. |br| ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1013
msgid "`The Practice of Programming <https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_ by Brian W. Kernighan and Rob Pike. |br| Addison-Wesley, Inc., 1999. |br| ISBN 0-201-61586-X."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1018
msgid "`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with K&R and this text - for **cpp**, **gcc**, **gcc internals** and **indent**"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1021
msgid "`WG14 International standardization workgroup for the programming language C <http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1024
msgid "`Kernel CodingStyle, by greg@kroah.com at OLS 2002 <http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:3
msgid "Developer guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:9
msgid "How to work on a bug"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:11
msgid "Any defect, even minor, if it changes the user-visible server behavior, needs a bug report. Report a bug at http://github.com/tarantool/tarantool/issues."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:14
msgid "When reporting a bug, try to come up with a test case right away. Set the current maintenance milestone for the bug fix, and specify the series. Assign the bug to yourself. Put the status to 'In progress' Once the patch is ready, put the bug the bug to 'In review' and solicit a review for the fix."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:19
msgid "Once there is a positive code review, push the patch and set the status to 'Closed'"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:21
msgid "Patches for bugs should contain a reference to the respective Launchpad bug page or at least bug id. Each patch should have a test, unless coming up with one is difficult in the current framework, in which case QA should be alerted."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:25
msgid "There are two things you need to do when your patch makes it into the master:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:27
msgid "put the bug to 'fix committed',"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:28
msgid "delete the remote branch."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:34
msgid "How to write a commit message"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:36
msgid "Any commit needs a helpful message. Mind the following guidelines when committing to any of Tarantool repositories at GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:39
msgid "Separate subject from body with a blank line."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:40
msgid "Try to limit the subject line to **50 characters** or so."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:41
msgid "Start the subject line with a capital letter unless it prefixed with a subsystem name and semicolon:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:44
msgid "memtx:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:45
msgid "vinyl:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:46
msgid "xlog:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:47
msgid "replication:"
msgstr "replication:"

#: ../doc/1.7/dev_guide/developer_guidelines.rst:48
msgid "recovery:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:49
msgid "iproto:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:50
msgid "net.box:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:51
msgid "lua:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:52
msgid "sql:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:54
msgid "Do not end the subject line with a period."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:55
msgid "Do not put \"gh-xx\", \"closes #xxx\" to the subject line."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:56
msgid "Use the imperative mood in the subject line. A properly formed Git commit subject line should always be able to complete the following sentence: \"If applied, this commit will */your subject line here/*\"."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:59
msgid "Wrap the body to **72 characters** or so."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:60
msgid "Use the body to explain **what and why** vs. how."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:61
msgid "Link GitHub issues on the lasts lines (`see how <https://help.github.com/articles/closing-issues-via-commit-messages>`_)."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:63
msgid "Use your real name and real email address. For Tarantool team members, **@tarantool.org** email is preferred, but not mandatory."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:67
msgid "A template:"
msgstr "Шаблон:"

#: ../doc/1.7/dev_guide/developer_guidelines.rst:69
msgid ""
"Summarize changes in 50 characters or less\n"
"\n"
"More detailed explanatory text, if necessary.\n"
"Wrap it to 72 characters or so.\n"
"In some contexts, the first line is treated as the subject of the\n"
"commit, and the rest of the text as the body.\n"
"The blank line separating the summary from the body is critical\n"
"(unless you omit the body entirely); various tools like `log`,\n"
"`shortlog` and `rebase` can get confused if you run the two together.\n"
"\n"
"Explain the problem that this commit is solving. Focus on why you\n"
"are making this change as opposed to how (the code explains that).\n"
"Are there side effects or other unintuitive consequences of this\n"
"change? Here's the place to explain them.\n"
"\n"
"Further paragraphs come after blank lines.\n"
"\n"
"- Bullet points are okay, too.\n"
"\n"
"- Typically a hyphen or asterisk is used for the bullet, preceded\n"
"  by a single space, with blank lines in between, but conventions\n"
"  vary here.\n"
"\n"
"Fixes: #123\n"
"Closes: #456\n"
"Needed for: #859\n"
"See also: #343, #789"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:99
msgid "Some real-world examples:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:101
msgid "`tarantool/tarantool@2993a75 <https://github.com/tarantool/tarantool/commit/2993a75858352f101deb4a15cefd497ae6a78cf7>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:102
msgid "`tarantool/tarantool@ccacba2 <https://github.com/tarantool/tarantool/commit/ccacba28f813fb99fd9eaf07fb41bf604dd341bc>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:103
msgid "`tarantool/tarantool@386df3d <https://github.com/tarantool/tarantool/commit/386df3d3eb9c5239fc83fd4dd3292d1b49446b89>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:104
msgid "`tarantool/tarantool@076a842 <https://github.com/tarantool/tarantool/commit/076a842011e09c84c25fb5e68f1b23c9917a3750>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:106
msgid "Based on [1_] and [2_]."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:112
msgid "How to submit a patch for review"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:114
msgid "We don't accept GitHub pull requests. Instead, all patches should be sent as plain-text messages to tarantool-patches@freelists.org. Please subscribe to our mailing list at https://www.freelists.org/list/tarantool-patches to ensure that your messages are added to the archive."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:120
msgid "**Preparing a patch**"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:122
msgid "Once you have committed a patch to your local git repository, you can submit it for review."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:125
msgid "To prepare an email, use ``git format-patch`` command:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:127
msgid "$ git format-patch -1"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:131
msgid "It will format the commit at the top of your local git repository as a plain-text email and write it to a file in the current directory. The file name will look like ``0001-your-commit-subject-line.patch``. To specify a different directory, use ``-o`` option:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:136
msgid "$ git format-patch -1 -o ~/patches-to-send"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:140
msgid "Once the patch has been formatted, you can view and edit it with your favorite text editor (after all, it is a plain-text file!). We strongly recommend adding:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:144
msgid "a hyperlink to the branch where this patch can be found at GitHub, and"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:145
msgid "a hyperlink to the GitHub issue your patch is supposed to fix, if any."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:147
msgid "If there is just one patch, the change log should go right after ``---`` in the message body (it will be ignored by ``git am`` then)."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:150
msgid "If there are multiple patches you want to submit in one go (e.g. this is a big feature which requires some preparatory patches to be committed first), you should send each patch in a separate email in reply to a cover letter. To format a patch series accordingly, pass the following options to ``git format-patch``:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:156
msgid "$ git format-patch --cover-letter --thread=shallow HEAD~2"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:162
msgid "``--cover-letter`` will make ``git format-patch`` generate a cover letter;"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:163
msgid "``--thread=shallow`` will mark each formatted patch email to be sent in reply to the cover letter;"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:165
msgid "``HEAD~2`` (we now use it instead of ``-1``) will make ``git format-patch`` format the first two patches at the top of your local git branch instead of just one. To format three patches, use ``HEAD~3``, and so forth."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:169
msgid "After the command has been successfully executed, you will find all your patches formatted as separate emails in your current directory (or in the directory specified via ``-o`` option):"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:173
msgid ""
"0000-cover-letter.patch\n"
"0001-first-commit.patch\n"
"0002-second-commit.patch\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:180
msgid "The cover letter will have BLURB in its subject and body. You'll have to edit it before submitting (again, it is a plain text file). Please write:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:183
msgid "a short series description in the subject line;"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:184
msgid "a few words about each patch of the series in the body."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:186
msgid "And don't forget to add hyperlinks to the GitHub issue and branch where your series can be found. In this case you don't need to put links or any additional information to each individual email -- the cover letter will cover everything."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:193
msgid "To omit ``--cover-letter`` and ``--thread=shallow`` options, you can add the following lines to your gitconfig:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:196
msgid ""
"[format]\n"
"    thread = shallow\n"
"    coverLetter = auto"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:202
msgid "**Sending a patch**"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:204
msgid "Once you have formatted your patches, they are ready to be sent via email. Of course, you can send them with your favorite mail agent, but it is much easier to use ``git send-email`` for this. Before using this command, you need to configure it."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:209
msgid "If you use a GMail account, add the following code to your ``.gitconfig``:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:211
msgid ""
"[sendemail]\n"
"    smtpencryption = tls\n"
"    smtpserver = smtp.gmail.com\n"
"    smtpserverport = 587\n"
"    smtpuser = your.name@gmail.com\n"
"    smtppass = topsecret"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:220
msgid "For mail.ru users, the configuration will be slightly different:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:222
msgid ""
"[sendemail]\n"
"    smtpencryption = ssl\n"
"    smtpserver = smtp.mail.ru\n"
"    smtpserverport = 465\n"
"    smtpuser = your.name@mail.ru\n"
"    smtppass = topsecret"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:231
msgid "If your email account is hosted by another service, consult your service provider about your SMTP settings."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:234
msgid "Once configured, use the following command to send your patches:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:236
msgid "$ git send-email --to tarantool-patches@freelists.org 00*"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:240
msgid "(``00*`` wildcard will be expanded by your shell to the list of patches generated at the previous step.)"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:243
msgid "If you want someone in particular to review your patch, add them to the list of recipients by passing ``--to`` or ``--cc`` once per each recipient."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:248
msgid "It is useful to check that ``git send-email`` will work as expected without sending anything to the world. Use ``--dry-run`` option for that."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:251
msgid "**Review process**"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:253
msgid "After having sent your patches, you just wait for a review. The reviewer will send their comments back to you in reply to the email that contains the patch that in their opinion needs to be fixed."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:257
msgid "Upon receiving an email with review remarks, you carefully read it and reply about whether you agree or disagree with. Please note that we use the interleaved reply style (aka \"inline reply\") for communications over email."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:261
msgid "Upon reaching an agreement, you send a fixed patch in reply to the email that ended the discussion. To send a patch, you can either attach a plain diff (created by ``git diff`` or ``git format-patch``) to email and send it with your favorite mail agent, or use ``--in-reply-to`` option of ``git send-email`` command."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:267
msgid "If you feel that the accumulated change set is large enough to send the whole series anew and restart the review process in a different thread, you generate the patch email(s) again with ``git format-patch``, this time adding v2 (then v3, v4, and so forth) to the subject and a change log to the message body. To modify the subject line accordingly, use the ``--subject-prefix`` option to ``git format-patch`` command:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:274
msgid "$ git format-patch -1 --subject-prefix='PATCH v2'"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:278
msgid "To add a change log, open the generated email with you favorite text editor and edit the message body. If there is just one patch, the change log should go right after ``---`` in the message body (it will be ignored by ``git am`` then). If there is more than one patch, the change log should be added to the cover letter. Here is an example of a good change log:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:284
msgid ""
"Changes in v3:\n"
"  - Fixed comments as per review by Alex\n"
"  - Added more tests\n"
"Changes in v2:\n"
"  - Fixed a crash if the user passes invalid options\n"
"  - Fixed a memory leak at exit"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:293
msgid "It is also a good practice to add a reference to the previous version of your patch set (via a hyperlink or message id)."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:298
msgid "Do not disagree with the reviewer without providing a good argument supporting your point of view."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:300
msgid "Do not take every word the reviewer says for granted. Reviewers are humans too, hence fallible."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:302
msgid "Do not expect that the reviewer will tell you how to do your thing. It is not their job. The reviewer might suggest alternative ways to tackle the problem, but in general it is your responsibility."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:305
msgid "Do not forget to update your remote git branch every time you send a new version of your patch."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:307
msgid "Do follow the guidelines above. If you do not comply, your patches are likely to be silently ignored."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:5
msgid "Documentation guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:7
msgid "These guidelines are updated on the on-demand basis, covering only those issues that cause pains to the existing writers. At this point, we do not aim to come up with an exhaustive Documentation Style Guide for the Tarantool project."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:13
msgid "Markup issues"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:17
msgid "Wrapping text"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:19
msgid "The limit is 80 characters per line for plain text, and no limit for any other constructions when wrapping affects ReST readability and/or HTML output. Also, it makes no sense to wrap text into lines shorter than 80 characters unless you have a good reason to do so."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:24
msgid "The 80-character limit comes from the ISO/ANSI 80x24 screen resolution, and it's unlikely that readers/writers will use 80-character consoles. Yet it's still a standard for many coding guidelines (including Tarantool). As for writers, the benefit is that an 80-character page guide allows keeping the text window rather narrow most of the time, leaving more space for other applications in a wide-screen environment."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:33
msgid "Formatting code snippets"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:35
msgid "For code snippets, we mainly use the ``code-block`` directive with an appropriate highlighting language. The most commonly used highlighting languages are:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:39
msgid "``.. code-block:: tarantoolsession``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:40
msgid "``.. code-block:: console``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:41
msgid "``.. code-block:: lua``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:43
msgid "For example (a code snippet in Lua):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:45
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:52
msgid "In rare cases, when we need custom highlight for specific parts of a code snippet and the ``code-block`` directive is not enough, we use the per-line ``codenormal`` directive together and explicit output formatting (defined in :file:`doc/sphinx/_static/sphinx_design.css`)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:57
msgid "Examples:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:59
msgid "Function syntax (the placeholder `space-name` is displayed in italics):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:61
msgid ":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:create_index('index-name')`"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:63
msgid "A tdb session (user input is in bold, command prompt is in blue, computer output is in green):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:103
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:75
msgid "Warning: Every entry of explicit output formatting (``codenormal``, ``codebold``, etc) tends to cause troubles when this documentation is translated to other languages. Please avoid using explicit output formatting unless it is REALLY needed."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:82
msgid "Using separated links"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:84
msgid "Avoid separating the link and the target definition (ref), like this:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:86
msgid ""
"This is a paragraph that contains `a link`_.\n"
"\n"
".. _a link: http://example.com/"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:92
msgid "Use non-separated links instead:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:94
msgid "This is a paragraph that contains `a link <http://example.com/>`_."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:98
msgid "Warning: Every separated link tends to cause troubles when this documentation is translated to other languages. Please avoid using separated links unless it is REALLY needed (e.g. in tables)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:104
msgid "Creating labels for local links"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:106
msgid "We avoid using links that sphinx generates automatically for most objects. Instead, we add our own labels for linking to any place in this documentation."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:109
msgid "Our naming convention is as follows:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:111
msgid "Character set: a through z, 0 through 9, dash, underscore."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:113
msgid "Format: ``path dash filename dash tag``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:115
msgid "Example: ``_c_api-box_index-iterator_type`` |br| where: |br| ``c_api`` is the directory name, |br| ``box_index`` is the file name (without \".rst\"), and |br| ``iterator_type`` is the tag."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:121
msgid "The file name is useful for knowing, when you see \"ref\", where it is pointing to. And if the file name is meaningful, you see that better."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:124
msgid "The file name alone, without a path, is enough when the file name is unique within ``doc/sphinx``. So, for ``fiber.rst`` it should be just \"fiber\", not \"reference-fiber\". While for \"index.rst\" (we have a handful of \"index.rst\" in different directories) please specify the path before the file name, e.g. \"reference-index\"."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:131
msgid "Use a dash \"-\" to delimit the path and the file name. In the documentation source, we use only underscores \"_\" in paths and file names, reserving dash \"-\" as the delimiter for local links."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:135
msgid "The tag can be anything meaningful. The only guideline is for Tarantool syntax items (such as members), where the preferred tag syntax is ``module_or_object_name dash member_name``. For example, ``box_space-drop``."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:141
msgid "Making comments"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:143
msgid "Sometimes we may need to leave comments in a ReST file. To make sphinx ignore some text during processing, use the following per-line notation with \".. //\" as the comment marker:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:147
msgid ".. // your comment here"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:151
msgid "The starting symbols \".. //\" do not interfere with the other ReST markup, and they are easy to find both visually and using grep. There are no symbols to escape in grep search, just go ahead with something like this:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:155
msgid "$ grep \".. //\" doc/sphinx/dev_guide/*.rst"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:159
msgid "These comments don't work properly in nested documentation, though (e.g. if you leave a comment in module -> object -> method, sphinx ignores the comment and all nested content that follows in the method description)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:165
msgid "Language and style issues"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:169
msgid "US vs British spelling"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:171
msgid "We use English US spelling."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:175
msgid "Instance vs server"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:177
msgid "We say \"instance\" rather than \"server\" to refer to an instance of Tarantool server. This keeps the manual terminology consistent with names like ``/etc/tarantool/instances.enabled`` in the Tarantool environment."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:181
msgid "Wrong usage: \"Replication allows multiple Tarantool *servers* to work on copies of the same databases.\""
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:184
msgid "Correct usage: \"Replication allows multiple Tarantool *instances* to work on copies of the same databases.\""
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:189
msgid "Examples and templates"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:193
msgid "Module and function"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:195
msgid "Here is an example of documenting a module (``my_fiber``) and a function (``my_fiber.create``)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:202
msgid "Create and start a ``my_fiber`` object. The object is created and begins to run immediately."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:205
msgid "the function to be associated with the ``my_fiber`` object"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:206
#: ../doc/1.7/reference/reference_lua/fiber.rst:185
msgid "what will be passed to function"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:208
msgid "created ``my_fiber`` object"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:213
msgid ""
"tarantool> my_fiber = require('my_fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   my_fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> my_fiber_object = my_fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:229
msgid "Module, class and method"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:231
msgid "Here is an example of documenting a module (``my_box.index``), a class (``my_index_object``) and a function (``my_index_object.rename``)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:242
msgid "an object reference"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:243
msgid "a new name for the index (type = string)"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:247
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:257
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.7/dev_guide/guidelines_index.rst:3
msgid "Guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/index.rst:5
msgid "Contributor's Guide"
msgstr ""

#: ../doc/1.7/dev_guide/internals_index.rst:3
msgid "Internals"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:5
msgid "Tarantool's binary protocol"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:7
msgid "Tarantool's binary protocol is a binary request/response protocol."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:11
msgid "Notation in diagrams"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:13
msgid ""
"0    X\n"
"+----+\n"
"|    | - X bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is a MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:32
msgid "MsgPack data types:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:34
msgid "**MP_INT** - Integer"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:35
msgid "**MP_MAP** - Map"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:36
msgid "**MP_ARR** - Array"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:37
msgid "**MP_STRING** - String"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:38
msgid "**MP_FIXSTR** - Fixed size string"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:39
msgid "**MP_OBJECT** - Any MsgPack object"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:40
msgid "**MP_BIN** - MsgPack binary format"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:44
msgid "Greeting packet"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:46
msgid ""
"TARANTOOL'S GREETING:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:62
msgid "The server instance begins the dialogue by sending a fixed-size (128-byte) text greeting to the client. The greeting always contains two 64-byte lines of ASCII text, each line ending with a newline character ('\\\\n'). The first line contains the instance version and protocol type. The second line contains up to 44 bytes of base64-encoded random string, to use in the authentication packet, and ends with up to 23 spaces."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:70
msgid "Unified packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:72
msgid "Once a greeting is read, the protocol becomes pure request/response and features a complete access to Tarantool functionality, including:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:75
msgid "request multiplexing, e.g. ability to asynchronously issue multiple requests via the same connection"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:77
msgid "response format that supports zero-copy writes"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:79
msgid "For data structuring and encoding, the protocol uses msgpack data format, see http://msgpack.org"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:82
msgid "The Tarantool protocol mandates use of a few integer constants serving as keys in maps used in the protocol. These constants are defined in `src/box/iproto_constants.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:86
msgid "We list them here too:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:88
msgid ""
"-- user keys\n"
"<code>          ::= 0x00\n"
"<sync>          ::= 0x01\n"
"<schema_id>     ::= 0x05\n"
"<space_id>      ::= 0x10\n"
"<index_id>      ::= 0x11\n"
"<limit>         ::= 0x12\n"
"<offset>        ::= 0x13\n"
"<iterator>      ::= 0x14\n"
"<key>           ::= 0x20\n"
"<tuple>         ::= 0x21\n"
"<function_name> ::= 0x22\n"
"<username>      ::= 0x23\n"
"<expression>    ::= 0x27\n"
"<ops>           ::= 0x28\n"
"<data>          ::= 0x30\n"
"<error>         ::= 0x31"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:108
msgid ""
"-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<select>       ::= 0x01\n"
"<insert>       ::= 0x02\n"
"<replace>      ::= 0x03\n"
"<update>       ::= 0x04\n"
"<delete>       ::= 0x05\n"
"<call_16>      ::= 0x06\n"
"<auth>         ::= 0x07\n"
"<eval>         ::= 0x08\n"
"<upsert>       ::= 0x09\n"
"<call>         ::= 0x0a\n"
"-- Admin command codes\n"
"-- (including codes for replica-set initialization and master election)\n"
"<ping>         ::= 0x40\n"
"<join>         ::= 0x41\n"
"<subscribe>    ::= 0x42\n"
"<request_vote> ::= 0x43\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<OK>      ::= 0x00\n"
"<ERROR>   ::= 0x8XXX"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:134
msgid "Both :code:`<header>` and :code:`<body>` are msgpack maps:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:136
msgid ""
"Request/Response:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:148
msgid ""
"UNIFIED HEADER:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:160
msgid "They only differ in the allowed set of keys and values. The key defines the type of value that follows. If a body has no keys, the entire msgpack map for the body may be missing. Such is the case, for example, for a <ping> request. ``schema_id`` may be absent in the request's header, meaning that there will be no version checking, but it must be present in the response. If ``schema_id`` is sent in the header, then it will be checked."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:171
msgid "Authentication"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:173
msgid "When a client connects to the server instance, the instance responds with a 128-byte text greeting message. Part of the greeting is base-64 encoded session salt - a random string which can be used for authentication. The length of decoded salt (44 bytes) exceeds the amount necessary to sign the authentication message (first 20 bytes). An excess is reserved for future authentication schemas."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:180
msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:208
msgid ":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 fields: authentication mechanism (\"chap-sha1\" is the only supported mechanism right now) and password, encrypted according to the specified mechanism. Authentication in Tarantool is optional, if no authentication is performed, session user is 'guest'. The instance responds to authentication packet with a standard response with 0 tuples."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:216
msgid "Requests"
msgstr "Запросы"

#: ../doc/1.7/dev_guide/box_protocol.rst:218
msgid "SELECT: CODE - 0x01 Find tuples matching the search pattern"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:221
msgid ""
"SELECT BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:238
msgid "INSERT:  CODE - 0x02 Inserts tuple into the space, if no tuple with same unique keys exists. Otherwise throw *duplicate key* error."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:240
msgid "REPLACE: CODE - 0x03 Insert a tuple into the space or replace an existing one."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:243
msgid ""
"INSERT/REPLACE BODY:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:256
msgid "UPDATE: CODE - 0x04 Update a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:259
msgid ""
"UPDATE BODY:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:278
msgid ""
"OP:\n"
"    Works only for integer fields:\n"
"    * Addition    OP = '+' . space[key][field_no] += argument\n"
"    * Subtraction OP = '-' . space[key][field_no] -= argument\n"
"    * Bitwise AND OP = '&' . space[key][field_no] &= argument\n"
"    * Bitwise XOR OP = '^' . space[key][field_no] ^= argument\n"
"    * Bitwise OR  OP = '|' . space[key][field_no] |= argument\n"
"    Works on any fields:\n"
"    * Delete      OP = '#'\n"
"      delete <argument> fields starting\n"
"      from <field_no> in the space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:301
msgid ""
"    * Insert      OP = '!'\n"
"      insert <argument> before <field_no>\n"
"    * Assign      OP = '='\n"
"      assign <argument> to field <field_no>.\n"
"      will extend the tuple if <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Works on string fields:\n"
"    * Splice      OP = ':'\n"
"      take the string from space[key][field_no] and\n"
"      substitute <offset> bytes from <position> with <argument>"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:323
msgid ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:335
msgid "It is an error to specify an argument of a type that differs from the expected type."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:337
msgid "DELETE: CODE - 0x05 Delete a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:340
msgid ""
"DELETE BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:353
msgid "CALL_16: CODE - 0x06 Call a stored function, returning an array of tuples. This is deprecated; CALL (0x0a) is recommended instead."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:356
msgid ""
"CALL_16 BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:370
msgid "EVAL: CODE - 0x08 Evaulate Lua expression"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:373
msgid ""
"EVAL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:386
msgid "UPSERT: CODE - 0x09 Update tuple if it would be found elsewhere try to insert tuple. Always use primary index for key."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:389
msgid ""
"UPSERT BODY:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Operations structure same as for UPDATE operation.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Supported operations:\n"
"\n"
"'+' - add a value to a numeric field. If the filed is not numeric, it's\n"
"      changed to 0 first. If the field does not exist, the operation is\n"
"      skipped. There is no error in case of overflow either, the value\n"
"      simply wraps around in C style. The range of the integer is MsgPack:\n"
"      from -2^63 to 2^64-1\n"
"'-' - same as the previous, but subtract a value\n"
"'=' - assign a field to a value. The field must exist, if it does not exist,\n"
"      the operation is skipped.\n"
"'!' - insert a field. It's only possible to insert a field if this create no\n"
"      nil \"gaps\" between fields. E.g. it's possible to add a field between\n"
"      existing fields or as the last field of the tuple.\n"
"'#' - delete a field. If the field does not exist, the operation is skipped.\n"
"      It's not possible to change with update operations a part of the primary\n"
"      key (this is validated before performing upsert)."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:430
msgid "CALL: CODE - 0x0a Similar to CALL_16, but -- like EVAL, CALL returns a list of values, unconverted"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:433
msgid ""
"CALL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:448
msgid "Response packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:450
msgid "We will show whole packets here:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:452
msgid ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:466
msgid "Set of tuples in the response :code:`<data>` expects a msgpack array of tuples as value EVAL command returns arbitrary `MP_ARRAY` with arbitrary MsgPack values."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:469
msgid ""
"ERROR: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Where 0xXXX is ERRCODE."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:484
msgid "An error message is present in the response only if there is an error; :code:`<error>` expects as value a msgpack string."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:487
msgid "Convenience macros which define hexadecimal constants for return codes can be found in `src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:493
msgid "Replication packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:495
msgid ""
"-- replication keys\n"
"<server_id>     ::= 0x02\n"
"<lsn>           ::= 0x03\n"
"<timestamp>     ::= 0x04\n"
"<server_uuid>   ::= 0x24\n"
"<cluster_uuid>  ::= 0x25\n"
"<vclock>        ::= 0x26"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:505
msgid ""
"-- replication codes\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:512
msgid ""
"JOIN:\n"
"\n"
"In the beginning you must send initial JOIN\n"
"               HEADER                      BODY\n"
"+================+================++===================+\n"
"|                |                ||   SERVER_UUID     |\n"
"|   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"|                |                ||                   |\n"
"+================+================++===================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Then instance, which we connect to, will send last SNAP file by, simply,\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x42    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every query that'll came through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:572
msgid "XLOG / SNAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:574
msgid "XLOG and SNAP files have nearly the same format. The header looks like:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:576
msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:584
msgid "After the file header come the data tuples. Tuples begin with a row marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker ``0xd510aded``. Thus, between the file header and the EOF marker, there may be data tuples that have this form:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:591
msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:608
msgid "See the example in the following section."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:9
msgid "Data persistence and the WAL file format"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:11
msgid "To maintain data persistence, Tarantool writes each data change request (insert, update, delete, replace, upsert) into a write-ahead log (WAL) file in the :ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file is created for every :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` records. Each data change request gets assigned a continuously growing 64-bit log sequence number. The name of the WAL file is based on the log sequence number of the first record in the file, plus an extension ``.xlog``."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:19
msgid "Apart from a log sequence number and the data change request (formatted as in :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`), each WAL record contains a header, some metadata, and then the data formatted according to `msgpack <https://en.wikipedia.org/wiki/MessagePack>`_ rules. For example, this is what the WAL file looks like after the first INSERT request (\"s:insert({1})\") for the sandbox database created in our :ref:`\"Getting started\" exercises <getting_started>`. On the left are the hexadecimal bytes that you would see with:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:28
msgid "$ hexdump 00000000000000000000.xlog"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:32
msgid "and on the right are comments."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:34
msgid ""
"Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" follows\n"
"00 02                         element#1: tag=request type, value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte \"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed array={1}"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:63
msgid "A tool for reading .xlog files is Tarantool's :ref:`xlog module <xlog>`."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:65
msgid "Tarantool processes requests atomically: a change is either accepted and recorded in the WAL, or discarded completely. Let's clarify how this happens, using the REPLACE request as an example:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:69
msgid "The server instance attempts to locate the original tuple by primary key. If found, a reference to the tuple is retained for later use."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:72
msgid "The new tuple is validated. If for example it does not contain an indexed field, or it has an indexed field whose type does not match the type according to the index definition, the change is aborted."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:76
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:78
msgid "A message is sent to the writer process running in the WAL thread, requesting that the change be recorded in the WAL. The instance switches to work on the next request until the write is acknowledged."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:82
msgid "On success, a confirmation is sent to the client. On failure, a rollback procedure is begun. During the rollback procedure, the transaction processor rolls back all changes to the database which occurred after the first failed change, from latest to oldest, up to the first failed change. All rolled back requests are aborted with :errcode:`ER_WAL_IO <ER_WAL_IO>` error. No new change is applied while rollback is in progress. When the rollback procedure is finished, the server restarts the processing pipeline."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:90
msgid "One advantage of the described algorithm is that complete request pipelining is achieved, even for requests on the same value of the primary key. As a result, database performance doesn't degrade even if all requests refer to the same key in the same space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:95
msgid "The transaction processor thread communicates with the WAL writer thread using asynchronous (yet reliable) messaging; the transaction processor thread, not being blocked on WAL tasks, continues to handle requests quickly even at high volumes of disk I/O. A response to a request is sent as soon as it is ready, even if there were earlier incomplete requests on the same connection. In particular, SELECT performance, even for SELECTs running on a connection packed with UPDATEs and DELETEs, remains unaffected by disk load."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:103
msgid "The WAL writer employs a number of durability modes, as defined in configuration variable :ref:`wal_mode <index-wal_mode>`. It is possible to turn the write-ahead log completely off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the write-ahead log it's still possible to take a persistent copy of the entire data set with the :ref:`box.snapshot() <box-snapshot>` request."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:110
msgid "An .xlog file always contains changes based on the primary key. Even if the client requested an update or delete using a secondary key, the record in the .xlog file will contain the primary key."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:118
msgid "The snapshot file format"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:120
msgid "The format of a snapshot .snap file is nearly the same as the format of a WAL .xlog file. However, the snapshot header differs: it contains the instance's global unique identifier and the snapshot file's position in history, relative to earlier snapshot files. Also, the content differs: an .xlog file may contain records for any data-change requests (inserts, updates, upserts, and deletes), a .snap file may only contain records of inserts to memtx spaces."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:127
msgid "Primarily, the .snap file's records are ordered by space id. Therefore the records of system spaces -- such as ``_schema``, ``_space``, ``_index``, ``_func``, ``_priv`` and ``_cluster`` -- will be at the start of the .snap file, before the records of any spaces that were created by users."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:132
msgid "Secondarily, the .snap file's records are ordered by primary key within space id."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:138
msgid "The recovery process"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:140
msgid "The recovery process begins when box.cfg{} happens for the first time after the Tarantool server instance starts."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:143
msgid "The recovery process must recover the databases as of the moment when the instance was last shut down. For this it may use the latest snapshot file and any WAL files that were written after the snapshot. One complicating factor is that Tarantool has two engines -- the memtx data must be reconstructed entirely from the snapshot and the WAL files, while the vinyl data will be on disk but might require updating around the time of a checkpoint. (When a snapshot happens, Tarantool tells the vinyl engine to make a checkpoint, and the snapshot operation is rolled back if anything goes wrong, so vinyl's checkpoint is at least as fresh as the snapshot file.)"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:160
msgid "Step 1"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:156
msgid "Read the configuration parameters in the ``box.cfg{}`` request. Parameters which affect recovery may include :ref:`work_dir <cfg_basic-work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, :ref:`memtx_dir <cfg_basic-memtx_dir>`, :ref:`vinyl_dir <cfg_basic-vinyl_dir>` and :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:180
msgid "Step 2"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:163
msgid "Find the latest snapshot file. Use its data to reconstruct the in-memory databases. Instruct the vinyl engine to recover to the latest checkpoint."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:166
msgid "There are actually two variations of the reconstruction procedure for memtx databases, depending on whether the recovery process is \"default\"."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:169
msgid "If the recovery process is default (``force_recovery`` is ``false``), memtx can read data in the snapshot with all indexes disabled. First, all tuples are read into memory. Then, primary keys are built in bulk, taking advantage of the fact that the data is already sorted by primary key within each space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:175
msgid "If the recovery process is non-default (``force_recovery`` is ``true``), Tarantool performs additional checking. Indexes are enabled at the start, and tuples are added one by one. This means that any unique-key constraint violations will be caught, and any duplicates will be skipped. Normally there will be no constraint violations or duplicates, so these checks are only made if an error has occurred."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:187
msgid "Step 3"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:183
msgid "Find the WAL file that was made at the time of, or after, the snapshot file. Read its log entries until the log-entry LSN is greater than the LSN of the snapshot, or greater than the LSN of the vinyl checkpoint. This is the recovery process's \"start position\"; it matches the current state of the engines."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:191
msgid "Step 4"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:190
msgid "Redo the log entries, from the start position to the end of the WAL. The engine skips a redo instruction if it is older than the engine's checkpoint."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:194
msgid "Step 5"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:194
msgid "For the memtx engine, re-create all secondary indexes."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:200
msgid "Server startup with replication"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:202
msgid "In addition to the recovery process described above, the server must take additional steps and precautions if :ref:`replication <replication>` is enabled."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:205
msgid "Once again the startup procedure is initiated by the ``box.cfg{}`` request. One of the ``box.cfg`` parameters may be :ref:`replication <cfg_replication-replication>` that specifies replication source(-s). We will refer to this replica, which is starting up due to ``box.cfg``, as the \"local\" replica to distinguish it from the other replicas in a replica set, which we will refer to as \"distant\" replicas."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:212
msgid "*If there is no snapshot .snap file and the ``replication`` parameter is empty*: |br| then the local replica assumes it is an unreplicated \"standalone\" instance, or is the first replica of a new replica set. It will generate new UUIDs for itself and for the replica set. The replica UUID is stored in the ``_cluster`` space; the replica set UUID is stored in the ``_schema`` space. Since a snapshot contains all the data in all the spaces, that means the local replica's snapshot will contain the replica UUID and the replica set UUID. Therefore, when the local replica restarts on later occasions, it will be able to recover these UUIDs when it reads the .snap file."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:222
msgid "*If there is no snapshot .snap file and the ``replication`` parameter is not empty and the ``_cluster`` space contains no other replica UUIDs*: |br| then the local replica assumes it is not a standalone instance, but is not yet part of a replica set. It must now join the replica set. It will send its replica UUID to the first distant replica which is listed in ``replication`` and which will act as a master. This is called the \"join request\". When a distant replica receives a join request, it will send back:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:230
msgid "the distant replica's replica set UUID,"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:231
msgid "the contents of the distant replica's .snap file. |br| When the local replica receives this information, it puts the replica set UUID in its ``_schema`` space, puts the distant replica's UUID and connection information in its ``_cluster`` space, and makes a snapshot containing all the data sent by the distant replica. Then, if the local replica has data in its WAL .xlog files, it sends that data to the distant replica. The distant replica will receive this and update its own copy of the data, and add the local replica's UUID to its ``_cluster`` space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:240
msgid "*If there is no snapshot .snap file and the ``replication`` parameter is not empty and the ``_cluster`` space contains other replica UUIDs*: |br| then the local replica assumes it is not a standalone instance, and is already part of a replica set. It will send its replica UUID and replica set UUID to all the distant replicas which are listed in ``replication``. This is called the \"on-connect handshake\". When a distant replica receives an on-connect handshake: |br|"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:247
msgid "the distant replica compares its own copy of the replica set UUID to the one in the on-connect handshake. If there is no match, then the handshake fails and the local replica will display an error."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:250
msgid "the distant replica looks for a record of the connecting instance in its ``_cluster`` space. If there is none, then the handshake fails. |br| Otherwise the handshake is successful. The distant replica will read any new information from its own .snap and .xlog files, and send the new requests to the local replica."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:256
msgid "In the end ... the local replica knows what replica set it belongs to, the distant replica knows that the local replica is a member of the replica set, and both replicas have the same database contents."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:262
msgid "*If there is a snapshot file and replication source is not empty*: |br| first the local replica goes through the recovery process described in the previous section, using its own .snap and .xlog files. Then it sends a \"subscribe\" request to all the other replicas of the replica set. The subscribe request contains the server vector clock. The vector clock has a collection of pairs 'server id, lsn' for every replica in the ``_cluster`` system space. Each distant replica, upon receiving a subscribe request, will read its .xlog files' requests and send them to the local replica if (lsn of .xlog file request) is greater than (lsn of the vector clock in the subscribe request). After all the other replicas of the replica set have responded to the local replica's subscribe request, the replica startup is complete."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:274
msgid "The following temporary limitations apply for version 1.7:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:276
msgid "The URIs in the ``replication`` parameter should all be in the same order on all replicas. This is not mandatory but is an aid to consistency."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:278
msgid "The replicas of a replica set should be started up at slightly different times. This is not mandatory but prevents a situation where each replica is waiting for the other replica to be ready."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:281
msgid "The maximum number of entries in the ``_cluster`` space is 32. Tuples for out-of-date replicas are not automatically re-used, so if this 32-replica limit is reached, users may have to reorganize the ``_cluster`` space manually."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:3
msgid "Lua Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:5
msgid "Inspiration:"
msgstr "Для вдохновения:"

#: ../doc/1.7/dev_guide/lua_style_guide.rst:7
msgid "https://github.com/Olivine-Labs/lua-style-guide"
msgstr "https://github.com/Olivine-Labs/lua-style-guide"

#: ../doc/1.7/dev_guide/lua_style_guide.rst:8
msgid "http://dev.minetest.net/Lua_code_style_guidelines"
msgstr "http://dev.minetest.net/Lua_code_style_guidelines"

#: ../doc/1.7/dev_guide/lua_style_guide.rst:9
msgid "http://sputnik.freewisdom.org/en/Coding_Standard"
msgstr "http://sputnik.freewisdom.org/en/Coding_Standard"

#: ../doc/1.7/dev_guide/lua_style_guide.rst:11
msgid "Programming style is an art. There is some arbitrariness to the rules, but there are sound rationales for them. It is useful not only to provide sound advice on style but to understand the underlying rationale and human aspect of why the style recommendations are formed:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:16
msgid "http://mindprod.com/jgloss/unmain.html"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:17
msgid "http://www.oreilly.com/catalog/perlbp/"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:18
msgid "http://books.google.com/books?id=QnghAQAAIAAJ"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:20
msgid "Zen of Python is good; understand it and use wisely:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Beautiful is better than ugly."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Explicit is better than implicit."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Simple is better than complex."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Complex is better than complicated."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Flat is better than nested."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Sparse is better than dense."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Readability counts."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Special cases aren't special enough to break the rules."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although practicality beats purity."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Errors should never pass silently."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Unless explicitly silenced."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "In the face of ambiguity, refuse the temptation to guess."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "There should be one -- and preferably only one -- obvious way to do it."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although that way may not be obvious at first unless you're Dutch."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Now is better than never."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although never is often better than *right* now."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "If the implementation is hard to explain, it's a bad idea."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "If the implementation is easy to explain, it may be a good idea."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Namespaces are one honking great idea -- let's do more of those!"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "https://www.python.org/dev/peps/pep-0020/"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:46
msgid "Indentation and Formatting"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:48
msgid "4 spaces instead tabs. PIL suggests using of two spaces, but programmer looks at code 4 up to 8 hours a day, so it's simplier to distinguish indentation with 4 spaces. Why spaces? Similar representation everywhere."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:52
msgid "You can use vim modelines:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:54
msgid "-- vim:ts=4 ss=4 sw=4 expandtab"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:58
msgid "A file should ends w/ one newline symbol, but shouldn't ends w/ blank line (two newline symbols)."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:61
msgid "Every do/while/for/if/function should indent 4 spaces."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:63
msgid "related ``or``/``and`` in ``if`` must be enclosed in the round brackets (). Example:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:65
msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    <...>\n"
"end -- good\n"
"\n"
"if a == true and b == false or a == false and b == true then\n"
"    <...>\n"
"end -- bad\n"
"\n"
"if a ^ b == true then\n"
"end -- good, but not explicit"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:78
msgid "Type conversion"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:80
msgid "Do not use concatenation to convert to string or addition to convert to number (use ``tostring``/``tonumber`` instead):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:83
msgid ""
"local a = 123\n"
"a = a .. ''\n"
"-- bad\n"
"\n"
"local a = 123\n"
"a = tostring(a)\n"
"-- good\n"
"\n"
"local a = '123'\n"
"a = a + 5 -- 128\n"
"-- bad\n"
"\n"
"local a = '123'\n"
"a = tonumber(a) + 5 -- 128\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:101
msgid "Try to avoid multiple nested ``if``'s with common body:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:103
msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    do_something()\n"
"end\n"
"-- good\n"
"\n"
"if a == true then\n"
"    if b == false then\n"
"        do_something()\n"
"    end\n"
"if b == true then\n"
"    if a == false then\n"
"        do_something()\n"
"    end\n"
"end\n"
"-- bad"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:121
msgid "Avoid multiple concatenations in one statement, use ``string.format`` instead:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:123
#, python-format
msgid ""
"function say_greeting(period, name)\n"
"    local a = \"good  \" .. period .. \", \" .. name\n"
"end\n"
"-- bad\n"
"\n"
"function say_greeting(period, name)\n"
"    local a = string.format(\"good %s, %s\", period, name)\n"
"end\n"
"-- good\n"
"\n"
"local say_greeting_fmt = \"good %s, %s\"\n"
"function say_greeting(period, name)\n"
"    local a = say_greeting_fmt:format(period, name)\n"
"end\n"
"-- best"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:141
msgid "Use ``and``/``or`` for default variable values"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:143
msgid ""
"function(input)\n"
"    input = input or 'default_value'\n"
"end -- good\n"
"\n"
"function(input)\n"
"    if input == nil then\n"
"        input = 'default_value'\n"
"    end\n"
"end -- ok, but excessive"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:155
msgid "``if``'s and return statements:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:157
msgid ""
"if a == true then\n"
"    return do_something()\n"
"end\n"
"do_other_thing() -- good\n"
"\n"
"if a == true then\n"
"    return do_something()\n"
"else\n"
"    do_other_thing()\n"
"end -- bad"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:170
msgid "Using spaces:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:172
msgid "one shouldn't use spaces between function name and opening round bracket, but arguments must be splitted with one whitespace charachter"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:175
msgid ""
"function name (arg1,arg2,...)\n"
"end -- bad\n"
"\n"
"function name(arg1, arg2, ...)\n"
"end -- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:183
msgid "use space after comment marker"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:185
msgid ""
"while true do -- inline comment\n"
"-- comment\n"
"do_something()\n"
"end\n"
"--[[\n"
"  multiline\n"
"  comment\n"
"]]--"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:196
msgid "surrounding operators"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:198
msgid ""
"local thing=1\n"
"thing = thing-1\n"
"thing = thing*1\n"
"thing = 'string'..'s'\n"
"-- bad\n"
"\n"
"local thing = 1\n"
"thing = thing - 1\n"
"thing = thing * 1\n"
"thing = 'string' .. 's'\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:212
msgid "use space after commas in tables"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:214
msgid ""
"local thing = {1,2,3}\n"
"thing = {1 , 2 , 3}\n"
"thing = {1 ,2 ,3}\n"
"-- bad\n"
"\n"
"local thing = {1, 2, 3}\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:224
msgid "use space in map definitions around equality sign and commas"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:226
msgid ""
"return {1,2,3,4} -- bad\n"
"return {\n"
"    key1 = val1,key2=val2\n"
"} -- bad\n"
"\n"
"return {\n"
"    1, 2, 3, 4\n"
"    key1 = val1, key2 = val2,\n"
"    key3 = vallll\n"
"} -- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:239
msgid "also, you may use alignment:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:241
msgid ""
"return {\n"
"    long_key  = 'vaaaaalue',\n"
"    key       = 'val',\n"
"    something = 'even better'\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:249
msgid "extra blank lines may be used (sparingly) to separate groups of related functions. Blank lines may be omitted between a bunch of related one-liners (e.g. a set of dummy implementations)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:253
msgid "use blank lines in function, sparingly, to indicate logical sections"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:255
msgid ""
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"local wat = 7\n"
"-- bad\n"
"\n"
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"local wat = 7\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:277
msgid "Delete whitespace at EOL (strongly forbidden. Use ``:s/\\s\\+$//gc`` in vim to delete them)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:282
msgid "Avoid global variable"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:284
msgid "You must avoid global variables. If you have an exceptional case, use ``_G`` variable to set it, add prefix or add table instead of prefix:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:287
msgid ""
"function bad_global_example()\n"
"end -- very, very bad\n"
"\n"
"function good_local_example()\n"
"end\n"
"_G.modulename_good_local_example = good_local_example -- good\n"
"_G.modulename = {}\n"
"_G.modulename.good_local_example = good_local_example -- better"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:298
msgid "Always use prefix to avoid name clash"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:302
msgid "Naming"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:304
msgid "names of variables/\"objects\" and \"methods\"/functions: snake_case"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:305
msgid "names of \"classes\": CamelCase"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:306
msgid "private variables/methods (properties in the future) of object starts with underscores ``<object>._<name>``. Avoid using of ``local function private_methods(self) end``"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:309
msgid "boolean - naming ``is_<...>``, ``isnt_<...>``, ``has_``, ``hasnt_`` is a good style."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:310
msgid "for \"very local\" variables: - ``t`` is for tables - ``i``, ``j`` are for indexing - ``n`` is for counting - ``k``, ``v`` is what you get out of ``pairs()`` (are acceptable, ``_`` if unused) - ``i``, ``v`` is what you get out of ``ipairs()`` (are acceptable, ``_`` if unused) - ``k``/``key`` is for table keys - ``v``/``val``/``value`` is for values that are passed around - ``x``/``y``/``z`` is for generic math quantities - ``s``/``str``/``string`` is for strings - ``c`` is for 1-char strings - ``f``/``func``/``cb`` are for functions - ``status, <rv>..`` or ``ok, <rv>..`` is what you get out of pcall/xpcall - ``buf, sz`` is a (buffer, size) pair - ``<name>_p`` is for pointers - ``t0``.. is for timestamps - ``err`` is for errors"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:327
msgid "abbrevations are acceptable if they're unambigous and if you'll document (or they're too common) them."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:329
msgid "global variables are written with ALL_CAPS. If it's some system variable, then they're using underscore to define it (``_G``/``_VERSION``/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:331
msgid "module naming snake_case (avoid underscores and dashes) - 'luasql', instead of 'Lua-SQL'"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:333
msgid "``*_mt`` and ``*_methods`` defines metatable and methods table"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:337
msgid "Idioms and patterns"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:339
msgid "Always use round brackets in call of functions except multiple cases (common lua style idioms):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:342
msgid "``*.cfg{ }`` functions (``box.cfg``/``memcached.cfg``/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:343
msgid "``ffi.cdef[[ ]]`` function"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:345
msgid "Avoid these kind of constructions:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:347
msgid "<func>'<name>' (strongly avoid require'..')"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:348
msgid "``function object:method() end`` (use ``functon object.method(self) end`` instead)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:349
msgid "do not use semicolon as table separator (only comma)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:350
msgid "semicolons at the end of line (only to split multiple statements on one line)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:351
msgid "try to avoid unnecessary function creation (closures/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:355
msgid "Modules"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:357
msgid "Don't start modules with license/authors/descriptions, you can write it in LICENSE/AUTHORS/README files. For writing modules use one of the two patterns (dont use ``modules()``):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:361
msgid ""
"local M = {}\n"
"\n"
"function M.foo()\n"
"...\n"
"end\n"
"\n"
"function M.bar()\n"
"...\n"
"end\n"
"\n"
"return M"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:377
msgid ""
"local function foo()\n"
"...\n"
"end\n"
"\n"
"local function bar()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"foo = foo,\n"
"bar = bar,\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:394
msgid "Commenting"
msgstr "Комментирование"

#: ../doc/1.7/dev_guide/lua_style_guide.rst:396
msgid "You should write code the way it shouldn't be described, but don't forget about commenting it. You shouldn't comment Lua syntax (assume that reader already knows Lua language). Try to tell about functions/variable names/etc."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:400
msgid "Multiline comments: use matching (``--[[ ]]--``) instead of simple (``--[[ ]]``)."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:403
msgid "Public function comments (??):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:405
msgid ""
"--- Copy any table (shallow and deep version)\n"
"-- * deepcopy: copies all levels\n"
"-- * shallowcopy: copies only first level\n"
"-- Supports __copy metamethod for copying custom tables with metatables\n"
"-- @function gsplit\n"
"-- @table         inp  original table\n"
"-- @shallow[opt]  sep  flag for shallow copy\n"
"-- @returns            table (copy)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:418
msgid "Testing"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:420
msgid "Use ``tap`` module for writing efficient tests. Example of test file:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:422
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local test = require('tap').test('table')\n"
"test:plan(31)\n"
"\n"
"do -- check basic table.copy (deepcopy)\n"
"    local example_table = {\n"
"        {1, 2, 3},\n"
"        {\"help, I'm very nested\", {{{ }}} }\n"
"    }\n"
"\n"
"    local copy_table = table.copy(example_table)\n"
"\n"
"    test:is_deeply(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that deepcopy behaves ok\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[1],\n"
"        copy_table[1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2],\n"
"        copy_table[2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2],\n"
"        copy_table[2][2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2][1],\n"
"        copy_table[2][2][1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"end\n"
"\n"
"<...>\n"
"\n"
"os.exit(test:check() == true and 0 or 1)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:473
msgid "When you'll test your code output will be something like this:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:475
msgid ""
"TAP version 13\n"
"1..31\n"
"ok - checking, that deepcopy behaves ok\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:489
msgid "Error Handling"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:491
msgid "Be generous in what you accept and strict in what you return."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:493
msgid "With error handling this means that you must provide an error object as second multi-return value in case of error. The error object can be a string, a Lua table or cdata, in the latter cases it must have ``__tostring`` metamethod defined."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:498
msgid "In case of error, use ``nil`` for the first return value. This makes the error hard to ignore."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:501
msgid "When checking function return values, check the first argument first. If it's ``nil``, look for error in the second argument:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:504
msgid ""
"local data, err = foo()\n"
"if not data\n"
"    return nil, err\n"
"end\n"
"return bar(data)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:512
msgid "Unless performance of your code is paramount, try to avoid using more than two return values."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:515
msgid "In rare cases you may want to return ``nil`` as a legal return value. In this case it's OK to check for error first, and return second:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:518
msgid ""
"local data, err = foo()\n"
"if not err\n"
"    return data\n"
"end\n"
"return nil, err"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:3
msgid "Python Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:7
msgid "Introduction"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:9
msgid "This document gives coding conventions for the Python code comprising the standard library in the main Python distribution.  Please see the companion informational PEP describing style guidelines for the C code in the C implementation of Python [1]_."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:14
msgid "This document and PEP 257 (Docstring Conventions) were adapted from Guido's original Python Style Guide essay, with some additions from Barry's style guide [2]_."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:21
msgid "A Foolish Consistency is the Hobgoblin of Little Minds"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:23
msgid "One of Guido's key insights is that code is read much more often than it is written.  The guidelines provided here are intended to improve the readability of code and make it consistent across the wide spectrum of Python code.  As PEP 20 says, \"Readability counts\"."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:28
msgid "A style guide is about consistency.  Consistency with this style guide is important.  Consistency within a project is more important. Consistency within one module or function is the most important."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:32
msgid "But most importantly: know when to be inconsistent -- sometimes the style guide just doesn't apply.  When in doubt, use your best judgment.  Look at other examples and decide what looks best.  And don't hesitate to ask!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:37
msgid "Two good reasons to break a particular rule:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:39
msgid "When applying the rule would make the code less readable, even for someone who is used to reading code that follows the rules."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:42
msgid "To be consistent with surrounding code that also breaks it (maybe for historic reasons) -- although this is also an opportunity to clean up someone else's mess (in true XP style)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:49
msgid "Code lay-out"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:53
msgid "Indentation"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:55
msgid "Use 4 spaces per indentation level."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:57
msgid "For really old code that you don't want to mess up, you can continue to use 8-space tabs."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:60
msgid "Continuation lines should align wrapped elements either vertically using Python's implicit line joining inside parentheses, brackets and braces, or using a hanging indent.  When using a hanging indent the following considerations should be applied; there should be no arguments on the first line and further indentation should be used to clearly distinguish itself as a continuation line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:67
#: ../doc/1.7/dev_guide/python_style_guide.rst:324
#: ../doc/1.7/dev_guide/python_style_guide.rst:353
#: ../doc/1.7/dev_guide/python_style_guide.rst:372
#: ../doc/1.7/dev_guide/python_style_guide.rst:385
msgid "Yes::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:103
msgid ""
"# Aligned with opening delimiter\n"
"foo = long_function_name(var_one, var_two,\n"
"                         var_three, var_four)\n"
"\n"
"# More indentation included to distinguish this from the rest.\n"
"def long_function_name(\n"
"        var_one, var_two, var_three,\n"
"        var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:79
#: ../doc/1.7/dev_guide/python_style_guide.rst:330
#: ../doc/1.7/dev_guide/python_style_guide.rst:361
#: ../doc/1.7/dev_guide/python_style_guide.rst:377
msgid "No::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:115
msgid ""
"# Arguments on first line forbidden when not using vertical alignment\n"
"foo = long_function_name(var_one, var_two,\n"
"    var_three, var_four)\n"
"\n"
"# Further indentation required as indentation is not distinguishable\n"
"def long_function_name(\n"
"    var_one, var_two, var_three,\n"
"    var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:91
msgid "Optional::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:127
msgid ""
"# Extra indentation is not necessary.\n"
"foo = long_function_name(\n"
"  var_one, var_two,\n"
"  var_three, var_four)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:98
msgid "The closing brace/bracket/parenthesis on multi-line constructs may either line up under the first non-whitespace character of the last line of list, as in::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:136
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"    ]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
"    )"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:111
msgid "or it may be lined up under the first character of the line that starts the multi-line construct, as in::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:148
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
")"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:126
msgid "Tabs or Spaces?"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:128
msgid "Never mix tabs and spaces."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:130
msgid "The most popular way of indenting Python is with spaces only.  The second-most popular way is with tabs only.  Code indented with a mixture of tabs and spaces should be converted to using spaces exclusively.  When invoking the Python command line interpreter with the ``-t`` option, it issues warnings about code that illegally mixes tabs and spaces.  When using ``-tt`` these warnings become errors. These options are highly recommended!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:138
msgid "For new projects, spaces-only are strongly recommended over tabs. Most editors have features that make this easy to do."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:143
msgid "Maximum Line Length"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:145
msgid "Limit all lines to a maximum of 79 characters."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:147
msgid "There are still many devices around that are limited to 80 character lines; plus, limiting windows to 80 characters makes it possible to have several windows side-by-side.  The default wrapping on such devices disrupts the visual structure of the code, making it more difficult to understand.  Therefore, please limit all lines to a maximum of 79 characters.  For flowing long blocks of text (docstrings or comments), limiting the length to 72 characters is recommended."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:155
msgid "The preferred way of wrapping long lines is by using Python's implied line continuation inside parentheses, brackets and braces.  Long lines can be broken over multiple lines by wrapping expressions in parentheses. These should be used in preference to using a backslash for line continuation."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:161
msgid "Backslashes may still be appropriate at times.  For example, long, multiple ``with``-statements cannot use implicit continuation, so backslashes are acceptable::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:199
msgid ""
"with open('/path/to/some/file/you/want/to/read') as file_1, \\\n"
"        open('/path/to/some/file/being/written', 'w') as file_2:\n"
"    file_2.write(file_1.read())"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:169
msgid "Another such case is with ``assert`` statements."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:171
msgid "Make sure to indent the continued line appropriately.  The preferred place to break around a binary operator is *after* the operator, not before it.  Some examples::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:209
#, python-format
msgid ""
"class Rectangle(Blob):\n"
"\n"
"    def __init__(self, width, height,\n"
"                 color='black', emphasis=None, highlight=0):\n"
"        if (width == 0 and height == 0 and\n"
"            color == 'red' and emphasis == 'strong' or\n"
"            highlight > 100):\n"
"            raise ValueError(\"sorry, you lose\")\n"
"        if width == 0 and height == 0 and (color == 'red' or\n"
"                                           emphasis is None):\n"
"            raise ValueError(\"I don't think so -- values are %s, %s\" %\n"
"                             (width, height))\n"
"        Blob.__init__(self, width, height,\n"
"                      color, emphasis, highlight)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:192
msgid "Blank Lines"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:194
msgid "Separate top-level function and class definitions with two blank lines."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:197
msgid "Method definitions inside a class are separated by a single blank line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:200
msgid "Extra blank lines may be used (sparingly) to separate groups of related functions.  Blank lines may be omitted between a bunch of related one-liners (e.g. a set of dummy implementations)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:204
msgid "Use blank lines in functions, sparingly, to indicate logical sections."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:206
msgid "Python accepts the control-L (i.e. ^L) form feed character as whitespace; Many tools treat these characters as page separators, so you may use them to separate pages of related sections of your file. Note, some editors and web-based code viewers may not recognize control-L as a form feed and will show another glyph in its place."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:214
msgid "Encodings (PEP 263)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:216
msgid "Code in the core Python distribution should always use the ASCII or Latin-1 encoding (a.k.a. ISO-8859-1).  For Python 3.0 and beyond, UTF-8 is preferred over Latin-1, see PEP 3120."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:220
msgid "Files using ASCII should not have a coding cookie.  Latin-1 (or UTF-8) should only be used when a comment or docstring needs to mention an author name that requires Latin-1; otherwise, using ``\\x``, ``\\u`` or ``\\U`` escapes is the preferred way to include non-ASCII data in string literals."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:226
msgid "For Python 3.0 and beyond, the following policy is prescribed for the standard library (see PEP 3131): All identifiers in the Python standard library MUST use ASCII-only identifiers, and SHOULD use English words wherever feasible (in many cases, abbreviations and technical terms are used which aren't English). In addition, string literals and comments must also be in ASCII. The only exceptions are (a) test cases testing the non-ASCII features, and (b) names of authors. Authors whose names are not based on the latin alphabet MUST provide a latin transliteration of their names."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:237
msgid "Open source projects with a global audience are encouraged to adopt a similar policy."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:243
msgid "Imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:245
msgid "Imports should usually be on separate lines, e.g.::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:281
msgid ""
"Yes: import os\n"
"     import sys\n"
"\n"
"No:  import sys, os"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:252
msgid "It's okay to say this though::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:288
msgid "from subprocess import Popen, PIPE"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:256
msgid "Imports are always put at the top of the file, just after any module comments and docstrings, and before module globals and constants."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:259
msgid "Imports should be grouped in the following order:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:261
msgid "standard library imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:262
msgid "related third party imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:263
msgid "local application/library specific imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:265
msgid "You should put a blank line between each group of imports."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:267
msgid "Put any relevant ``__all__`` specification after the imports."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:269
msgid "Relative imports for intra-package imports are highly discouraged. Always use the absolute package path for all imports.  Even now that PEP 328 is fully implemented in Python 2.5, its style of explicit relative imports is actively discouraged; absolute imports are more portable and usually more readable."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:275
msgid "When importing a class from a class-containing module, it's usually okay to spell this::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:312
msgid ""
"from myclass import MyClass\n"
"from foo.bar.yourclass import YourClass"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:281
msgid "If this spelling causes local name clashes, then spell them ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:317
msgid ""
"import myclass\n"
"import foo.bar.yourclass"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:286
msgid "and use \"myclass.MyClass\" and \"foo.bar.yourclass.YourClass\"."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:291
msgid "Whitespace in Expressions and Statements"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:295
msgid "Pet Peeves"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:297
msgid "Avoid extraneous whitespace in the following situations:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:299
msgid "Immediately inside parentheses, brackets or braces. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:335
msgid ""
"Yes: spam(ham[1], {eggs: 2})\n"
"No:  spam( ham[ 1 ], { eggs: 2 } )"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:304
msgid "Immediately before a comma, semicolon, or colon::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:340
msgid ""
"Yes: if x == 4: print x, y; x, y = y, x\n"
"No:  if x == 4 : print x , y ; x , y = y , x"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:309
msgid "Immediately before the open parenthesis that starts the argument list of a function call::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:346
msgid ""
"Yes: spam(1)\n"
"No:  spam (1)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:315
msgid "Immediately before the open parenthesis that starts an indexing or slicing::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:352
msgid ""
"Yes: dict['key'] = list[index]\n"
"No:  dict ['key'] = list [index]"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:321
msgid "More than one space around an assignment (or other) operator to align it with another."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:360
msgid ""
"x = 1\n"
"y = 2\n"
"long_variable = 3"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:366
msgid ""
"x             = 1\n"
"y             = 2\n"
"long_variable = 3"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:339
msgid "Other Recommendations"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:341
msgid "Always surround these binary operators with a single space on either side: assignment (``=``), augmented assignment (``+=``, ``-=`` etc.), comparisons (``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``, ``>=``, ``in``, ``not in``, ``is``, ``is not``), Booleans (``and``, ``or``, ``not``)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:347
msgid "If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies). Use your own judgement; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:389
msgid ""
"i = i + 1\n"
"submitted += 1\n"
"x = x*2 - 1\n"
"hypot2 = x*x + y*y\n"
"c = (a+b) * (a-b)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:397
msgid ""
"i=i+1\n"
"submitted +=1\n"
"x = x * 2 - 1\n"
"hypot2 = x * x + y * y\n"
"c = (a + b) * (a - b)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:369
msgid "Don't use spaces around the ``=`` sign when used to indicate a keyword argument or a default parameter value."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:408
msgid ""
"def complex(real, imag=0.0):\n"
"    return magic(r=real, i=imag)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:413
msgid ""
"def complex(real, imag = 0.0):\n"
"    return magic(r = real, i = imag)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:382
msgid "Compound statements (multiple statements on the same line) are generally discouraged."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:421
msgid ""
"if foo == 'blah':\n"
"    do_blah_thing()\n"
"do_one()\n"
"do_two()\n"
"do_three()"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:393
#: ../doc/1.7/dev_guide/python_style_guide.rst:402
msgid "Rather not::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:429
msgid ""
"if foo == 'blah': do_blah_thing()\n"
"do_one(); do_two(); do_three()"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:398
msgid "While sometimes it's okay to put an if/for/while with a small body on the same line, never do this for multi-clause statements.  Also avoid folding such long lines!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:438
msgid ""
"if foo == 'blah': do_blah_thing()\n"
"for x in lst: total += x\n"
"while t < 10: t = delay()"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:408
msgid "Definitely not::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:444
msgid ""
"if foo == 'blah': do_blah_thing()\n"
"else: do_non_blah_thing()\n"
"\n"
"try: something()\n"
"finally: cleanup()\n"
"\n"
"do_one(); do_two(); do_three(long, argument,\n"
"                             list, like, this)\n"
"\n"
"if foo == 'blah': one(); two(); three()"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:423
msgid "Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:425
msgid "Comments that contradict the code are worse than no comments.  Always make a priority of keeping the comments up-to-date when the code changes!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:429
msgid "Comments should be complete sentences.  If a comment is a phrase or sentence, its first word should be capitalized, unless it is an identifier that begins with a lower case letter (never alter the case of identifiers!)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:434
msgid "If a comment is short, the period at the end can be omitted.  Block comments generally consist of one or more paragraphs built out of complete sentences, and each sentence should end in a period."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:438
msgid "You should use two spaces after a sentence-ending period."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:440
msgid "When writing English, Strunk and White apply."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:442
#, python-format
msgid "Python coders from non-English speaking countries: please write your comments in English, unless you are 120% sure that the code will never be read by people who don't speak your language."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:448
msgid "Block Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:450
msgid "Block comments generally apply to some (or all) code that follows them, and are indented to the same level as that code.  Each line of a block comment starts with a ``#`` and a single space (unless it is indented text inside the comment)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:455
msgid "Paragraphs inside a block comment are separated by a line containing a single ``#``."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:460
msgid "Inline Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:462
msgid "Use inline comments sparingly."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:464
msgid "An inline comment is a comment on the same line as a statement. Inline comments should be separated by at least two spaces from the statement.  They should start with a # and a single space."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:468
msgid "Inline comments are unnecessary and in fact distracting if they state the obvious.  Don't do this::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:505
msgid "x = x + 1                 # Increment x"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:473
msgid "But sometimes, this is useful::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:509
msgid "x = x + 1                 # Compensate for border"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:479
msgid "Documentation Strings"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:481
msgid "Conventions for writing good documentation strings (a.k.a. \"docstrings\") are immortalized in PEP 257."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:484
msgid "Write docstrings for all public modules, functions, classes, and methods.  Docstrings are not necessary for non-public methods, but you should have a comment that describes what the method does.  This comment should appear after the ``def`` line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:489
msgid "PEP 257 describes good docstring conventions.  Note that most importantly, the ``\"\"\"`` that ends a multiline docstring should be on a line by itself, and preferably preceded by a blank line, e.g.::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:527
msgid ""
"\"\"\"Return a foobang\n"
"\n"
"Optional plotz says to frobnicate the bizbaz first.\n"
"\n"
"\"\"\""
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:499
msgid "For one liner docstrings, it's okay to keep the closing ``\"\"\"`` on the same line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:505
msgid "Version Bookkeeping"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:507
msgid "If you have to have Subversion, CVS, or RCS crud in your source file, do it as follows. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:544
msgid ""
"__version__ = \"$Revision$\"\n"
"# $Source$"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:513
msgid "These lines should be included after the module's docstring, before any other code, separated by a blank line above and below."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:519
msgid "Naming Conventions"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:521
msgid "The naming conventions of Python's library are a bit of a mess, so we'll never get this completely consistent -- nevertheless, here are the currently recommended naming standards.  New modules and packages (including third party frameworks) should be written to these standards, but where an existing library has a different style, internal consistency is preferred."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:530
msgid "Descriptive: Naming Styles"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:532
msgid "There are a lot of different naming styles.  It helps to be able to recognize what naming style is being used, independently from what they are used for."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:536
msgid "The following naming styles are commonly distinguished:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:538
msgid "``b`` (single lowercase letter)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:539
msgid "``B`` (single uppercase letter)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:540
msgid "``lowercase``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:541
msgid "``lower_case_with_underscores``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:542
msgid "``UPPERCASE``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:543
msgid "``UPPER_CASE_WITH_UNDERSCORES``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:544
msgid "``CapitalizedWords`` (or CapWords, or CamelCase -- so named because of the bumpy look of its letters [3]_).  This is also sometimes known as StudlyCaps."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:548
msgid "Note: When using abbreviations in CapWords, capitalize all the letters of the abbreviation.  Thus HTTPServerError is better than HttpServerError."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:551
msgid "``mixedCase`` (differs from CapitalizedWords by initial lowercase character!)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:553
msgid "``Capitalized_Words_With_Underscores`` (ugly!)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:555
msgid "There's also the style of using a short unique prefix to group related names together.  This is not used much in Python, but it is mentioned for completeness.  For example, the ``os.stat()`` function returns a tuple whose items traditionally have names like ``st_mode``, ``st_size``, ``st_mtime`` and so on.  (This is done to emphasize the correspondence with the fields of the POSIX system call struct, which helps programmers familiar with that.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:563
msgid "The X11 library uses a leading X for all its public functions.  In Python, this style is generally deemed unnecessary because attribute and method names are prefixed with an object, and function names are prefixed with a module name."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:568
msgid "In addition, the following special forms using leading or trailing underscores are recognized (these can generally be combined with any case convention):"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:572
msgid "``_single_leading_underscore``: weak \"internal use\" indicator. E.g. ``from M import *`` does not import objects whose name starts with an underscore."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:576
msgid "``single_trailing_underscore_``: used by convention to avoid conflicts with Python keyword, e.g. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:613
msgid "Tkinter.Toplevel(master, class_='ClassName')"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:581
msgid "``__double_leading_underscore``: when naming a class attribute, invokes name mangling (inside class FooBar, ``__boo`` becomes ``_FooBar__boo``; see below)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:585
msgid "``__double_leading_and_trailing_underscore__``: \"magic\" objects or attributes that live in user-controlled namespaces. E.g. ``__init__``, ``__import__`` or ``__file__``.  Never invent such names; only use them as documented."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:592
msgid "Prescriptive: Naming Conventions"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:596
msgid "Names to Avoid"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:598
msgid "Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) as single character variable names."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:602
msgid "In some fonts, these characters are indistinguishable from the numerals one and zero.  When tempted to use 'l', use 'L' instead."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:607
msgid "Package and Module Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:609
msgid "Modules should have short, all-lowercase names.  Underscores can be used in the module name if it improves readability.  Python packages should also have short, all-lowercase names, although the use of underscores is discouraged."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:614
msgid "Since module names are mapped to file names, and some file systems are case insensitive and truncate long names, it is important that module names be chosen to be fairly short -- this won't be a problem on Unix, but it may be a problem when the code is transported to older Mac or Windows versions, or DOS."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:620
msgid "When an extension module written in C or C++ has an accompanying Python module that provides a higher level (e.g. more object oriented) interface, the C/C++ module has a leading underscore (e.g. ``_socket``)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:627
msgid "Class Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:629
msgid "Almost without exception, class names use the CapWords convention. Classes for internal use have a leading underscore in addition."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:634
msgid "Exception Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:636
msgid "Because exceptions should be classes, the class naming convention applies here.  However, you should use the suffix \"Error\" on your exception names (if the exception actually is an error)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:642
msgid "Global Variable Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:644
msgid "(Let's hope that these variables are meant for use inside one module only.)  The conventions are about the same as those for functions."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:647
msgid "Modules that are designed for use via ``from M import *`` should use the ``__all__`` mechanism to prevent exporting globals, or use the older convention of prefixing such globals with an underscore (which you might want to do to indicate these globals are \"module non-public\")."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:655
msgid "Function Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:657
msgid "Function names should be lowercase, with words separated by underscores as necessary to improve readability."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:660
msgid "mixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:666
msgid "Function and method arguments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:668
msgid "Always use ``self`` for the first argument to instance methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:670
msgid "Always use ``cls`` for the first argument to class methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:672
msgid "If a function argument's name clashes with a reserved keyword, it is generally better to append a single trailing underscore rather than use an abbreviation or spelling corruption.  Thus ``class_`` is better than ``clss``.  (Perhaps better is to avoid such clashes by using a synonym.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:680
msgid "Method Names and Instance Variables"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:682
msgid "Use the function naming rules: lowercase with words separated by underscores as necessary to improve readability."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:685
msgid "Use one leading underscore only for non-public methods and instance variables."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:688
msgid "To avoid name clashes with subclasses, use two leading underscores to invoke Python's name mangling rules."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:691
msgid "Python mangles these names with the class name: if class Foo has an attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An insistent user could still gain access by calling ``Foo._Foo__a``.) Generally, double leading underscores should be used only to avoid name conflicts with attributes in classes designed to be subclassed."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:697
msgid "Note: there is some controversy about the use of __names (see below)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:701
msgid "Constants"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:703
msgid "Constants are usually defined on a module level and written in all capital letters with underscores separating words.  Examples include ``MAX_OVERFLOW`` and ``TOTAL``."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:709
msgid "Designing for inheritance"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:711
msgid "Always decide whether a class's methods and instance variables (collectively: \"attributes\") should be public or non-public.  If in doubt, choose non-public; it's easier to make it public later than to make a public attribute non-public."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:716
msgid "Public attributes are those that you expect unrelated clients of your class to use, with your commitment to avoid backward incompatible changes.  Non-public attributes are those that are not intended to be used by third parties; you make no guarantees that non-public attributes won't change or even be removed."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:722
msgid "We don't use the term \"private\" here, since no attribute is really private in Python (without a generally unnecessary amount of work)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:725
msgid "Another category of attributes are those that are part of the \"subclass API\" (often called \"protected\" in other languages).  Some classes are designed to be inherited from, either to extend or modify aspects of the class's behavior.  When designing such a class, take care to make explicit decisions about which attributes are public, which are part of the subclass API, and which are truly only to be used by your base class."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:733
msgid "With this in mind, here are the Pythonic guidelines:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:735
msgid "Public attributes should have no leading underscores."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:737
msgid "If your public attribute name collides with a reserved keyword, append a single trailing underscore to your attribute name.  This is preferable to an abbreviation or corrupted spelling.  (However, not withstanding this rule, 'cls' is the preferred spelling for any variable or argument which is known to be a class, especially the first argument to a class method.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:745
#: ../doc/1.7/dev_guide/python_style_guide.rst:756
#: ../doc/1.7/dev_guide/python_style_guide.rst:778
msgid "Note 1:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:745
msgid "See the argument name recommendation above for class methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:747
msgid "For simple public data attributes, it is best to expose just the attribute name, without complicated accessor/mutator methods.  Keep in mind that Python provides an easy path to future enhancement, should you find that a simple data attribute needs to grow functional behavior.  In that case, use properties to hide functional implementation behind simple data attribute access syntax."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:756
msgid "Properties only work on new-style classes."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:760
#: ../doc/1.7/dev_guide/python_style_guide.rst:783
msgid "Note 2:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:759
msgid "Try to keep the functional behavior side-effect free, although side-effects such as caching are generally fine."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:765
#: ../doc/1.7/dev_guide/python_style_guide.rst:788
msgid "Note 3:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:763
msgid "Avoid using properties for computationally expensive operations; the attribute notation makes the caller believe that access is (relatively) cheap."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:767
msgid "If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores.  This invokes Python's name mangling algorithm, where the name of the class is mangled into the attribute name.  This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:776
msgid "Note that only the simple class name is used in the mangled name, so if a subclass chooses both the same class name and attribute name, you can still get name collisions."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:781
msgid "Name mangling can make certain uses, such as debugging and ``__getattr__()``, less convenient.  However the name mangling algorithm is well documented and easy to perform manually."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:786
msgid "Not everyone likes name mangling.  Try to balance the need to avoid accidental name clashes with potential use by advanced callers."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:792
msgid "References"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:794
msgid "`PEP 7, Style Guide for C Code, van Rossum <https://www.python.org/dev/peps/pep-0007/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:795
msgid "`Barry's GNU Mailman style guide <http://barry.warsaw.us/software/STYLEGUIDE.txt>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:796
msgid "`CamelCase Wikipedia page <http://www.wikipedia.com/wiki/CamelCase>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:800
msgid "Copyright"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:802
msgid "Author:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:804
msgid "Guido van Rossum <guido@python.org>"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:805
msgid "Barry Warsaw <barry@python.org>"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:3
#: ../doc/1.7/reference/reference_lua/box.rst:5
msgid "Module `box`"
msgstr "Модуль `box`"

#: ../doc/1.7/dev_guide/reference_capi/box.rst:7
msgid "Opaque structure passed to a C stored procedure"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:13
msgid "Return a tuple from a C stored procedure."
msgstr "Возвращает кортеж с помощью хранимой процедуры на языке C."

#: ../doc/1.7/dev_guide/reference_capi/box.rst:15
msgid "The returned tuple is automatically reference-counted by Tarantool. An example program that uses ``box_return_tuple()`` is :ref:`write.c <f_c_tutorial-write>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:19
msgid "an opaque structure passed to the C stored procedure by Tarantool"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:21
msgid "a tuple to return"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst
#: ../doc/1.7/dev_guide/reference_capi/coio.rst
#: ../doc/1.7/dev_guide/reference_capi/error.rst
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst
#: ../doc/1.7/dev_guide/reference_capi/latch.rst
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst
#: ../doc/1.7/dev_guide/reference_capi/txn.rst
#: ../doc/1.7/dev_guide/reference_capi/utils.rst
msgid "Returns"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:23
msgid "-1 on error (perhaps, out of memory; check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:25
#: ../doc/1.7/dev_guide/reference_capi/box.rst:73
#: ../doc/1.7/dev_guide/reference_capi/box.rst:90
#: ../doc/1.7/dev_guide/reference_capi/box.rst:106
#: ../doc/1.7/dev_guide/reference_capi/box.rst:127
#: ../doc/1.7/dev_guide/reference_capi/box.rst:148
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:64
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:77
msgid "0 otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:31
msgid "Find space id by name."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:33
msgid "This function performs a SELECT request on the ``_vspace`` system space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:35
msgid "space name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:36
#: ../doc/1.7/dev_guide/reference_capi/box.rst:52
msgid "length of ``name``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:38
#: ../doc/1.7/dev_guide/reference_capi/box.rst:54
msgid ":c:macro:`BOX_ID_NIL` on error or if not found (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:40
#: ../doc/1.7/dev_guide/reference_capi/box.rst:56
msgid "space_id otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:42
msgid "See also: :c:type:`box_index_id_by_name`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:46
msgid "Find index id by name."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:48
msgid "This function performs a SELECT request on the ``_vindex`` system space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:50
#: ../doc/1.7/dev_guide/reference_capi/box.rst:66
#: ../doc/1.7/dev_guide/reference_capi/box.rst:83
#: ../doc/1.7/dev_guide/reference_capi/box.rst:98
#: ../doc/1.7/dev_guide/reference_capi/box.rst:114
#: ../doc/1.7/dev_guide/reference_capi/box.rst:135
#: ../doc/1.7/dev_guide/reference_capi/box.rst:156
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:85
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:129
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:139
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:149
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:168
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:184
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:200
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:216
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:234
msgid "space identifier"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:51
msgid "index name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:58
msgid "See also: :c:type:`box_space_id_by_name`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:64
msgid "Execute an INSERT/REPLACE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:67
#: ../doc/1.7/dev_guide/reference_capi/box.rst:84
#: ../doc/1.7/dev_guide/reference_capi/box.rst:137
msgid "encoded tuple in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:68
#: ../doc/1.7/dev_guide/reference_capi/box.rst:85
#: ../doc/1.7/dev_guide/reference_capi/box.rst:138
msgid "end of a ``tuple``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:69
#: ../doc/1.7/dev_guide/reference_capi/box.rst:86
msgid "output argument. Resulting tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:72
#: ../doc/1.7/dev_guide/reference_capi/box.rst:89
#: ../doc/1.7/dev_guide/reference_capi/box.rst:105
#: ../doc/1.7/dev_guide/reference_capi/box.rst:126
msgid "-1 on error (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:75
msgid "See also :ref:`space_object.insert()<box_space-insert>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:81
msgid "Execute a REPLACE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:92
msgid "See also :ref:`space_object.replace()<box_space-replace>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:96
msgid "Execute a DELETE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:99
#: ../doc/1.7/dev_guide/reference_capi/box.rst:115
#: ../doc/1.7/dev_guide/reference_capi/box.rst:136
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:86
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:130
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:140
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:150
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:169
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:185
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:201
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:217
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:235
msgid "index identifier"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:100
#: ../doc/1.7/dev_guide/reference_capi/box.rst:116
msgid "encoded key in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:101
#: ../doc/1.7/dev_guide/reference_capi/box.rst:117
msgid "end of a ``key``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:102
#: ../doc/1.7/dev_guide/reference_capi/box.rst:123
#: ../doc/1.7/dev_guide/reference_capi/box.rst:144
msgid "output argument. An old tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:108
msgid "See also :ref:`space_object.delete()<box_space-delete>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:112
msgid "Execute an UPDATE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:118
#: ../doc/1.7/dev_guide/reference_capi/box.rst:139
msgid "encoded operations in MsgPack Array format, e.g. ``[[ '=', field_id,  value ], ['!', 2, 'xxx']]``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:120
msgid "end of an ``ops`` section"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:121
#: ../doc/1.7/dev_guide/reference_capi/box.rst:142
msgid "0 if field_ids are zero-based as in C, 1 if field ids are 1-based as in Lua"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:129
msgid "See also :ref:`space_object.update()<box_space-update>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:133
msgid "Execute an UPSERT request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:141
msgid "end of a ``ops``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:147
msgid "-1 on error (check ::ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:150
msgid "See also :ref:`space_object.upsert()<box_space-upsert>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:154
msgid "Truncate a space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:3
msgid "Module `index`"
msgstr "Модуль `index`"

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:7
msgid "A space iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:13
msgid "Controls how to iterate over tuples in an index. Different index types support different iterator types. For example, one can start iteration from a particular value (request key) and then retrieve all tuples where keys are greater or equal (= GE) to this key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:18
msgid "If iterator type is not supported by the selected index type, iterator constructor must fail with ER_UNSUPPORTED. To be selectable for primary key, an index must support at least ITER_EQ and ITER_GE types."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:22
msgid "NULL value of request key corresponds to the first or last key in the index, depending on iteration direction. (first key for GE and GT types, and last key for LE and LT). Therefore, to iterate over all tuples in an index, one can use ITER_GE or ITER_LE iteration types with start key equal to NULL. For ITER_EQ, the key must not be NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:30
msgid "key == x ASC order"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:34
msgid "key == x DESC order"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:38
msgid "all tuples"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:42
msgid "key < x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:46
msgid "key <= x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:50
msgid "key >= x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:54
msgid "key > x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:58
msgid "all bits from x are set in key"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:62
msgid "at least one x's bit is set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:66
msgid "all bits are not set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:70
msgid "key overlaps x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:74
msgid "tuples in distance ascending order from specified point"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:80
msgid "Allocate and initialize iterator for space_id, index_id."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:82
msgid "The returned iterator must be destroyed by :ref:`box_iterator_free<c_api-box_index-box_iterator_free>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:87
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:218
msgid ":ref:`iterator_type<c_api-box_index-iterator_type>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:88
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:170
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:186
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:202
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:219
msgid "encode key in MsgPack Array format ([part1, part2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:89
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:171
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:187
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:203
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:220
msgid "the end of encoded ``key``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:91
msgid "NULL on error (check :ref:`box_error_last <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:92
msgid "iterator otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:94
msgid "See also :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`, :ref:`box_iterator_free<c_api-box_index-box_iterator_free>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:101
msgid "Retrieve the next item from the ``iterator``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:103
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:117
msgid "an iterator returned by :ref:`box_index_iterator <c_api-box_index-box_index_iterator>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:105
msgid "output argument. result a tuple or NULL if there is no more data."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:108
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:132
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:142
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:175
msgid "-1 on error (check :ref:`box_error_last <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:109
msgid "0 on success. The end of data is not an error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:115
msgid "Destroy and deallocate iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:122
msgid "Determine a direction of the given iterator type: -1 for REQ, LT, LE, and +1 for all others."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:127
msgid "Return the number of element in the index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:133
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:143
msgid ">= 0 otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:137
msgid "Return the number of bytes used in memory by the index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:147
msgid "Return a random tuple from the index (useful for statistical analysis)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:151
msgid "random seed"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:152
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:172
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:188
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:204
msgid "output argument. result a tuple or NULL if there is no tuples in space"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:155
msgid "See also: :ref:`index_object.random<box_index-random>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:161
msgid "Get a tuple from index by the key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:163
msgid "Please note that this function works much more faster than :ref:`index_object.select<box_index-select>` or :ref:`box_index_iterator<c_api-box_index-box_index_iterator>` + :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:176
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:192
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:208
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:223
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:172
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:18
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:27
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:65
msgid "0 on success"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:178
msgid "See also: ``index_object.get()``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:182
msgid "Return a first (minimal) tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:191
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:207
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:222
msgid "-1 on error (check :ref:`box_error_last() <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:194
msgid "See also: :ref:`index_object.min()<box_index-min>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:198
msgid "Return a last (maximal) tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:210
msgid "See also: :ref:`index_object.max()<box_index-max>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:214
msgid "Count the number of tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:225
msgid "See also: :ref:`index_object.count()<box_index-count>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:230
msgid "Return :ref:`key definition <capi-tuple_key_def>` for an index"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:232
msgid "Returned object is valid until the next yield."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:237
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:168
msgid "key definition on success"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:238
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:169
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:187
msgid "NULL on error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:240
msgid "See also: :ref:`box_tuple_compare() <capi-tuple_box_tuple_compare>`,"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:241
msgid ":ref:`box_tuple_format_new() <capi-tuple_box_tuple_format_new>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/clock.rst:3
#: ../doc/1.7/reference/reference_lua/clock.rst:5
msgid "Module `clock`"
msgstr "Модуль `clock`"

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:3
msgid "Module `coio`"
msgstr "Модуль `coio`"

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:9
msgid "READ event"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:13
msgid "WRITE event"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:19
msgid "Wait until READ or WRITE event on socket (``fd``). Yields."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:21
#: ../doc/1.7/dev_guide/reference_capi/coio.rst:70
msgid "non-blocking socket file description"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:22
msgid "requested events to wait. Combination of ``COIO_READ | COIO_WRITE`` bit flags."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:24
msgid "timeout in seconds."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:26
msgid "0 - timeout"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:27
msgid ">0 - returned events. Combination of ``TNT_IO_READ | TNT_IO_WRITE`` bit flags."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:33
msgid "Create new eio task with specified function and arguments. Yield and wait until the task is complete or a timeout occurs. This function may use the :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:38
msgid "To avoid double error checking, this function does not throw exceptions. In most cases it is also necessary to check the return value of the called function and perform necessary actions. If func sets errno, the errno is preserved across the call."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:43
msgid "-1 and ``errno`` = ENOMEM if failed to create a task"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:44
msgid "the function return (``errno`` is preserved)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:48
msgid ""
"static ssize_t openfile_cb(va_list ap)\n"
"{\n"
"        const char* filename = va_arg(ap);\n"
"        int flags = va_arg(ap);\n"
"        return open(filename, flags);\n"
"}\n"
"\n"
"if (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)\n"
"    // handle errors.\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:63
msgid "Fiber-friendly version of :manpage:`getaddrinfo(3)`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:67
msgid "Close the ``fd`` and wake any fiber blocked in :ref:`coio_wait() <c_api-coio-coio_wait>` call on this ``fd``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:72
msgid "the result of ``close(fd)``, see :manpage:`close(2)`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:3
msgid "Module `error`"
msgstr "Модуль `error`"

#: ../doc/1.7/dev_guide/reference_capi/error.rst:153
msgid "Error - contains information about error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:157
msgid "Return the error type, e.g. \"ClientError\", \"SocketError\", etc."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:159
#: ../doc/1.7/dev_guide/reference_capi/error.rst:166
#: ../doc/1.7/dev_guide/reference_capi/error.rst:173
msgid "error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:160
#: ../doc/1.7/dev_guide/reference_capi/error.rst:174
msgid "not-null string"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:164
msgid "Return IPROTO error code"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:167
msgid "enum :ref:`box_error_code <capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:171
msgid "Return the error message"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:180
msgid "Get the information about the last API call error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:182
msgid "The Tarantool error handling works most like libc's errno. All API calls return -1 or NULL in the event of error. An internal pointer to box_error_t type is set by API functions to indicate what went wrong. This value is only significant if API call failed (returned -1 or NULL)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:187
msgid "Successful function can also touch the last error in some cases. You don't have to clear the last error before calling API functions. The returned object is valid only until next call to **any** API function."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:191
msgid "You must set the last error using box_error_set() in your stored C procedures if you want to return a custom error message. You can re-throw the last API error to IPROTO client by keeping the current value and returning -1 to Tarantool from your stored procedure."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:196
msgid "last error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:200
msgid "Clear the last error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:204
msgid "Set the last error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:208
msgid "IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:210
#: ../doc/1.7/dev_guide/reference_capi/say.rst:33
#: ../doc/1.7/dev_guide/reference_capi/say.rst:48
msgid "format arguments"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:212
msgid "See also: IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:216
msgid "A backward-compatible API define."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:3
#: ../doc/1.7/reference/reference_lua/fiber.rst:5
msgid "Module `fiber`"
msgstr "Модуль `fiber`"

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:7
msgid "Fiber - contains information about a :ref:`fiber <atomic-threads_fibers_yields>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:11
msgid "Function to run inside a fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:15
msgid "Create a new fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:17
msgid "Takes a fiber from the fiber cache, if it's not empty. Can fail only if there is not enough memory for the fiber structure or fiber stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:20
msgid "The created fiber automatically returns itself to the fiber cache when its \"main\" function completes."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:23
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:39
msgid "string with fiber name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:24
msgid "func for run inside fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:26
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:43
msgid "See also: :ref:`fiber_start()<c_api-fiber-fiber_start>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:30
msgid "Create a new fiber with defined attributes."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:32
msgid "Can fail only if there is not enough memory for the fiber structure or fiber stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:35
msgid "The created fiber automatically returns itself to the fiber cache if has a default stack size when its \"main\" function completes."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:40
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:163
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:169
msgid "fiber attributes container"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:41
msgid "function to run inside the fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:49
msgid "Start execution of created fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:51
msgid "fiber to start"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:52
msgid "arguments to start the fiber with"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:56
msgid "Return control to another fiber and wait until it'll be woken."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:58
msgid "See also: :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:64
msgid "Interrupt a synchronous wait of a fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:66
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:104
msgid "fiber to be woken up"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:72
msgid "Cancel the subject fiber (set ``FIBER_IS_CANCELLED`` flag)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:74
msgid "If target fiber's flag ``FIBER_IS_CANCELLABLE`` set, then it would be woken up (maybe prematurely). Then current fiber yields until the target fiber is dead (or is woken up by :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:78
msgid "fiber to be cancelled"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:82
msgid "Make it possible or not possible to wakeup the current fiber immediately when it's cancelled."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:85
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:96
msgid "fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:86
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:97
msgid "status to set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:88
msgid "previous state"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:94
msgid "Set fiber to be joinable (``false`` by default)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:101
msgid "Wait until the fiber is dead and then move its execution status to the caller. The fiber must not be detached."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:106
msgid "Before: ``FIBER_IS_JOINABLE`` flag is set."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:108
msgid "See also: :ref:`fiber_set_joinable()<c_api-fiber-fiber_set_joinable>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:112
msgid "Put the current fiber to sleep for at least 's' seconds."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:114
msgid "time to sleep"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:116
msgid "Note: this is a cancellation point."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:118
msgid "See also: :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:124
msgid "Check current fiber for cancellation (it must be checked manually)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:128
msgid "Report loop begin time as double (cheap)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:132
msgid "Report loop begin time as 64-bit int."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:136
msgid "Reschedule fiber to end of event loop cycle."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:142
msgid "Return ``slab_cache`` suitable to use with ``tarantool/small`` library"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:146
msgid "Return the current fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:152
msgid "Create a new fiber attributes container and initialize it with default parameters."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:155
msgid "Can be used for creating many fibers: corresponding fibers will not take ownership."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:160
msgid "Delete the ``fiber_attr`` and free all allocated resources. This is safe when fibers created with this attribute still exist."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:167
msgid "Set the fiber's stack size in the fiber attributes container."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:170
msgid "stack size for new fibers (in bytes)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:173
msgid "-1 on failure (if ``stack_size`` is smaller than the minimum allowable fiber stack size)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:178
msgid "Get the fiber's stack size from the fiber attributes container."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:180
msgid "fiber attributes container, or NULL for default"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:183
msgid "stack size (in bytes)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:189
msgid "A conditional variable: a synchronization primitive that allow fibers in Tarantool's :ref:`cooperative multitasking <atomic-cooperative_multitasking>` environment to yield until some predicate is satisfied."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:193
msgid "Fiber conditions have two basic operations -- \"wait\" and \"signal\", -- where \"wait\" suspends the execution of a fiber (i.e. yields) until \"signal\" is called."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:197
msgid "Unlike ``pthread_cond``, ``fiber_cond`` doesn't require mutex/latch wrapping."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:201
msgid "Create a new conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:205
msgid "Delete the conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:207
msgid "Note: behavior is undefined if there are fibers waiting for the conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:210
msgid "conditional variable to delete"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:216
msgid "Wake up **one** (any) of the fibers waiting for the conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:218
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:226
msgid "Does nothing if no one is waiting."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:220
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:228
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:244
msgid "conditional variable"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:224
msgid "Wake up **all** fibers waiting for the conditional variable."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:234
msgid "Suspend the execution of the current fiber (i.e. yield) until :ref:`fiber_cond_signal() <c_api-fiber_cond_signal>` is called."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:237
msgid "Like ``pthread_cond``, ``fiber_cond`` can issue spurious wake ups caused by explicit :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>` or :ref:`fiber_cancel()<c_api-fiber-fiber_cancel>` calls. It is highly recommended to wrap calls to this function into a loop and check the actual predicate and :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>` on every iteration."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:245
msgid "timeout in seconds"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:247
msgid "0 on :ref:`fiber_cond_signal() <c_api-fiber_cond_signal>` call or a spurious wake up"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:249
msgid "-1 on timeout, and the error code is set to 'TimedOut'"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:253
msgid "Shortcut for :ref:`fiber_cond_wait_timeout() <c_api-fiber_cond_wait_timeout>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/index.rst:5
msgid "C API reference"
msgstr "Справочник по C API"

#: ../doc/1.7/dev_guide/reference_capi/index.rst:7
msgid "List of C API headers"
msgstr "Список API для языка C"

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:3
msgid "Module `latch`"
msgstr "Модуль `latch`"

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:7
msgid "A lock for cooperative multitasking environment"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:11
msgid "Allocate and initialize the new latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:13
msgid "allocated latch object"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst
msgid "Return type"
msgstr "Возвращаемый тип"

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:14
msgid "box_latch_t *"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:18
msgid "Destroy and free the latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:20
msgid "latch to destroy"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:24
msgid "Lock a latch. Waits indefinitely until the current fiber can gain access to the latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst
msgid "param box_latch_t* latch"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:27
#: ../doc/1.7/dev_guide/reference_capi/latch.rst:33
msgid "latch to lock"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:31
msgid "Try to lock a latch. Return immediately if the latch is locked."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:34
msgid "status of operation. 0 - success, 1 - latch is locked"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:35
msgid "int"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:39
msgid "Unlock a latch. The fiber calling this function must own the latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:41
msgid "latch to unlock"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:3
msgid "Module `say` (logging)"
msgstr "Модуль `say` (логирование)"

#: ../doc/1.7/dev_guide/reference_capi/say.rst:11
msgid "do not use this value directly"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:29
#: ../doc/1.7/dev_guide/reference_capi/say.rst:45
msgid "Format and print a message to Tarantool log file."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:31
msgid ":ref:`log level <c_api-say-say_level>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:32
#: ../doc/1.7/dev_guide/reference_capi/say.rst:47
msgid "``printf()``-like format string"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:35
#: ../doc/1.7/dev_guide/reference_capi/say.rst:50
msgid "See also :manpage:`printf(3)`, :ref:`say_level<c_api-say-say_level>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:54
#, python-format
msgid "say_info(\"Some useful information: %s\", status);"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:3
msgid "Module `schema`"
msgstr "Модуль `schema`"

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:11
msgid "Start of the reserved range of system spaces."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:15
msgid "Space id of _schema."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:19
msgid "Space id of _space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:23
msgid "Space id of _vspace view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:27
msgid "Space id of _index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:31
msgid "Space id of _vindex view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:35
msgid "Space id of _func."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:39
msgid "Space id of _vfunc view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:43
msgid "Space id of _user."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:47
msgid "Space id of _vuser view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:51
msgid "Space id of _priv."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:55
msgid "Space id of _vpriv view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:59
msgid "Space id of _cluster."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:63
msgid "Space id of _truncate."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:67
msgid "End of reserved range of system spaces."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:71
msgid "NULL value, returned on error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:3
msgid "Module `trivia/config`"
msgstr "Модуль `trivia/config`"

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:7
msgid "Extern modifier for all public functions."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:11
msgid "Package major version - 1 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:15
msgid "Package minor version - 7 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:19
msgid "Package patch version - 0 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:23
msgid "A string with major-minor-patch-commit-id identifier of the release, e.g. 1.7.0-1216-g73f7154."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:28
msgid "System configuration dir (e.g ``/etc``)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:32
msgid "Install prefix (e.g. ``/usr``)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:36
msgid "Build type, e.g. Debug or Release"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:40
msgid "CMake build type signature, e.g. ``Linux-x86_64-Debug``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:44
msgid "Command line used to run CMake."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:48
msgid "Pathes to C and CXX compilers."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:52
msgid "C compile flags used to build Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:56
msgid "CXX compile flags used to build Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:60
msgid "A path to install ``*.lua`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:64
msgid "A path to install ``*.so``/``*.dylib`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:68
msgid "A path to Lua includes (the same directory where this file is contained)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:72
msgid "A constant added to ``package.path`` in Lua to find ``*.lua`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:76
msgid "A constant added to ``package.cpath`` in Lua to find ``*.so`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:3
msgid "Module `tuple`"
msgstr "Модуль `tuple`"

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:11
msgid "Tuple format."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:13
msgid "Each Tuple has an associated format (class). Default format is used to create tuples which are not attached to any particular space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:24
msgid "Allocate and initialize a new tuple from raw MsgPack Array data."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:26
msgid "tuple format. Use :ref:`box_tuple_format_default()<c_api-tuple-box_tuple_format_default>` to create space-independent tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:29
msgid "tuple data in MsgPack Array format ([field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:30
msgid "the end of ``data``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:32
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:49
msgid "NULL on out of memory"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:33
msgid "tuple otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:35
msgid "See also: :ref:`box.tuple.new()<box_tuple-new>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:39
msgid "When working with tuples, it is the developer's responsibility to ensure that enough space is allocated, taking especial caution when writing to them with msgpuck functions such as ``mp_encode_array()``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:48
msgid "Increase the reference counter of tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:50
msgid "Tuples are reference counted. All functions that return tuples guarantee that the last returned tuple is reference counted internally until the next call to API function that yields or returns another tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:54
msgid "You should increase the reference counter before taking tuples for long processing in your code. Such tuples will not be garbage collected even if another fiber removes them from a space. After processing, decrement the reference counter using :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`, otherwise the tuple will leak."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:61
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:74
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:87
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:93
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:112
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:127
msgid "a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:63
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:76
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:105
msgid "-1 on error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:66
msgid "See also: :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:72
msgid "Decrease the reference counter of tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:79
msgid "See also: :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:85
msgid "Return the number of fields in a tuple (the size of MsgPack Array)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:91
msgid "Return the number of bytes used to store internal tuple data (MsgPack Array)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:97
msgid "Dump raw MsgPack data to the memory buffer ``buf`` of size ``size``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:99
msgid "Store tuple fields in the memory buffer."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:101
msgid "Upon successful return, the function returns the number of bytes written. If buffer size is not enough then the return value is the number of bytes which would have been written if enough space had been available."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:106
msgid "number of bytes written on success."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:110
msgid "Return the associated format."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:114
msgid "tuple format"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:120
msgid "Return the raw tuple field in MsgPack format. The result is a pointer to raw MessagePack data which can be decoded with mp_decode functions, for an example see the tutorial program :ref:`read.c <f_c_tutorial-read>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:125
msgid "The buffer is valid until the next call to a ``box_tuple_*`` function."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:128
msgid "zero-based index in MsgPack array."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:130
msgid "NULL if i >= :ref:`box_tuple_field_count()<c_api-tuple-box_tuple_field_count>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:131
msgid "msgpack otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:146
msgid "Possible data types for tuple fields."
msgstr "Допустимые типы данных для полей кортежа."

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:148
msgid "One cannot use STRS/ENUM macros for types because there is a mismatch between enum name (STRING) and type name literal (\"STR\"). STR is already used as a type in Objective C."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:156
msgid "Key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:160
msgid "Create a key definition with the key fields with passed types on passed positions."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:162
msgid "May be used for tuple format creation and/or tuple comparison."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:164
msgid "array with key field identifiers"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:165
msgid "array with key :ref:`field types <capi-tuple_field_type>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:166
msgid "the number of key fields"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:173
msgid "Delete a key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:175
msgid "key definition to delete"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:181
msgid "Return new in-memory tuple format based on passed key definitions"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:183
msgid "array of keys defined for the format"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:184
msgid "count of keys"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:186
msgid "new tuple format on success"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:191
msgid "Increment tuple format reference count"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:193
msgid "tuple format to ref"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:197
msgid "Decrement tuple format reference count"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:199
msgid "tuple format to unref"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:205
msgid "Compare tuples using key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:207
msgid "the first tuple"
msgstr "первый кортеж"

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:208
msgid "the second tuple"
msgstr "второй кортеж"

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:209
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:223
msgid "key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:211
msgid "0  if ``key_fields(tuple_a)`` == ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:212
msgid "<0 if ``key_fields(tuple_a)`` < ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:213
msgid ">0 if ``key_fields(tuple_a)`` > ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:215
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:229
msgid "See also: enum :ref:`field_type <capi-tuple_field_type>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:219
msgid "Compare a tuple with a key using key definition"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:222
msgid "key with MessagePack array header"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:225
msgid "0  if ``key_fields(tuple)`` == ``parts(key)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:226
msgid "<0 if ``key_fields(tuple)`` < ``parts(key)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:227
msgid ">0 if ``key_fields(tuple)`` > ``parts(key)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:233
msgid "Tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:237
msgid "Allocate and initialize a new tuple iterator. The tuple iterator allows iterating over fields at the root level of a MsgPack array."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:242
msgid ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // error handling using box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // process raw MsgPack data\n"
"}\n"
"\n"
"// rewind the iterator to the first position\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// rewind three fields\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:265
msgid "Destroy and free tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:271
msgid "Return zero-based next position in iterator. That is, this function returnы the field id of the field that will be returned by the next call to :ref:`box_tuple_next()<c_api-tuple-box_tuple_next>`. Returned value is zero after initialization or rewind and :ref:`box_tuple_field_count()<c_api-tuple-box_tuple_field_count>` after the end of iteration."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:278
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:285
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:300
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:321
msgid "a tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:279
msgid "position"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:283
msgid "Rewind iterator to the initial position."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:287
msgid "After: ``box_tuple_position(it) == 0``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:291
msgid "Seek the tuple iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:293
msgid "The result is a pointer to raw MessagePack data which can be decoded with mp_decode functions, for an example see the tutorial program :ref:`read.c <f_c_tutorial-read>`. The returned buffer is valid until the next call to ``box_tuple_*`` API. The requested ``field_no`` is returned by the next call to ``box_tuple_next(it)``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:301
msgid "field number - zero-based position in MsgPack array"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:304
msgid "After:"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:306
msgid "``box_tuple_position(it) == field_not`` if returned value is not NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:307
msgid "``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned value is NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:314
msgid "Return the next tuple field from tuple iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:316
msgid "The result is a pointer to raw MessagePack data which can be decoded with mp_decode functions, for an example see the tutorial program :ref:`read.c <f_c_tutorial-read>`. The returned buffer is valid until next call to ``box_tuple_*`` API."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:322
msgid "NULL if there are no more fields"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:323
msgid "MsgPack otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:325
msgid "Before: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` is zero-based ID of returned field."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:328
msgid "After: ``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned value is NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:3
msgid "Module `txn`"
msgstr "Модуль `txn`"

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:7
msgid "Return true if there is an active transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:13
msgid "Begin a transaction in the current fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:15
msgid "A transaction is attached to caller fiber, therefore one fiber can have only one active transaction. See also :ref:`box.begin()<box-begin>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:19
msgid "-1 on error. Perhaps a transaction has already been started."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:25
msgid "Commit the current transaction. See also :ref:`box.commit() <box-commit>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:28
msgid "-1 on error. Perhaps a disk write failure"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:32
msgid "Roll back the current transaction. See also :ref:`box.rollback() <box-rollback>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:36
msgid "Return a descriptor of a savepoint."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:40
msgid "Roll back the current transaction as far as the specified savepoint."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:44
msgid "Allocate memory on txn memory pool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:46
msgid "The memory is automatically deallocated when the transaction is committed or rolled back."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:3
msgid "Module `lua/utils`"
msgstr "Модуль `lua/utils`"

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:9
msgid "Push cdata of given ``ctypeid`` onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:11
msgid "CTypeID must be used from FFI at least once. Allocated memory returned uninitialized. Only numbers and pointers are supported."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:14
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:27
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:42
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:49
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:62
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:74
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:81
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:116
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:128
msgid "Lua State"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:15
msgid "FFI's CTypeID of this cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:17
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:31
msgid "memory associated with this cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:19
msgid "See also: :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:25
msgid "Check whether the function argument ``idx`` is a cdata."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:28
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:43
msgid "stack index"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:29
msgid "output argument. FFI's CTypeID of returned cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:33
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:37
msgid "Set finalizer function on a cdata object."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:39
msgid "Equivalent to call `ffi.gc(obj, function)`. Finalizer function must be on the top of the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:47
msgid "Return CTypeID (FFI) of given СDATA type."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:50
msgid "C type name as string (e.g. \"struct request\" or \"uint32_t\")"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:53
msgid "CTypeID"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:55
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:60
msgid "Declare symbols for FFI."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:63
msgid "C definitions (e.g. \"struct stat\")"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:66
msgid "``LUA_ERRRUN``, ``LUA_ERRMEM` or ``LUA_ERRERR`` otherwise."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:68
msgid "See also: ``ffi.cdef(def)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:72
msgid "Push uint64_t onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:75
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:82
msgid "value to push"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:79
msgid "Push int64_t onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:86
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:100
msgid "Check whether the argument idx is a uint64 or a convertable string and returns this number."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst
msgid "throws"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:89
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:96
msgid "error if the argument can't be converted"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:93
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:107
msgid "Check whether the argument idx is a int64 or a convertable string and returns this number."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:103
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:110
msgid "the converted number or 0 of argument can't be converted"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:114
msgid "Push a tuple onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:118
msgid "error on OOM"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:120
msgid "See also: :ref:`luaT_istuple <c_api-utils-luaT_istuple>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:126
msgid "Check whether ``idx`` is a tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:129
msgid "the stack index"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:131
msgid "non-NULL if ``idx`` is a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:132
msgid "NULL if ``idx`` is not a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:136
msgid "Re-throw the last Tarantool error as a Lua object."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:138
msgid "See also: `lua_error() <https://www.lua.org/manual/5.1/manual.html#lua_error>`_,"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:139
msgid ":ref:`box_error_last() <c_api-error-box_error_last>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:143
msgid "Similar to `lua_cpcall() <https://www.lua.org/manual/5.1/manual.html#lua_cpcall>`_, but with the proper support of Tarantool errors."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:148
msgid "Get the global Lua state used by Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:5
msgid "Release management"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:11
msgid "Release policy"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:12
msgid "A Tarantool release is identified by three digits, for example, 1.7.7. We use these digits according to their definitions provided at http://semver.org:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:15
msgid "The first digit stands for MAJOR release. A **major** release may contain incompatible changes*."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:17
msgid "The second digit stands for MINOR release, it does not contain incompatible"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:18
msgid "changes, and is used for introducing backward-compatible features."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:19
msgid "The third digit is for PATCH releases that contain only backward-compatible *bug fixes*."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:22
msgid "In MINOR digit, we reflect how stable a release is:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:24
msgid "0 meaning alpha,"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:25
msgid "1 meaning beta,"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:26
msgid "anything between 1 and 10 meaning stable, and"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:27
msgid "10 meaning LTS."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:29
msgid "So, each MAJOR release series goes through a development-maturity life cycle of MINOR releases, as follows:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:32
msgid "**Alpha**. Once in every few months we release a few alpha versions, e.g. 2.0.1, 2.0.2."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:35
msgid "Alpha versions may contain incompatible changes, crashes and other bugs."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:37
msgid "**Beta**. Once major changes necessary to introduce new flagship features are ready, we release a few beta versions, e.g. 2.1.3, 2.1.4."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:40
msgid "Beta versions may contain crashes, but do not have incompatible changes, so can be used to develop new applications."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:43
msgid "**Stable**. Finally, after we see our beta versions run successfully in production, usually in a few more months, during which we fix all incoming bugs and add some minor features, we declare this MAJOR release series stable."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:48
msgid "Like Ubuntu, we distinguish two kinds of stable releases:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:50
msgid "**LTS (Long Term Support)** releases that are supported for 3 years (community) and up to 5 years (paying customers). **LTS** release is identified by MINOR version 10."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:53
msgid "**Standard stable releases** are only supported a few months after the next stable is out."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:56
msgid "\"Support\" means that we continue fixing bugs in a release."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:58
msgid "We add commits simultaneously to three MAJOR releases:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:60
msgid "**LTS** is a stable release which does not receive new features, and only gets backward compatible fixes. Hence, following the rules of semver, LTS release never has its MAJOR or MINOR version increased, and only gets PATCH level releases."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:65
msgid "**STABLE** is our current stable release, which may receive new features. When the next STABLE version is published, MINOR version is incremented. Between MINOR releases, we may have intermediate PATCH level releases as well, which will contain only bug fixes. We maintain PATCH level releases for two STABLE releases, the current and the previous one, to preserve support continuity."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:72
msgid "**NEXT** is our next MAJOR release, and it follows the maturity cycle described in the beginning. While NEXT release is in alpha state, its MINOR is frozen at 0 and is only increased when the release reaches BETA status. Once the NEXT release becomes STABLE, we switch the vehicle for delivery of minor features, designating the previous stable release as LTS, and releasing it with MINOR set to 10."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:79
msgid "To sum up, once a quarter we release:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:81
msgid "the next LTS release, e.g. 2.10.6, 2.10.7 or 2.10.8"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:82
msgid "the next STABLE release, e.g. 3.6, 3.7 or 3.8"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:83
msgid "(optionally) an alpha or beta version of the NEXT release, e.g. 4.0.1, 4.0.2 or 4.0.3"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:86
msgid "In all supported releases, we also release a PATCH release as soon as we find and fix an outstanding CVE/vulnerability."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:89
msgid "We also publish nightly builds, and use the fourth slot in the version identifier to designate the nightly build number."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:92
msgid "Example version identifier:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:94
msgid "2.0.3 - third alpha of 2.0 release"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:95
msgid "2.1.3 - a beta of 2.0 release"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:96
msgid "2.2 - a stable version of 2.0 series, but not an LTS yet"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:97
msgid "2.10 - an LTS release"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:103
msgid "How to make a minor release"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:105
msgid ""
"$ git tag -a 2.4 -m \"Next minor in 2.x series\"\n"
"$ vim CMakeLists.txt # edit CPACK_PACKAGE_VERSION_PATCH\n"
"$ git push --tags"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:111
msgid "A tag which is made on a git branch can be taken along with a merge, or left on the branch. The technique to \"keep the tag on the branch it was originally set on\" is to use ``--no-fast-forward`` when merging this branch."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:115
msgid "With ``--no-ff``, a merge changeset is created to represent the received changes, and only that merge changeset ends up in the destination branch. This technique can be useful when there are two active lines of development, e.g. \"stable\" and \"next\", and it's necessary to be able to tag both lines independently."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:121
msgid "To make sure that a tag doesn't end up in the destination branch, it is necessary to have the commit to which the tag is attached, \"stay on the original branch\". That's exactly what a merge with disabled \"fast-forward\" does -- creates a \"merge\" commit and adds it to both branches."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:126
msgid "Here's what it may look like:"
msgstr "Вывод может выглядеть следующим образом:"

#: ../doc/1.7/dev_guide/release_management.rst:128
msgid ""
"kostja@shmita:~/work/tarantool$ git checkout master\n"
"Already on 'master'\n"
"kostja@shmita:~/work/tarantool$ git tag -a 2.4 -m \"Next development\"\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4\n"
"kostja@shmita:~/work/tarantool$ git checkout master-stable\n"
"Switched to branch 'master-stable'\n"
"kostja@shmita:~/work/tarantool$ git tag -a 2.3 -m \"Next stable\"\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.3\n"
"kostja@shmita:~/work/tarantool$ git checkout master\n"
"Switched to branch 'master'\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4\n"
"kostja@shmita:~/work/tarantool$ git merge --no-ff master-stable\n"
"Auto-merging CMakeLists.txt\n"
"Merge made by recursive.\n"
" CMakeLists.txt |    1 +\n"
" 1 files changed, 1 insertions(+), 0 deletions(-)\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4.0-0-g0a98576"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:152
msgid "Also, don't forget this:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:154
msgid "Update all issues. Upload the ChangeLog based on ``git log`` output."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:156
msgid "The ChangeLog must only include items which are mentioned as issues on GitHub. If anything significant is there, which is not mentioned, something went wrong in release planning and the release should be held up until this is cleared."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:161
msgid "Click 'Release milestone'. Create a milestone for the next minor release. Alert the driver to target bugs and blueprints to the new milestone."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:166
msgid "How to release a Docker container"
msgstr "Как выпустить Docker-контейнер"

#: ../doc/1.7/dev_guide/release_management.rst:168
msgid "To bump a new version of a Docker container:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:170
msgid "On the ``master`` branch of `tarantool/docker <https://github.com/tarantool/docker>`_ repository, find the Dockerfile that corresponds to the commit's major version (e.g. https://github.com/tarantool/docker/blob/master/2.4/Dockerfile for Tarantool version 2.4) and specify the required commit in ``TARANTOOL_VERSION``, for example ``TARANTOOL_VERSION=2.4.0-11-gcd17b77f9``."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:178
msgid "Commit the Dockerfile back to ``master`` branch."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:180
msgid "In the same repository, create a branch named after the commit's ``<major>.<minor>`` versions, e.g. ``2.4`` for commit 2.4.0-11-gcd17b77f9."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:184
msgid "In Tarantool container build settings at ``hub.docker.com`` (https://hub.docker.com/r/tarantool/tarantool/~/settings/automated-builds/), add a new line:"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:188
msgid "Branch: x.y, /x, x.y"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:192
msgid "where ``x`` and ``y`` correspond to the commit's major and minor versions."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:194
msgid "Click **Save changes**."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:196
msgid "Shortly after, a new Docker container will be built."
msgstr ""

#: ../doc/1.7/index.rst:6
msgid "Tarantool - Documentation"
msgstr ""

#: ../doc/1.7/index.rst:13
msgid "|nbspc|"
msgstr ""

#: ../doc/1.7/index.rst:61
msgid "Tarantool 1.7 manual  This manual embraces all aspects of using Tarantool: from introductory information and exercises for beginners -- to advanced instructions and detailed references for power users and contributors.  Документация находится в процессе перевода и может отставать от английской версии.      <div class=\"badge-icon\"></div>  Other sources  Single page  PDF  English  Russian  Telegram chat RU  Telegram chat EN"
msgstr ""

#: ../doc/1.7/index.rst:22
msgid "Tarantool 1.10 manual"
msgstr "Документация по Tarantool 1.10"

#: ../doc/1.7/index.rst:26
msgid "This manual embraces all aspects of using Tarantool: from introductory information and exercises for beginners -- to advanced instructions and detailed references for power users and contributors."
msgstr "Данная документация содержит полную информацию по использованию Tarantool: от вводной части для новичков – до подробных инструкций и справочников для опытных пользователей и участников проекта."

#: ../doc/1.7/index.rst:47
msgid "Other sources"
msgstr "Прочие источники"

#: ../doc/1.7/index.rst:49
msgid "`Single page <singlehtml.html>`_"
msgstr "`Одной страницей <singlehtml.html>`_"

#: ../doc/1.7/index.rst:50
msgid "`PDF <Tarantool.pdf>`_"
msgstr "`PDF <Tarantool.pdf>`_"

#: ../doc/1.7/index.rst:51
msgid "`English`_"
msgstr "`Форум (eng)`_"

#: ../doc/1.7/index.rst:52
msgid "`Russian`_"
msgstr "`Форум (рус)`_"

#: ../doc/1.7/index.rst:60
msgid "`Telegram chat EN`_"
msgstr "`Telegram-чат`_"

#: ../doc/1.7/index.rst:60
msgid "`Telegram chat RU`_"
msgstr "`Telegram-чат`_"

#: ../doc/1.7/intro.rst:7
msgid "An application server together with a database manager"
msgstr "Сервер приложений + СУБД"

#: ../doc/1.7/intro.rst:9
msgid "Tarantool is a Lua application server integrated with a database management system. It has a \"fiber\" model which means that many Tarantool applications can run simultaneously on a single thread, while each instance of the Tarantool server itself can run multiple threads for input-output and background maintenance. It incorporates the LuaJIT -- \"Just In Time\" -- Lua compiler, Lua libraries for most common applications, and the Tarantool Database Server which is an established NoSQL DBMS. Thus Tarantool serves all the purposes that have made node.js and Twisted popular, plus it supports data persistence."
msgstr "Tarantool представляет собой сервер приложений на языке Lua, интегрированный с СУБД. В основе Tarantool'а лежат файберы (fibers), что означает, что несколько Tarantool-приложений могут работать в одном потоке (thread), при этом каждый экземпляр Tarantool-сервера может одновременно запускать несколько потоков для обработки ввода-вывода данных и фоновых задач. Tarantool включает в себя LuaJIT (Just In Time) - Lua-компилятор, Lua-библиотеки для наиболее распространенных приложений, а также сервер базы данных Tarantool'а, который представляет собой широко признанную СУБД NoSQL. Таким образом, Tarantool используется для всех тех целей, которые принесли популярность node.js и Twisted, и более того - поддерживает персистентность данных."

#: ../doc/1.7/intro.rst:17
msgid "The code is free. The open-source license is `BSD license`_. The supported platforms are GNU/Linux, Mac OS and FreeBSD."
msgstr "Tarantool — это open-source проект. Исходный код открыт для всех и распространяется бесплатно согласно лицензии `BSD license`_. Поддерживаемые платформы: GNU / Linux, Mac OS и FreeBSD."

#: ../doc/1.7/intro.rst:20
msgid "Tarantool's creator and biggest user is `Mail.Ru`_, the largest internet company in Russia, with 30 million users, 25 million emails per day, and a web site whose Alexa global rank is in the `top 40`_ worldwide. Tarantool services Mail.Ru's hottest data, such as the session data of online users, the properties of online applications, the caches of the underlying data, the distribution and sharding algorithms, and much more. Outside Mail.Ru the software is used by a growing number of projects in online gaming, digital marketing, and social media industries. Although Mail.Ru is the sponsor for product development, the roadmap and the bugs database and the development process are fully open. The software incorporates patches from dozens of community contributors. The Tarantool community writes and maintains most of the drivers for programming languages.  The greater Lua community has hundreds of useful packages most of which can become Tarantool extensions."
msgstr "Создателем Tarantool'а — а также его основным пользователем — является компания `Mail.Ru`_, крупнейшая Интернет-компания России (30 млн пользователей, 25 млн электронных писем в день, веб-сайт в списке `top 40`_ международного Alexa-рейтинга). Tarantool используется для обработки  самых \"горячих\" данных Mail.Ru, таких как данные пользовательских онлайн-сессий, настройки онлайн-приложений, кэширование сервисных данных,  алгоритмы распределения данных и шардинга, и т.д. Tarantool также используется во всё большем количестве проектов вне стен Mail.Ru. Это, к примеру, онлайн-игры, цифровой маркетинг, социальные сети. Несмотря на то  что Mail.Ru спонсирует разработку Tarantool'а, весь процесс разработки, в т.ч. дальнейшие планы и база обнаруженных ошибок, является полностью открытым. В Tarantool включены патчи от большого числа сторонних разработчиков. Усилиями сообщества разработчиков Tarantool'а были написаны (и далее поддерживаются) библиотеки для подключения модулей на внешних языках программирования. А сообщество Lua-разработчиков предоставило сотни полезных пакетов, большинство из которых можно использовать в качестве расширений для Tarantool'а."

#: ../doc/1.7/intro.rst:34
msgid "Users can create, modify and drop **Lua functions** at runtime. Or they can define **Lua programs** that are loaded during startup for triggers, background tasks, and interacting with networked peers. Unlike popular application development frameworks based on a \"reactor\" pattern, networking in server-side Lua is sequential, yet very efficient, as it is built on top of the **cooperative multitasking** environment that Tarantool itself uses."
msgstr "Пользователи Tarantool'а могут создавать, изменять и удалять **Lua-функции** прямо во время исполнения кода. Также они могут указывать  **Lua-программы**, которые будут загружаться во время запуска Tarantool'а. Такие программы могут служить триггерами, выполнять фоновые задачи и взаимодействовать с другими узлами по сети. В отличие от многих популярных сред разработки приложений, которые используют \"реактивный\" принцип, сетевое взаимодействие в Lua устроено последовательно, но очень эффективно, т.к. оно использует среду **кооперативной многозадачности** самого Tarantool'а."

#: ../doc/1.7/intro.rst:42
msgid "One of the built-in Lua packages provides an API for the Database Management System. Thus some developers see Tarantool as a DBMS with a popular stored procedure language, while others see it as a Lua interpreter, while still others see it as a replacement for many components of multi-tier Web applications. Performance can be a few hundred thousand transactions per second on a laptop, scalable upwards or outwards to server farms."
msgstr "Один из встраиваемых Lua-пакетов — это API для функций СУБД. Таким образом, некоторые разработчики рассматривают Tarantool как СУБД с популярным языком для написания хранимых процедур, другие рассматривают его как Lua-интерпретатор, а третьи — как вариант замены сразу нескольких компонентов в многозвенных веб-приложениях. Производительность Tarantool'а может достигать сотен тысяч транзакций в секунду на ноутбуке, и ее можно наращивать \"вверх\" или \"вширь\" за счет новых серверных ферм."

#: ../doc/1.7/intro.rst:52
msgid "Database features"
msgstr "Возможности СУБД"

#: ../doc/1.7/intro.rst:54
msgid "Tarantool can run without it, but \"The Box\" -- the DBMS server -- is a strong distinguishing feature."
msgstr "Компонент \"box\" — серверная часть с функциями СУБД — это важная часть Tarantool'а, хотя он может работать и без данного компонента."

#: ../doc/1.7/intro.rst:57
msgid "The database API allows for permanently storing Lua objects, managing object collections, creating or dropping secondary keys, making changes atomically, configuring and monitoring replication, performing controlled fail-over, and executing Lua code triggered by database events. Remote database instances are accessible transparently via a remote-procedure-invocation API."
msgstr "API для функций СУБД позволяет хранить Lua-объекты, управлять коллекциями объектов, создавать и удалять вторичные ключи, делать атомарные изменения, конфигурировать и мониторить репликацию, производить  контролируемое переключение при отказе (failover), а также исполнять код  на Lua, который вызывается событиями в базе. А для прозрачного доступа к  удаленным (remote) экземплярам баз данных разработан API для вызова удаленных процедур."

#: ../doc/1.7/intro.rst:65
msgid "Tarantool's DBMS server uses the **storage engine** concept, where different sets of algorithms and data structures can be used for different situations. Two storage engines are built-in: an in-memory engine which has all the data and indexes in RAM, and a two-level B-tree engine for data sets whose size is 10 to 1000 times the amount of available RAM. All storage engines in Tarantool support transactions and replication by using a common **write ahead log** (WAL). This ensures consistency and crash safety of the persistent state. Changes are not considered complete until the WAL is written. The logging subsystem supports group commit."
msgstr "В архитектуре серверной части СУБД Tarantool'а реализована концепция \"движков\" базы данных (storage engines), где в разных ситуациях используются разные наборы алгоритмов и структуры данных. В Tarantool'е есть два встроенных движка: in-memory движок, который держит все данные и  индексы в оперативной памяти, и двухуровневый движок для B-деревьев, который обрабатывает данные размером в 10-1000 раз больше того, что может  поместиться в оперативной памяти. Все движки в Tarantool'е поддерживают транзакции и репликацию, поскольку они используют единый механизм **упреждающей записи** (WAL = write ahead log). Это механизм обеспечивает  согласованность и сохранность данных при сбоях. Таким образом, изменения  не считаются завершенными, пока не проходит запись в лог WAL. Подсистема  логирования также поддерживает групповые коммиты. "

#: ../doc/1.7/intro.rst:76
msgid "**Tarantool's in-memory storage engine** (memtx) keeps all the data in random-access memory, and therefore has very low read latency. It also keeps persistent copies of the data in non-volatile storage, such as disk, when users request \"snapshots\". If an instance of the server stops and the random-access memory is lost, then restarts, it reads the latest snapshot and then replays the transactions that are in the log -- therefore no data is lost."
msgstr "**In-memory движок базы данных Tarantool'а** (memtx) хранит все данные в оперативной памяти, поэтому у него низкое значение задержки чтения. Кроме того, когда пользователи запрашивают снимки данных (snapshots), этот движок создает персистентные копии данных в энергонезависимой памяти, например на диске. Если экземпляр сервера прекращает работать и данные в оперативной памяти теряются, то при следующем запуске сервер загрузит в память самый свежий снимок и воспроизведет все транзакции из журнала. Таким образом, данные не теряются."

#: ../doc/1.7/intro.rst:85
msgid "**Tarantool's in-memory engine is lock-free** in typical situations. Instead of the operating system's concurrency primitives, such as mutexes, Tarantool uses cooperative multitasking to handle thousands of connections simultaneously. There is a fixed number of independent execution threads. The threads do not share state. Instead they exchange data using low-overhead message queues. While this approach limits the number of cores that the instance will use, it removes competition for the memory bus and ensures peak scalability of memory access and network throughput. CPU utilization of a typical highly-loaded Tarantool instance is under 10%. Searches are possible via **secondary index keys** as well as primary keys."
msgstr "В штатных ситуациях **in-memory движок работает без блокировок**. Вместо многопоточных примитивов, которые предлагает операционная система (таких как mutex'ы), Tarantool использует кооперативную многозадачность для работы с тысячами соединений одновременно. В Tarantool'е есть фиксированное количество независимых потоков управления (thread), и у них нет общего состояния. Для обмена данными между потоками используются очереди сообщений с малой перегрузкой. Хотя такой подход накладывает ограничение на количество процессорных ядер, которые может использовать экземпляр, в то же время он позволяет избежать борьбы за шину памяти, а также дает запас масштабируемости по скорости доступа к памяти и производительности сети. В результате даже при большой нагрузке экземпляр Tarantool'а в среднем использует процессор менее чем на 10%. Кроме того, Tarantool поддерживает поиск как по первичным, так и по **внешним ключам в индексах**."

#: ../doc/1.7/intro.rst:95
msgid "**Tarantool's disk-based storage engine** is a fusion of ideas from modern filesystems, log-structured merge trees and classical B-trees. All data is organized into **ranges**. Each range is represented by a file on disk. Range size is a configuration option and normally is around 64MB. Each range is a collection of pages, serving different purposes. Pages in a fully merged range contain non-overlapping ranges of keys. A range can be partially merged if there were a lot of changes in its key range recently. In that case some pages represent new keys and values in the range. The disk-based storage engine is append only: new data never overwrites old data. The disk-based storage engine is named *vinyl*."
msgstr "**Дисковый движок базы данных Tarantool'а** совмещает в себе подходы, заимствованные из современных файловых систем, журнально-структурированных деревьев со слиянием (log-structured merge trees) и классических B-деревьев. Все данные разбиты на **диапазоны**. Каждый диапазон представлен файлом на диске. Размер диапазона можно изменять, обычно он равен 64МБ. Каждый диапазон — это набор страниц, которые служат разным целям. После полного слияния диапазона ключи на его страницах не пересекаются. Если диапазоны ключей недавно сильно изменялись, можно провести частичное слияние диапазона. В этом случае на некоторых страницах появились новые ключи и значения. Дисковый движок обновляет данные по принципу дописывания в конец: новые данные никогда не затирают старые. Дисковый движок базы данных называется *vinyl*."

#: ../doc/1.7/intro.rst:106
msgid "Tarantool supports **multi-part index keys**. The possible index types are HASH, TREE, BITSET, and RTREE."
msgstr "Tarantool поддерживает работу с **составными ключами в индексах**. Возможные типы ключей: HASH, TREE, BITSET и RTREE."

#: ../doc/1.7/intro.rst:109
msgid "Tarantool supports **asynchronous replication**, locally or to remote hosts. The replication architecture can be **master-master**, that is, many nodes may both handle the loads and receive what others have handled, for the same data sets."
msgstr "Tarantool также поддерживает **асинхронную репликацию** — как локальную, так и на удаленных серверах. При этом репликацию можно настроить по принципу **мастер-мастер**, когда несколько узлов могут не только обрабатывать входящую нагрузку, но и получать данные от других узлов."

#: ../doc/1.7/reference/configuration/index.rst:5
msgid "Configuration reference"
msgstr "Справочник по настройке"

#: ../doc/1.7/reference/configuration/index.rst:7
msgid "This reference covers all options and parameters which can be set for Tarantool on the command line or in an :ref:`initialization file <index-init_label>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:10
msgid "Tarantool is started by entering either of the following command:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:49
msgid ""
"$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:23
msgid "Command options"
msgstr "Опции командной строки"

#: ../doc/1.7/reference/configuration/index.rst:27
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:33
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:35
msgid ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:42
msgid "In this example:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:44
msgid "“Tarantool” is the name of the reusable asynchronous networking programming framework."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:47
msgid "The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for each new milestone and indicates possible incompatible changes, and ``<patch>`` stands for the number of bug fix releases made after the start of the milestone. For non-released versions only, there may be a commit number and commit SHA1 to indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:55
msgid "“Target” is the platform tarantool was built on. Some platform-specific details may follow this line."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:60
msgid "Tarantool uses `git describe <http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to produce its version id, and this id can be used at any time to check out the corresponding source from our `git repository <http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:70
msgid "URI"
msgstr "Универсальный код ресурса (URI)"

#: ../doc/1.7/reference/configuration/index.rst:72
msgid "Some configuration parameters and some functions depend on a URI, or \"Universal Resource Identifier\". The URI string format is similar to the `generic syntax for a URI schema <http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may contain (in order) a user name for login, a password, a host name or host IP address, and a port number. Only the port number is always mandatory. The password is mandatory if the user name is specified, unless the user name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or '[::]' is assumed, meaning respectively any IPv4 address or any IPv6 address, on the local machine. If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:91
msgid "URI fragment"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:93
msgid "port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:93
msgid "3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:95
msgid "host:port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:95
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:97
msgid "username:password@host:port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:97
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:100
msgid "In certain circumstances a Unix domain socket may be used where a URI is expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:104
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:110
msgid "Initialization file"
msgstr "Файл инициализации"

#: ../doc/1.7/reference/configuration/index.rst:112
msgid "If the command to start Tarantool includes :codeitalic:`lua-initialization-file`, then Tarantool begins by invoking the Lua program in the file, which by convention may have the name \"``script.lua``\". The Lua program may get further arguments from the command line or may use operating-system functions, such as ``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if the database server will be used or if ports need to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:120
msgid ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    memtx_memory        = 100000,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:131
msgid "and suppose the environment variable LISTEN_URI contains 3301, and suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen might look like this:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:135
msgid ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:149
msgid "If you wish to start an interactive session on the same terminal after initialization is complete, you can use :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:165
msgid "Configuration parameters"
msgstr "Конфигурационные параметры"

#: ../doc/1.7/reference/configuration/index.rst:167
msgid "Configuration parameters have the form:"
msgstr "Конфигурационные параметры:"

#: ../doc/1.7/reference/configuration/index.rst:169
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:171
msgid "Since ``box.cfg`` may contain many configuration parameters and since some of the parameters (such as directory addresses) are semi-permanent, it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:176
msgid "Most configuration parameters are for allocating resources, opening ports, and specifying database behavior. All parameters are optional. A few parameters are dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a second time."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:181
msgid "To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:184
msgid "The following sections describe all parameters for basic operation, for storage, for binary logging and snapshots, for replication, for networking, and for logging."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:189
msgid "Basic parameters"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:4
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:5
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:6
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:7
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:8
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:9
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:10
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:11
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:12
msgid ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:18
msgid "Run the server as a background task. The :ref:`log <cfg_logging-log>` and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for this to work."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:22
#: ../doc/1.7/reference/configuration/cfg_basic.rst:111
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:19
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:25
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:55
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:66
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/1.7/reference/configuration/cfg_logging.rst:120
msgid "Type: boolean"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:23
#: ../doc/1.7/reference/configuration/cfg_basic.rst:112
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:26
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:49
msgid "Default: false"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:24
#: ../doc/1.7/reference/configuration/cfg_basic.rst:86
#: ../doc/1.7/reference/configuration/cfg_basic.rst:97
#: ../doc/1.7/reference/configuration/cfg_basic.rst:125
#: ../doc/1.7/reference/configuration/cfg_basic.rst:150
#: ../doc/1.7/reference/configuration/cfg_basic.rst:164
#: ../doc/1.7/reference/configuration/cfg_basic.rst:189
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:21
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:34
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:77
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:27
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:57
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:95
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:110
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:50
#: ../doc/1.7/reference/configuration/cfg_logging.rst:105
#: ../doc/1.7/reference/configuration/cfg_logging.rst:122
#: ../doc/1.7/reference/configuration/cfg_replication.rst:127
#: ../doc/1.7/reference/configuration/cfg_replication.rst:149
#: ../doc/1.7/reference/configuration/cfg_storage.rst:30
#: ../doc/1.7/reference/configuration/cfg_storage.rst:43
#: ../doc/1.7/reference/configuration/cfg_storage.rst:55
#: ../doc/1.7/reference/configuration/cfg_storage.rst:69
#: ../doc/1.7/reference/configuration/cfg_storage.rst:79
#: ../doc/1.7/reference/configuration/cfg_storage.rst:92
#: ../doc/1.7/reference/configuration/cfg_storage.rst:102
#: ../doc/1.7/reference/configuration/cfg_storage.rst:114
#: ../doc/1.7/reference/configuration/cfg_storage.rst:126
#: ../doc/1.7/reference/configuration/cfg_storage.rst:139
#: ../doc/1.7/reference/configuration/cfg_storage.rst:151
#: ../doc/1.7/reference/configuration/cfg_storage.rst:162
#: ../doc/1.7/reference/configuration/cfg_storage.rst:173
msgid "Dynamic: no"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:30
msgid "Add the given string to the server's process title (what’s shown in the COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:34
msgid "For example, ordinarily :samp:`ps -ef` shows the Tarantool server process thus:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:37
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:42
msgid "But if the configuration parameters include ``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:45
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:50
#: ../doc/1.7/reference/configuration/cfg_basic.rst:84
#: ../doc/1.7/reference/configuration/cfg_basic.rst:95
#: ../doc/1.7/reference/configuration/cfg_basic.rst:123
#: ../doc/1.7/reference/configuration/cfg_basic.rst:148
#: ../doc/1.7/reference/configuration/cfg_basic.rst:162
#: ../doc/1.7/reference/configuration/cfg_basic.rst:187
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:63
#: ../doc/1.7/reference/configuration/cfg_logging.rst:103
#: ../doc/1.7/reference/configuration/cfg_logging.rst:173
#: ../doc/1.7/reference/configuration/cfg_replication.rst:40
#: ../doc/1.7/reference/configuration/cfg_replication.rst:125
#: ../doc/1.7/reference/configuration/cfg_replication.rst:147
msgid "Type: string"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:51
#: ../doc/1.7/reference/configuration/cfg_basic.rst:73
#: ../doc/1.7/reference/configuration/cfg_basic.rst:96
#: ../doc/1.7/reference/configuration/cfg_basic.rst:149
#: ../doc/1.7/reference/configuration/cfg_basic.rst:188
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:48
#: ../doc/1.7/reference/configuration/cfg_logging.rst:104
#: ../doc/1.7/reference/configuration/cfg_networking.rst:14
#: ../doc/1.7/reference/configuration/cfg_replication.rst:41
#: ../doc/1.7/reference/configuration/cfg_replication.rst:77
#: ../doc/1.7/reference/configuration/cfg_replication.rst:126
#: ../doc/1.7/reference/configuration/cfg_replication.rst:148
msgid "Default: null"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:52
#: ../doc/1.7/reference/configuration/cfg_basic.rst:74
#: ../doc/1.7/reference/configuration/cfg_basic.rst:113
#: ../doc/1.7/reference/configuration/cfg_basic.rst:140
#: ../doc/1.7/reference/configuration/cfg_basic.rst:203
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:68
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:60
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:89
msgid "Dynamic: yes"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:58
msgid "The read/write data port number or :ref:`URI <index-uri>` (Universal Resource Identifier) string. Has no default value, so **must be specified** if connections will occur from remote clients that do not use the :ref:`“admin port” <admin-security>`. Connections made with :samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" connections."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:65
msgid "A typical value is 3301."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:69
msgid "A replica also binds to this port, and accepts connections, but these connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:72
msgid "Type: integer or string"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:80
msgid "A directory where memtx stores snapshot (.snap) files. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:85
#: ../doc/1.7/reference/configuration/cfg_basic.rst:124
#: ../doc/1.7/reference/configuration/cfg_basic.rst:163
msgid "Default: \".\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:92
msgid "Store the process id in this file. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:103
msgid "Say ``box.cfg{read_only=true...}`` to put the server instance in read-only mode. After this, any requests that try to change persistent data will fail with error :errcode:`ER_READONLY`. Read-only mode should be used for master-replica :ref:`replication <replication>`. Read-only mode does not affect data-change requests for spaces defined as :ref:`temporary <box_schema-space_create>`. Although read-only mode prevents the server from writing to the :ref:`WAL <internals-wal>`, it does not prevent writing diagnostics with the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:119
msgid "A directory where vinyl files or subdirectories will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:131
msgid "The vinyl storage engine has a scheduler which does compaction. When vinyl is low on available memory, the compaction scheduler may be unable to keep up with incoming update requests. In that situation, queries may time out after ``vinyl_timeout`` seconds. This should rarely occur, since normally vinyl would throttle inserts when it is running low on compaction bandwidth."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:138
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:47
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:75
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:93
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:108
#: ../doc/1.7/reference/configuration/cfg_logging.rst:132
#: ../doc/1.7/reference/configuration/cfg_networking.rst:13
#: ../doc/1.7/reference/configuration/cfg_storage.rst:28
#: ../doc/1.7/reference/configuration/cfg_storage.rst:67
#: ../doc/1.7/reference/configuration/cfg_storage.rst:149
msgid "Type: float"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:139
msgid "Default: 60"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:146
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:156
msgid "A directory where write-ahead log (.xlog) files are stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different values, so that write-ahead log files and snapshot files can be stored on different disks. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:170
msgid "A directory where database working files will be stored. The server instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. Can be relative to the current directory. If not specified, defaults to the current directory. Other directory parameters may be relative to ``work_dir``, for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:176
msgid ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:184
msgid "will put xlog files in ``/home/user/A/B``, snapshot files in ``/home/user/A/C``, and all other files or subdirectories in ``/home/user/A``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:196
msgid "The maximum number of threads to use during execution of certain internal processes (currently :ref:`socket.getaddrinfo() <socket-getaddrinfo>` and :ref:`coio_call() <c_api-coio-coio_call>`)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:201
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:32
#: ../doc/1.7/reference/configuration/cfg_logging.rst:28
#: ../doc/1.7/reference/configuration/cfg_networking.rst:30
#: ../doc/1.7/reference/configuration/cfg_replication.rst:54
#: ../doc/1.7/reference/configuration/cfg_replication.rst:76
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:58
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:87
#: ../doc/1.7/reference/configuration/cfg_storage.rst:41
#: ../doc/1.7/reference/configuration/cfg_storage.rst:53
#: ../doc/1.7/reference/configuration/cfg_storage.rst:77
#: ../doc/1.7/reference/configuration/cfg_storage.rst:90
#: ../doc/1.7/reference/configuration/cfg_storage.rst:100
#: ../doc/1.7/reference/configuration/cfg_storage.rst:112
#: ../doc/1.7/reference/configuration/cfg_storage.rst:124
#: ../doc/1.7/reference/configuration/cfg_storage.rst:137
#: ../doc/1.7/reference/configuration/cfg_storage.rst:160
#: ../doc/1.7/reference/configuration/cfg_storage.rst:171
msgid "Type: integer"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:202
msgid "Default: 4"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:195
msgid "Configuring the storage"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:1
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:2
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:3
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:4
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:5
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:6
msgid ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:7
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:8
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:9
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:10
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:11
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:12
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:13
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:19
msgid "How much memory Tarantool allocates to actually store tuples, in bytes. When the limit is reached, :ref:`INSERT <box_space-insert>` or :ref:`UPDATE <box_space-insert>` requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. The server does not go beyond the ``memtx_memory`` limit to allocate tuples, but there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the ``memtx_memory`` limit."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:29
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:36
msgid "Size of the largest allocation unit, in bytes, for the memtx storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:42
#: ../doc/1.7/reference/configuration/cfg_storage.rst:91
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:49
msgid "Size of the smallest allocation unit, in bytes. It can be decreased if most of the tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:54
msgid "Default: 16"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:61
msgid "Bloom filter false positive rate -- the suitable probability of the `bloom filter <https://en.wikipedia.org/wiki/Bloom_filter>`_ to give a wrong result. The ``vinyl_bloom_fpr`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:68
msgid "Default = 0.05"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:75
msgid "The maximal cache size for the vinyl storage engine, in bytes."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:78
#: ../doc/1.7/reference/configuration/cfg_storage.rst:101
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:85
msgid "Size of the largest allocation unit, in bytes, for the vinyl storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:98
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:108
msgid "Page size, in bytes. Page is a read/write unit for vinyl disk operations. The ``vinyl_page_size`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:113
msgid "Default = 8 * 1024 = 8192"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:120
msgid "The maximal range size for vinyl, in bytes. The ``vinyl_range_size`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:125
msgid "Default = 1024 * 1024 * 1024 = 1073741824"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:132
msgid "The maximal number of runs per level in vinyl LSM tree. If this number is exceeded, a new level is created. The ``vinyl_run_count_per_level`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:138
#: ../doc/1.7/reference/configuration/cfg_storage.rst:172
msgid "Default = 2"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:145
msgid "Ratio between the sizes of different levels in the LSM tree. The ``vinyl_run_size_ratio`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:150
msgid "Default = 3.5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:157
msgid "The maximum number of read threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:161
msgid "Default = 1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:168
msgid "The maximum number of write threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:203
msgid "Checkpoint daemon"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:4
msgid "The checkpoint daemon is a fiber which is constantly running. At intervals, it may make new :ref:`snapshot (.snap) files <index-box_persistence>` and then may delete old snapshot files."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:8
msgid "If the checkpoint daemon deletes an old snapshot file, then it will also delete any :ref:`write-ahead log (.xlog) <internals-wal>` files which are older than the snapshot file and which contain information that is present in the snapshot file. It will also delete obsolete vinyl ``.run`` files."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:13
msgid "The :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` configuration settings determine how long the intervals are, and how many snapshots should exist before deletions occur."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:20
msgid "The checkpoint daemon **will not delete** a file if:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:22
msgid "a **backup** is ongoing and the file has not been backed up (see :ref:`\"Hot backup\" <admin-backups-hot_backup_vinyl_memtx>`), or"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:25
msgid "**replication** is ongoing and the file has not been relayed to a replica (see :ref:`\"Replication architecture\" <replication-architecture>`),"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:28
msgid "a replica is connecting, or"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:30
msgid "a replica has fallen behind. The progress of each replica is tracked; if a replica's position is far from being up to date, then the server stops to give it a chance to catch up. If an administrator concludes that a replica is permanently down, then the correct procedure is to restart the server, or (preferably) :ref:`remove the replica from the cluster <replication-remove_instances>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:42
msgid "The interval between actions by the checkpoint daemon, in seconds. If ``checkpoint_interval`` is set to a value greater than zero, and there is activity which causes change to a database, then the checkpoint daemon will call :ref:`box.snapshot <box-snapshot>` every ``checkpoint_interval`` seconds, creating a new snapshot file each time. If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is disabled."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:51
msgid "box.cfg{checkpoint_interval=60}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:55
msgid "will cause the checkpoint daemon to create a new database snapshot once per minute, if there is activity."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:59
msgid "Default: 3600 (one hour)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:66
msgid "The maximum number of snapshots that may exist on the :ref:`memtx_dir <cfg_basic-memtx_dir>` directory before the checkpoint daemon will delete old snapshots. If ``checkpoint_count`` equals zero, then the checkpoint daemon does not delete old snapshots. For example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:72
msgid ""
"box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:79
msgid "will cause the checkpoint daemon to create a new snapshot each hour until it has created ten snapshots. After that, it will delete the oldest snapshot (and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:83
msgid "Remember that, as noted earlier, snapshots will not be deleted if replication is ongoing and the file has not been relayed to a replica. Therefore ``checkpoint_count`` has no effect unless all replicas are alive."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:76
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:88
msgid "Default: 2"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:209
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:11
msgid "If ``force_recovery`` equals true, Tarantool tries to continue if there is an error while reading a :ref:`snapshot file<index-box_persistence>` (at server instance start) or a :ref:`write-ahead log file<internals-wal>` (at server instance start or when applying an update at a replica): skips invalid records, reads as much data as possible and re-builds the file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:17
msgid "Otherwise, Tarantool aborts recovery on read errors."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:20
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:56
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:67
#: ../doc/1.7/reference/configuration/cfg_logging.rst:121
msgid "Default: true"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:27
msgid "How many log records to store in a single write-ahead log file. When this limit is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:33
msgid "Default: 500000"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:40
msgid "Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes per second it can write to disk. The same can be achieved by splitting :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>` locations and moving snapshots to a separate disk."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:49
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:65
#: ../doc/1.7/reference/configuration/cfg_logging.rst:30
#: ../doc/1.7/reference/configuration/cfg_logging.rst:134
#: ../doc/1.7/reference/configuration/cfg_logging.rst:175
#: ../doc/1.7/reference/configuration/cfg_networking.rst:15
#: ../doc/1.7/reference/configuration/cfg_networking.rst:32
#: ../doc/1.7/reference/configuration/cfg_replication.rst:42
#: ../doc/1.7/reference/configuration/cfg_replication.rst:56
#: ../doc/1.7/reference/configuration/cfg_replication.rst:78
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:55
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:57
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:58
msgid "``write``: :ref:`fibers <fiber-fibers>` wait for their data to be written to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:60
msgid "``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:`write(2)`;"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:64
msgid "Default: \"write\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:71
msgid "Number of seconds between periodic scans of the write-ahead-log file directory, when checking for changes to write-ahead-log files for the sake of :ref:`replication <replication>` or :ref:`hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:217
msgid "Hot standby"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:3
msgid "Whether to start the server in **hot standby** mode."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:5
msgid "Hot standby is a feature which provides a simple form of failover without :ref:`replication <replication>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:8
msgid "The expectation is that there will be two instances of the server using the same configuration. The first one to start will be the \"primary\" instance. The second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:12
msgid "To initiate the standby instance, start a second instance of the Tarantool server on the same computer with the same :ref:`box.cfg <box_introspection-box_cfg>` configuration settings -- including the same directories and same non-null URIs -- and with the additional configuration setting ``hot_standby = true``. Expect to see a notification ending with the words ``I> Entering hot standby mode``. This is fine. It means that the standby instance is ready to take over if the primary instance goes down."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:22
msgid "The standby instance will initialize and will try to take a lock on :ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary instance has made a lock on ``wal_dir``. So the standby instance goes into a loop, reading the write ahead log which the primary instance is writing (so the two instances are always in sync), and trying to take the lock. If the primary instance goes down for any reason, the lock will be released. In this case, the standby instance will succeed in taking the lock, will connect on the :ref:`listen <cfg_basic-listen>` address and will become the primary instance. Expect to see a notification ending with the words ``I> ready to accept requests``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:35
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:37
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:39
msgid "if :ref:`wal_dir_rescan_delay = a large number <cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and FreeBSD); on these platforms, it is designed so that the loop repeats every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:43
msgid "if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it is designed to work with ``wal_mode = 'write'`` or ``wal_mode = 'fsync'``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:45
msgid "for spaces created with :ref:`engine = 'vinyl' <box_schema-space_create>`; it is designed to work for spaces created with ``engine = 'memtx'``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:1
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:2
msgid ":ref:`replication_timeout <cfg_replication-replication_timeout>`"
msgstr ":ref:`replication_timeout <cfg_replication-replication_timeout>`"

#: ../doc/1.7/reference/configuration/cfg_replication.rst:3
msgid ":ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`"
msgstr ":ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`"

#: ../doc/1.7/reference/configuration/cfg_replication.rst:4
msgid ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"
msgstr ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"

#: ../doc/1.7/reference/configuration/cfg_replication.rst:5
msgid ":ref:`instance_uuid <cfg_replication-instance_uuid>`"
msgstr ":ref:`instance_uuid <cfg_replication-instance_uuid>`"

#: ../doc/1.7/reference/configuration/cfg_replication.rst:11
msgid "If ``replication`` is not an empty string, the instance is considered to be a Tarantool :ref:`replica <replication>`. The replica will try to connect to the master specified in ``replication`` with a :ref:`URI <index-uri>` (Universal Resource Identifier), for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:16
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:18
msgid "If there is more than one replication source in a replica set, specify an array of URIs, for example (replace 'uri' and 'uri2' in this example with valid URIs):"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:22
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:24
msgid "If one of the URIs is \"self\" -- that is, if one of the URIs is for the instance where ``box.cfg{}`` is being executed on -- then it is ignored. Thus it is possible to use the same ``replication`` specification on multiple server instances, as shown in :ref:`these examples <replication-bootstrap>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:30
msgid "The default user name is 'guest'."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:32
msgid "A read-only replica does not accept data-change requests on the :ref:`listen <cfg_basic-listen>` port."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:35
msgid "The ``replication`` parameter is dynamic, that is, to enter master mode, simply set ``replication`` to an empty string and issue:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:38
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"

#: ../doc/1.7/reference/configuration/cfg_replication.rst:48
msgid "A replica sends heartbeat messages to the master every second, and the master is programmed to reconnect automatically if it doesn’t see heartbeat messages more often than ``replication_timeout`` seconds."
msgstr "Реплика отправляет сообщения контрольного сигнала на мастер каждую секунду, и мастер запрограммирован на автоматическое переподключение, если он не получает сообщения контрольного сигнала дольше количества секунд, указанного в ``replication_timeout``."

#: ../doc/1.7/reference/configuration/cfg_replication.rst:52
msgid "See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:55
msgid "Default: 1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:62
msgid "By default a replica will try to connect to all the masters, or it will not start. (The default is recommended so that all replicas will receive the same replica set UUID.)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:66
msgid "However, by specifying ``replication_connect_quorum = N``, where N is a number greater than or equal to zero, users can state that the replica only needs to connect to N masters."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:70
#: ../doc/1.7/reference/configuration/cfg_replication.rst:119
#: ../doc/1.7/reference/configuration/cfg_replication.rst:141
#: ../doc/1.7/reference/reference_lua/socket.rst:213
msgid "Example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:72
msgid "box.cfg{replication_connect_quorum=2}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:84
msgid "As described in section :ref:`\"Replication architecture\" <replication-architecture>`, each replica set is identified by a `universally unique identifier <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ called **replica set UUID**, and each instance is identified by an **instance UUID**."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:91
msgid "Ordinarily it is sufficient to let the system generate and format the UUID strings which will be permanently stored."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:94
msgid "However, some administrators may prefer to store Tarantool configuration information in a central repository, for example `Apache ZooKeeper <https://zookeeper.apache.org>`_. Such administrators can assign their own UUID values for either -- or both -- instances (:ref:`instance_uuid <cfg_replication-instance_uuid>`) and replica set (``replicaset_uuid``), when starting up for the first time."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:101
msgid "General rules:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:103
msgid "The values must be true unique identifiers, not shared by other instances or replica sets within the common infrastructure."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:106
msgid "The values must be used consistently, not changed after initial setup (the initial values are stored in :ref:`snapshot files <index-box_persistence>` and are checked whenever the system is restarted)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:110
msgid "The values must comply with `RFC 4122 <https://tools.ietf.org/html/rfc4122>`_. The `nil UUID <https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ is not allowed."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:114
msgid "The UUID format includes sixteen octets represented as 32 hexadecimal (base 16) digits, displayed in five groups separated by hyphens, in the form ``8-4-4-4-12`` for a total of 36 characters (32 alphanumeric characters and four hyphens)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:121
msgid "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:133
msgid "For replication administration purposes, it is possible to set the `universally unique identifiers <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ of the instance (``instance_uuid``) and the replica set (``replicaset_uuid``), instead of having the system generate the values."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:138
msgid "See the description of :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>` parameter for details."
msgstr "Для получения подробной информации см. описание параметра :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`."

#: ../doc/1.7/reference/configuration/cfg_replication.rst:143
msgid "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"
msgstr "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"

#: ../doc/1.7/reference/configuration/index.rst:229
msgid "Networking"
msgstr "Работа с сетями"

#: ../doc/1.7/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:2
msgid ":ref:`readahead <cfg_networking-readahead>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:8
msgid "The instance will sleep for io_collect_interval seconds between iterations of the event loop. Can be used to reduce CPU load in deployments in which the number of client connections is large, but requests are not so frequent (for example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:21
msgid "The size of the read-ahead buffer associated with a client connection. The larger the buffer, the more memory an active connection consumes and the more requests can be read from the operating system buffer in a single system call. The rule of thumb is to make sure the buffer can contain at least a few dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size should be increased. If batched request processing is not used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:31
msgid "Default: 16320"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:4
msgid ":ref:`log <cfg_logging-log>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:5
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:7
msgid ":ref:`log_format <cfg_logging-log_format>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:13
msgid "What level of detail the :ref:`log <admin-logs>` will have. There are seven levels:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:15
#: ../doc/1.7/reference/reference_lua/log.rst:65
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:16
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:17
#: ../doc/1.7/reference/reference_lua/log.rst:67
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:18
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:19
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:20
msgid "6 – ``VERBOSE``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:21
msgid "7 – ``DEBUG``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:23
msgid "By setting log_level, one can enable logging of all classes below or equal to the given level. Tarantool prints its logs to the standard error stream by default, but this can be changed with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:29
msgid "Default: 5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:32
msgid "Warning: prior to Tarantool 1.7.5 there were only six levels and ``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring repetitive events which would cause too much log writing if ``INFO`` were used instead."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:41
msgid "By default, Tarantool sends the log to the standard error stream (``stderr``). If ``log`` is specified, Tarantool sends the log to a file, or to a pipe, or to the system logger."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:45
#: ../doc/1.7/reference/configuration/cfg_logging.rst:57
#: ../doc/1.7/reference/configuration/cfg_logging.rst:71
msgid "Example setting:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:47
msgid ""
"box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file: tarantool.log'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:53
msgid "This will open the file ``tarantool.log`` for output on the server’s default directory. If the ``log`` string has no prefix or has the prefix \"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:59
msgid ""
"box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:65
msgid "This will start the program `cronolog <https://linux.die.net/man/1/cronolog>`_ when the server starts, and will send all log messages to the standard input (``stdin``) of cronolog. If the ``log`` string begins with '|' or has the prefix \"pipe:\", then the string is interpreted as a Unix `pipeline <https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:73
msgid ""
"box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:81
msgid "If the ``log`` string has the prefix \"syslog:\", then the string is interpreted as a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ program which normally is running in the background of any Unix-like platform. One can optionally specify an ``identity``, a ``facility``, or both. The ``identity`` is an arbitrary string, default value = ``tarantool``, which will be placed at the beginning of all messages. The facility is an abbreviation for the name of one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ facilities, default value = ``user``, which tell syslogd where the message should go."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:92
msgid "Possible values for ``facility`` are: auth, authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, local3, local4, local5, local6, local7."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:96
msgid "The ``facility`` setting is currently ignored but will be used in the future."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:98
msgid "When logging to a file, Tarantool reopens the log on `SIGHUP <https://en.wikipedia.org/wiki/SIGHUP>`_. When log is a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:111
msgid "If ``log_nonblock`` equals true, Tarantool does not block on the log file descriptor when it’s not ready for write, and drops the message instead. If :ref:`log_level <cfg_logging-log_level>` is high, and many messages go to the log file, setting ``log_nonblock`` to true may improve logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:117
msgid "This parameter has effect only if the output is going to ``syslog`` or to a pipe."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:128
msgid "If processing a request takes longer than the given value (in seconds), warn about it in the log. Has effect only if :ref:`log_level <cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:133
msgid "Default: 0.5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:140
msgid "Log entries have two possible formats:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:142
msgid "'plain' (the default), or"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:143
msgid "'json' (with more detail and with JSON labels)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:145
msgid "Here is what a log entry looks like after ``box.cfg{log_format='plain'}``:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:147
msgid "2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' configuration option to \"plain\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:151
msgid "Here is what a log entry looks like after ``box.cfg{log_format='json'}``:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:153
msgid ""
"{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:165
msgid "The ``log_format='plain'`` entry has time, process id, cord name, :ref:`fiber_id <fiber_object-id>`, :ref:`fiber_name <fiber_object-name_get>`, :ref:`log level <cfg_logging-log_level>`, and message."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:170
msgid "The ``log_format='json'`` entry has the same things along with their labels, and in addition has the file name and line number of the Tarantool source."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:174
msgid "Default: 'plain'"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:181
msgid "Logging example"
msgstr "Пример записи в журнал"

#: ../doc/1.7/reference/configuration/cfg_logging.rst:183
msgid "This will illustrate how \"rotation\" works, that is, what happens when the server instance is writing to a log and signals are used when archiving it."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:186
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:188
msgid "On Terminal #1: start an interactive Tarantool session, then say the logging will go to `Log_file`, then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:191
msgid ""
"box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:197
msgid "On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:1267
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:205
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:207
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:211
msgid "On Terminal #2: use ``ps`` to find the process ID of the Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:1280
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:218
msgid "On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the Tarantool instance. The result of this is: Tarantool will open `Log_file` again, and the next log message will go to `Log_file`. (The same effect could be accomplished by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:1290
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:228
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:230
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:234
msgid "On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have these lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:1304
msgid ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:243
msgid "and `Log_file` will have"
msgstr ""

#: ../internal after doc/1.7/reference/configuration/cfg_logging.rst:1312
#: padding
msgid ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:241
msgid "Deprecated parameters"
msgstr "Устаревшие параметры"

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:3
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:5
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:6
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:7
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:8
msgid ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-panic_on_snap_error_deprecated>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:9
msgid ":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:10
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:11
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:12
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:13
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:14
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:15
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:16
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:17
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:23
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:101
msgid "**Deprecated**, do not use."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:33
msgid "**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:41
msgid "**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-log_nonblock>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:49
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:63
msgid "**Deprecated** in favor of :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:52
msgid "If there is an error while reading a snapshot file (at server instance start), abort."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:74
msgid "**Deprecated** in favor of :ref:`replication <cfg_replication-replication>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:83
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:86
msgid "How much memory Tarantool allocates to actually store tuples, **in gigabytes**. When the limit is reached, INSERT or UPDATE requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit to allocate tuples, there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:94
msgid "Default: 1.0"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:103
msgid "The multiplier for computing the sizes of memory chunks that tuples are stored in. A lower value may result in less wasted memory depending on the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:109
msgid "Default: 1.1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:116
msgid "**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:125
msgid "**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:134
msgid "**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:142
msgid "**Deprecated** in favor of :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:151
msgid "**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/index.rst:5
msgid "Reference"
msgstr "Справочники"

#: ../doc/1.7/reference/lua_tips.rst:5
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:7
msgid "The Lua syntax for :ref:`data-manipulation functions <index-box_data-operations>` can vary. Here are examples of the variations with ``select()`` requests. The same rules exist for the other data-manipulation functions."
msgstr "Lua-синтаксис в :ref:`функциях управления данными <index-box_data-operations>` может различаться. Далее приводятся варианты таких различий на примере запросов ``select()``. Аналогичные правила существуют и для остальных функций."

#: ../doc/1.7/reference/lua_tips.rst:11
msgid "Every one of the examples does the same thing: select a tuple set from a space named 'tester' where the primary-key field value equals 1. For these examples, we assume that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only."
msgstr "В каждом из приведенных примеров выполняются следующие действия: производится выборка по набору кортежей из спейса с именем 'tester', где значение поля, которое соответствует ключу в первичном индексе, равно 1. Также во всех примерах мы принимаем, что числовой идентификатор спейса 'tester' равен 512, но это верно только для нашей тестовой базы."

#: ../doc/1.7/reference/lua_tips.rst:20
msgid "Object reference variations"
msgstr "Способы ссылки на объект"

#: ../doc/1.7/reference/lua_tips.rst:22
msgid "First, there are three **object reference variations**:"
msgstr "Во-первых, есть пять *способов ссылки на объект*:"

#: ../doc/1.7/reference/lua_tips.rst:24
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""
"-- #1 модуль.подмодуль.имя\n"
"        tarantool> box.space.tester:select{1}\n"
"        -- #2 заменить имя буквенной константой в квадратных скобках\n"
"        tarantool> box.space['tester']:select{1}\n"
"        -- #3 использовать переменную для всей ссылки на объект\n"
"        tarantool> s = box.space.tester\n"
"        tarantool> s:select{1}"

#: ../doc/1.7/reference/lua_tips.rst:34
msgid "Examples in this manual usually have the \":samp:`box.space.{tester}:`\" form (#1). However, this is a matter of user preference and all the variations exist in the wild."
msgstr "Для примеров в документации, как правило, используется вариант синтаксиса №1, например \":samp:`box.space.{tester}:`\". Но вы можете с тем же успехом пользоваться любым из пяти описанных выше вариантов."

#: ../doc/1.7/reference/lua_tips.rst:38
msgid "Also, descriptions in this manual use the syntax \"``space_object:``\" for references to objects which are spaces, and \"``index_object:``\" for references to objects which are indexes (for example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr "Также описания в руководстве используют синтаксис типа  \"``space_object:``\" для ссылки на спейсы и \"``index_object:``\" для ссылки на индексы (например, :samp:`box.space.{tester}.index.{primary}:`)."

#: ../doc/1.7/reference/lua_tips.rst:47
msgid "Parameter variations"
msgstr "Способы задания параметров"

#: ../doc/1.7/reference/lua_tips.rst:49
msgid "Then, there are seven **parameter variations**:"
msgstr "Затем есть семь *способов задания параметров*:"

#: ../doc/1.7/reference/lua_tips.rst:51
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""
"-- #1\n"
"        tarantool> box.space.tester:select{1}\n"
"        -- #2\n"
"        tarantool> box.space.tester:select({1})\n"
"        -- #3\n"
"        tarantool> box.space.tester:select(1)\n"
"        -- #4\n"
"        tarantool> box.space.tester.select(box.space.tester,1)\n"
"        -- #5\n"
"        tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"        -- #6\n"
"        tarantool> variable = 1\n"
"        tarantool> box.space.tester:select{variable}\n"
"        -- #7\n"
"        tarantool> variable = {1}\n"
"        tarantool> box.space.tester:select(variable)"

#: ../doc/1.7/reference/lua_tips.rst:70
msgid "Lua allows to omit parentheses ``()`` when invoking a function if its only argument is a Lua table, and we use it sometimes in our examples. This is why ``select{1}`` is equivalent to ``select({1})``. Literal values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may be replaced by variable names, as in examples #6 and #7."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:76
msgid "Although there are special cases where braces can be omitted, they are preferable because they signal \"Lua table\". Examples and descriptions in this manual have the ``{1}`` form. However, this too is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:7
msgid "As well as executing Lua chunks or defining their own functions, you can exploit Tarantool's storage functionality with the ``box`` module and its submodules."
msgstr "Помимо выполнения фрагментов кода на Lua или определения собственных функций, с помощью модуля ``box`` и вложенных модулей можно использовать функции хранилища Tarantool'а."

#: ../doc/1.7/reference/reference_lua/box.rst:10
msgid "The contents of the ``box`` module can be inspected at runtime with ``box``, with no arguments. The ``box`` module contains:"
msgstr "Содержимое модуля ``box`` можно просмотреть во время исполнения кода с помощью команды ``box`` без аргументов. Модуль ``box`` включает в себя следующее:"

#: ../doc/1.7/reference/reference_lua/box.rst:34
msgid "Every submodule contains one or more Lua functions. A few submodules contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr "Каждый вложенный модуль включает в себя одну или более Lua-функций. Несколько вложенных модулей включают в себя элементы класса, а также функции. Функции обеспечивают определение данных (create alter drop), управление данными (insert delete update upsert select replace) и просмотр состояния (просмотр содержимого спейсов, получение доступа к конфигурации сервера)."

#: ../doc/1.7/reference/reference_lua/box_error.rst:3
msgid "Submodule `box.error`"
msgstr "Вложенный модуль `box.error`"

#: ../doc/1.7/reference/reference_lua/box_error.rst:11
msgid "The ``box.error`` function is for raising an error. The difference between this function and Lua's built-in `error <https://www.lua.org/pil/8.3.html>`_ function is that when the error reaches the client, its error code is preserved. In contrast, a Lua error would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:21
msgid "Below is a list of all ``box.error`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:31
msgid ":ref:`box.error() <box_error-error>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:31
msgid "Throw an error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:34
msgid ":ref:`box.error.last() <box_error-last>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:34
msgid "Get a description of the last error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:37
msgid ":ref:`box.error.clear() <box_error-clear>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:37
msgid "Clear the record of errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:43
msgid "When called with a Lua-table argument, the code and reason have any user-desired values. The result will be those values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:51
msgid "When called without arguments, ``box.error()`` re-throws whatever the last error was."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:58
msgid "Emulate a request error, with text based on one of the pre-defined Tarantool errors defined in the file `errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_ in the source tree. Lua constants which correspond to those Tarantool errors are defined as members of ``box.error``, for example ``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:64
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:65
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:69
#, python-format
msgid "the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it includes one \"``%s``\" component which will be replaced with errtext. Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, 'joe')`` will result in an error with the accompanying message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst
msgid "except"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:75
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:79
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:98
msgid "Returns a description of the last error, as a Lua table with five members: \"line\" (number) Tarantool source file line number, \"code\" (number) error's number, \"type\", (string) error's C++ class, \"message\" (string) error's message, \"file\" (string) Tarantool source file. Additionally, if the error is a system error (for example due to a failure in socket or file io), there may be a sixth member: \"errno\" (number) C standard error number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:108
msgid "rtype: table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:114
msgid "Clears the record of errors, so functions like `box.error()` or `box.error.last()` will have no effect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:119
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"  file: /tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:5
msgid "Function `box.once`"
msgstr "Функция `box.once`"

#: ../doc/1.7/reference/reference_lua/box_once.rst:9
msgid "Execute a function, provided it has not been executed before. A passed value is checked to see whether the function has already been executed. If it has been executed before, nothing happens. If it has not been executed before, the function is invoked."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:14
msgid "See an example of using ``box.once()`` while :ref:`bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:17
msgid "If an error occurs inside ``box.once()`` when initializing a database, you can re-execute the failed ``box.once()`` block without stopping the database. The solution is to delete the ``once`` object from the system space :ref:`_schema <box_space-schema>`. Say ``box.space._schema:select{}``, find your ``once`` object there and delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:24
msgid "When ``box.once()`` is used for initialization, it may be useful to wait until the database is in an appropriate state (read-only or read-write). In that case, see the functions in the :ref:`box.ctl submodule <box_ctl>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:28
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:48
msgid "a value that will be checked"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:49
msgid "a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:50
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:5
msgid "Function `box.snapshot`"
msgstr "Функция `box.snapshot`"

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:9
msgid "Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the delayed garbage collection mode for all data. In this mode, tuples which were allocated before the snapshot has started are not freed until the snapshot has finished. To preserve consistency of the primary key, used to iterate over tuples, a copy-on-write technique is employed. If the master process changes part of a primary key, the corresponding process page is split, and the snapshot process obtains an old copy of the page. In effect, the snapshot process uses multi-version concurrency control in order to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:21
msgid "Since a snapshot is written sequentially, one can expect a very high write performance (averaging to 80MB/second on modern disks), which means an average database instance gets saved in a matter of minutes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:27
#, python-format
msgid "As long as there are any changes to the parent index memory through concurrent updates, there are going to be page splits, and therefore you need to have some extra free memory to run this command. 10% of :ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, sufficient. This statement waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:35
msgid "**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process caused a fork, which could cause occasional latency spikes. Starting with Tarantool version 1.6.6, the snapshot process creates a consistent read view and this view is written to the snapshot file by a separate thread (the \"Write Ahead Log\" thread)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:41
msgid "Although ``box.snapshot()`` does not cause a fork, there is a separate fiber which may produce snapshots at regular intervals -- see the discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:47
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""
"tarantool> box.info.version\n"
"        ---\n"
"        - 1.7.0-1216-g73f7154\n"
"        ...\n"
"        tarantool> box.snapshot()\n"
"        ---\n"
"        - ok\n"
"        ...\n"
"        tarantool> box.snapshot()\n"
"        ---\n"
"        - error: can't save snapshot, errno 17 (File exists)\n"
"        ..."

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:62
msgid "Taking a snapshot does not cause the server to start a new write-ahead log. Once a snapshot is taken, old WALs can be deleted as long as all replicated data is up to date. But the WAL which was current at the time ``box.snapshot()`` started must be kept for recovery, since it still contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:68
msgid "An alternative way to save a snapshot is to send a SIGUSR1 signal to the instance. While this approach could be handy, it is not recommended for use in automation: a signal provides no way to find out whether the snapshot was taken successfully or not."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:5
msgid "Module `buffer`"
msgstr "Модуль `buffer`"

#: ../doc/1.7/reference/reference_lua/buffer.rst:7
msgid "The ``buffer`` module returns a dynamically resizable buffer which is solely for use as an option for methods of the :ref:`net.box module <net_box-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:10
msgid "Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` option is used, then the ``net.box`` methods return a raw MsgPack_ string. This saves time on the server, if the client application has its own routine for decoding MsgPack strings."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:20
msgid "a descriptor of a buffer."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:21
#: ../doc/1.7/reference/reference_lua/uuid.rst:61
#: ../doc/1.7/reference/reference_lua/uuid.rst:83
#: ../doc/1.7/reference/reference_lua/uuid.rst:91
msgid "cdata"
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:25
msgid "Assume a Tarantool server is listening on farhost:3301. Assume it has a space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start up a server on localhost:3302 and then use ``net.box`` routines to connect to farhost. Then we create a buffer, and use it as an option for a ``conn.space...select()`` call. The result will be in MsgPack_ format. To show this, we will use :ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the buffer). Thus we do not decode on the remote server, but we do decode on the local server."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:38
msgid ""
"box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:50
msgid "The result of the final request looks like this:"
msgstr "Результат последнего запроса выглядит следующим образом:"

#: ../doc/1.7/reference/reference_lua/buffer.rst:52
msgid ""
"tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/buffer.rst:62
msgid "Before Tarantool version 1.7.7, the function to use for this case is ``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version 1.7.7, ``ibuf_decode`` is deprecated."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:11
msgid "The ``clock`` module returns time values derived from the Posix / C CLOCK_GETTIME_ function or equivalent. Most functions in the module return a number of seconds; functions whose names end in \"64\" return a 64-bit number of nanoseconds."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:20
msgid "Below is a list of all ``clock`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:30
msgid ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:31
msgid "Get the wall clock time in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:35
msgid ":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-time>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:36
msgid "Get the wall clock time in nanoseconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:40
msgid ":ref:`clock.monotonic() <clock-monotonic>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:40
msgid "Get the monotonic time in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:43
msgid ":ref:`clock.monotonic64() <clock-monotonic>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:43
msgid "Get the monotonic time in nanoseconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:46
msgid ":ref:`clock.proc() <clock-proc>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:46
msgid "Get the processor time in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:49
msgid ":ref:`clock.proc64() <clock-proc>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:49
msgid "Get the processor time in nanoseconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:52
msgid ":ref:`clock.thread() <clock-thread>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:52
msgid "Get the thread time in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:55
msgid ":ref:`clock.thread64() <clock-thread>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:55
msgid "Get the thread time in nanoseconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:58
msgid ":ref:`clock.bench() <clock-bench>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:58
msgid "Measure the time a function takes within a processor"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:71
msgid "The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). This is the best function for knowing what the official time is, as determined by the system administrator."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:75
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:76
#: ../doc/1.7/reference/reference_lua/clock.rst:101
#: ../doc/1.7/reference/reference_lua/clock.rst:122
#: ../doc/1.7/reference/reference_lua/clock.rst:143
msgid "number or number64"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:80
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:86
msgid "See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:94
msgid "The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock time but is not affected by changes to or from daylight saving time, or by changes done by a user. This is the best function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:100
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:105
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:116
msgid "The processor time. Derived from C function ``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a CPU."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:121
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:126
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:137
msgid "The thread time. Derived from C function ``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a thread within a CPU."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:142
msgid "seconds or nanoseconds since the transaction processor thread started."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:147
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:157
msgid "The time that a function takes within a processor. This function uses ``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it is not useful for showing actual elapsed time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:161
msgid "function or function reference"
msgstr "функция или ссылка на функцию"

#: ../doc/1.7/reference/reference_lua/clock.rst:162
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:164
msgid "**table**. first element - seconds of CPU time, second element - whatever the function returns."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:169
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:5
msgid "Module `console`"
msgstr "Модуль `console`"

#: ../doc/1.7/reference/reference_lua/console.rst:11
msgid "The console module allows one Tarantool instance to access another Tarantool instance, and allows one Tarantool instance to start listening on an :ref:`admin port <admin-security>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:19
msgid "Below is a list of all ``console`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:29
msgid ":ref:`console.connect() <console-connect>`"
msgstr ":ref:`console.connect() <console-connect>`"

#: ../doc/1.7/reference/reference_lua/console.rst:29
msgid "Connect to an instance"
msgstr "Подключение к экземпляру"

#: ../doc/1.7/reference/reference_lua/console.rst:32
msgid ":ref:`console.listen() <console-listen>`"
msgstr ":ref:`console.listen() <console-listen>`"

#: ../doc/1.7/reference/reference_lua/console.rst:32
msgid "Listen for incoming requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:35
msgid ":ref:`console.start() <console-start>`"
msgstr ":ref:`console.start() <console-start>`"

#: ../doc/1.7/reference/reference_lua/console.rst:35
msgid "Start the console"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:38
msgid ":ref:`console.ac() <console-ac>`"
msgstr ":ref:`console.ac() <console-ac>`"

#: ../doc/1.7/reference/reference_lua/console.rst:38
msgid "Set the auto-completion flag"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:41
msgid ":ref:`console.delimiter() <console-delimiter>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:41
msgid "Set a delimiter"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:51
msgid "Connect to the instance at :ref:`URI <index-uri>`, change the prompt from '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client until the user ends the session or types ``control-D``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:55
msgid "The console.connect function allows one Tarantool instance, in interactive mode, to access another Tarantool instance. Subsequent requests will appear to be handled locally, but in reality the requests are being sent to the remote instance and the local instance is acting as a client. Once connection is successful, the prompt will change and subsequent requests are sent to, and executed on, the remote instance. Results are displayed on the local instance. To return to local mode, enter ``control-D``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:63
msgid "If the Tarantool instance at :samp:`uri` requires authentication, the connection might look something like: ``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:67
msgid "There are no restrictions on the types of requests that can be entered, except those which are due to privilege restrictions -- by default the login to the remote instance is done with user name = 'guest'. The remote instance could allow for this by granting at least one privilege: ``box.schema.user.grant('guest','execute','universe')``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:73
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:76
msgid "Possible errors: the connection will fail if the target Tarantool instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:81
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:95
msgid "Listen on :ref:`URI <index-uri>`. The primary way of listening for incoming requests is via the connection-information string, or URI, specified in ``box.cfg{listen=...}``. The alternative way of listening is via the URI specified in ``console.listen(...)``. This alternative way is called \"administrative\" or simply :ref:`\"admin port\" <admin-security>`. The listening is usually over a local host with a Unix domain socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:102
msgid "the URI of the local instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:104
msgid "The \"admin\" address is the URI to listen on. It has no default value, so it must be specified if connections will occur via an admin port. The parameter is expressed with URI = Universal Resource Identifier format, for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:112
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:133
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:137
msgid "A special use of ``console.start()`` is with :ref:`initialization files <index-init_label>`. Normally, if one starts the Tarantool instance with :samp:`tarantool {initialization file}` there is no console. This can be remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:142
msgid ""
"local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:151
msgid "Set the auto-completion flag. If auto-completion is `true`, and the user is using Tarantool as a client or the user is using Tarantool via ``console.connect()``, then hitting the TAB key may cause tarantool to complete a word automatically. The default auto-completion value is `true`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:160
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:162
msgid "The default end-of-request marker is a newline (line feed). Custom markers are not necessary because Tarantool can tell when a multi-line request has not ended (for example, if it sees that a function declaration does not have an end keyword). Nonetheless for special needs, or for entering multi-line requests in older Tarantool versions, you can change the end-of-request marker. As a result, newline alone is not treated as end of request."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:170
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:172
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:176
msgid ""
"tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."
msgstr ""
"tarantool> console = require('console'); console.delimiter('!')\n"
"      ---\n"
"      ...\n"
"      tarantool> function f ()\n"
"               > statement_1 = 'a'\n"
"               > statement_2 = 'b'\n"
"               > end!\n"
"      ---\n"
"      ...\n"
"      tarantool> console.delimiter('')!\n"
"      ---\n"
"      ..."

#: ../doc/1.7/reference/reference_lua/crypto.rst:5
msgid "Module `crypto`"
msgstr "Модуль `crypto`"

#: ../doc/1.7/reference/reference_lua/crypto.rst:13
msgid "\"Crypto\" is short for \"Cryptography\", which generally refers to the production of a digest value from a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``crypto`` module supports ten types of cryptographic hash functions (AES_, DES_, DSS_, MD4_, MD5_, MDC2_, RIPEMD_, SHA-0_, SHA-1_, SHA-2_). Some of the crypto functionality is also present in the :ref:`digest` module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:24
msgid "Below is a list of all ``crypto`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:34
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:34
msgid "Encrypt a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:37
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:37
msgid "Decrypt a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:40
msgid ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:40
msgid "Get a digest"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:50
msgid "Pass or return a cipher derived from the string, key, and (optionally, sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:53
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:54
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:55
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:56
msgid "des    - des (with 56-bit binary strings using DES, though DES is not recommended)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:59
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:61
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:62
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:63
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:64
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:66
msgid "For more information, read the article about `Encryption Modes`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:70
msgid ""
"crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
"crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:83
msgid "Pass or return a digest derived from the string. The twelve choices of algorithms:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:86
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:87
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:88
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:89
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:90
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:91
msgid "ripemd160 - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:92
msgid "sha - sha (with 160-bit binary strings using SHA-0)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:93
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:94
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:95
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:96
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:97
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:101
msgid ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:108
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:110
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports for all crypto functions.."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:116
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', 'key'))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new()\n"
"c:init()\n"
"c:update('A', 'key')\n"
"c:update('B', 'key')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:140
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:142
msgid "The following functions are equivalent. For example, the ``digest`` function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:145
msgid ""
"crypto.cipher.aes256.cbc.encrypt('string', 'key') == digest.aes256cbc.encrypt('string', 'key')\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha('string') == digest.sha('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:3
msgid "Module `csv`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:11
msgid "The ``csv`` module handles records formatted according to Comma-Separated-Values (CSV) rules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:14
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:16
msgid "Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but not within files,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:18
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:19
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:20
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:21
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:22
msgid "When enclosed by quote marks, commas and line feeds and spaces are treated as ordinary characters, and a pair of quote marks \"\" is treated as a single quote mark."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:28
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:30
msgid ":samp:`delimiter = {string}` (default: comma) -- single-byte character to designate end-of-field"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:32
msgid ":samp:`quote_char = {string}` (default: quote mark) -- single-byte character to designate encloser of string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:34
msgid ":samp:`chunk_size = {number}` (default: 4096) -- number of characters to read at once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:36
msgid ":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to skip at the start (usually for a header)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:43
msgid "Below is a list of all ``csv`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:53
msgid ":ref:`csv.load() <csv-load>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:53
msgid "Load a CSV file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:56
msgid ":ref:`csv.dump() <csv-dump>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:56
msgid "Transform input into a CSV-formatted string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:59
msgid ":ref:`csv.iterate() <csv-iterate>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:59
msgid "Iterate over CSV records"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:67
msgid "Get CSV-formatted input from ``readable`` and return a table as output. Usually ``readable`` is either a string or a file opened for reading. Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:71
msgid "a string, or any object which has a read() method, formatted according to the CSV rules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:73
#: ../doc/1.7/reference/reference_lua/csv.rst:199
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:74
msgid "loaded_value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:79
msgid "Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:82
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:94
msgid "Readable string contains 2-byte character = Cyrillic Letter Palochka: (This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:97
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:104
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:106
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:114
msgid "Readable file :file:`./file.csv` contains two CSV records. Explanation of ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and example respectively:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:118
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:145
msgid "Get table input from ``csv-table`` and return a CSV-formatted string as output. Or, get table input from ``csv-table`` and put the output in ``writable``. Usually :samp:`{options}` is not specified. Usually ``writable``, if specified, is a file opened for writing. :ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-load>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:151
#: ../doc/1.7/reference/reference_lua/csv.rst:197
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:153
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:154
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:156
msgid "dumped_value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:157
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:161
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:163
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:175
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:177
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:193
msgid "Form a Lua iterator function for going through CSV records one field at a time. Use of an iterator is strongly recommended if the amount of data is large (ten or more megabytes)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:201
msgid "Lua iterator function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:202
msgid "iterator function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:206
msgid ":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() <csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is a function which is the same as the :ref:`csv.load() <csv-load>` function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:211
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:5
msgid "Debug facilities"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:11
msgid "Tarantool users can benefit from built-in debug facilities that are part of:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:13
msgid "Lua (`debug <https://www.lua.org/manual/5.1/manual.html#5.9>`_ library, see details below) and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:15
msgid "LuaJit (`debug.* <http://luajit.org/extensions.html>`_ functions)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:19
msgid "The ``debug`` library provides an interface for debugging Lua programs. All functions in this library reside in the ``debug`` table. Those functions that operate on a thread have an optional first parameter that specifies the thread to operate on. The default is always the current thread."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:26
msgid "This library should be used only for debugging and profiling and not as a regular programming tool, as the functions provided here can take too long to run. Besides, several of these functions can compromise otherwise secure code."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:35
msgid "Below is a list of all ``debug`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:45
msgid ":ref:`debug.debug() <debug-debug>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:45
msgid "Enter an interactive mode"
msgstr "Вход в интерактивный режим"

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:48
msgid ":ref:`debug.getfenv() <debug-getfenv>`"
msgstr ":ref:`debug.getfenv() <debug-getfenv>`"

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:48
msgid "Get an object's environment"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:51
msgid ":ref:`debug.gethook() <debug-gethook>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:51
msgid "Get a thread's current hook settings"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:54
msgid ":ref:`debug.getinfo() <debug-getinfo>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:54
msgid "Get information about a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:57
msgid ":ref:`debug.getlocal() <debug-getlocal>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:57
msgid "Get a local variable's name and value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:60
msgid ":ref:`debug.getmetatable() <debug-getmetatable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:60
msgid "Get an object's metatable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:63
msgid ":ref:`debug.getregistry() <debug-getregistry>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:63
msgid "Get the registry table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:66
msgid ":ref:`debug.getupvalue() <debug-getupvalue>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:66
msgid "Get an upvalue's name and value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:69
msgid ":ref:`debug.setfenv() <debug-setfenv>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:69
msgid "Set an object's environment"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:72
msgid ":ref:`debug.sethook() <debug-sethook>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:72
msgid "Set a given function as a hook"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:75
msgid ":ref:`debug.setlocal() <debug-setlocal>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:75
msgid "Assign a value to a local variable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:78
msgid ":ref:`debug.setmetatable() <debug-setmetatable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:78
msgid "Set an object's metatable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:81
msgid ":ref:`debug.setupvalue() <debug-setupvalue>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:81
msgid "Assign a value to an upvalue"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:84
msgid ":ref:`debug.traceback() <debug-traceback>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:84
msgid "Get a traceback of the call stack"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:92
msgid "Enters an interactive mode and runs each string that the user types in. The user can, among other things, inspect global and local variables, change their values and evaluate expressions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:96
msgid "Enter ``cont`` to exit this function, so that the caller can continue its execution."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:101
msgid "Commands for ``debug.debug()`` are not lexically nested within any function and so have no direct access to local variables."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:108
msgid "object to get the environment of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:111
msgid "the environment of the ``object``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:117
msgid "the current hook settings of the ``thread`` as three values:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:119
msgid "the current hook function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:120
msgid "the current hook mask"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:121
msgid "the current hook count as set by the ``debug.sethook()`` function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:127
msgid "function to get information on"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:129
msgid "what information on the ``function`` to return"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:131
msgid "a table with information about the ``function``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:133
msgid "You can pass in a ``function`` directly, or you can give a number that specifies a function running at level ``function`` of the call stack of the given ``thread``: level 0 is the current function (``getinfo()`` itself), level 1 is the function that called ``getinfo()``, and so on. If ``function`` is a number larger than the number of active functions, ``getinfo()`` returns ``nil``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:140
msgid "The default for ``what`` is to get all information available, except the table of valid lines. If present, the option ``f`` adds a field named ``func`` with the function itself. If present, the option ``L`` adds a field named ``activelines`` with the table of valid lines."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:149
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:226
msgid "level of the stack"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:150
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:227
msgid "index of the local variable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:152
msgid "the name and the value of the local variable with the index ``local`` of the function at level ``level`` of the stack or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:159
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:237
msgid "You can call ``debug.getinfo()`` to check whether the level is valid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:165
msgid "object to get the metatable of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:168
msgid "a metatable of the ``object`` or ``nil`` if it does not have a metatable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:175
msgid "the registry table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:181
msgid "function to get the upvalue of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:182
#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:257
msgid "index of the function upvalue"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:184
msgid "the name and the value of the upvalue with the index ``up`` of the function ``func`` or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:192
msgid "Sets the environment of the ``object`` to the ``table``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:194
msgid "object to change the environment of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:196
msgid "table to set the object environment to"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:198
msgid "the ``object``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:204
msgid "Sets the given function as a hook.  When called without arguments, turns the hook off."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:207
msgid "function to set as a hook"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:208
msgid "describes when the ``hook`` will be called; may have the following values:  * ``c`` - the ``hook`` is called every time Lua calls a function * ``r`` - the ``hook`` is called every time Lua returns from a function * ``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:208
msgid "describes when the ``hook`` will be called; may have the following values:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:211
msgid "``c`` - the ``hook`` is called every time Lua calls a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:212
msgid "``r`` - the ``hook`` is called every time Lua returns from a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:213
msgid "``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:215
msgid "describes when the ``hook`` will be called; when different from zero, the ``hook`` is called after every ``count`` instructions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:223
msgid "Assigns the value ``value`` to the local variable with the index ``local`` of the function at level ``level`` of the stack."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:228
msgid "value to assign to the local variable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:231
msgid "the name of the local variable or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:243
msgid "Sets the metatable of the ``object`` to the ``table``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:245
msgid "object to change the metatable of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:247
msgid "table to set the object metatable to"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:253
msgid "Assigns the value ``value`` to the upvalue with the index ``up`` of the function ``func``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:256
msgid "function to set the upvalue of"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:258
msgid "value to assign to the function upvalue"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:261
msgid "the name of the upvalue or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:268
msgid "an optional message prepended to the traceback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:269
msgid "specifies at which level to start the traceback (default is 1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/debug_facilities.rst:272
msgid "a string with a traceback of the call stack"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:5
msgid "Module `digest`"
msgstr "Модуль `digest`"

#: ../doc/1.7/reference/reference_lua/digest.rst:13
msgid "A \"digest\" is a value which is returned by a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``digest`` module supports several types of cryptographic hash functions (AES_, MD4_, MD5_, SHA-0_, SHA-1_, SHA-2_, PBKDF2_) as well as a checksum function (CRC32_), two functions for base64_, and two non-cryptographic hash functions (guava_, murmur_). Some of the digest functionality is also present in the :ref:`crypto <crypto>` module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:25
msgid "Below is a list of all ``digest`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:35
msgid ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:35
msgid "Encrypt a string using AES"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:38
msgid ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:38
msgid "Decrypt a string using AES"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:41
msgid ":ref:`digest.md4() <digest-md4>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:41
msgid "Get a digest made with MD4"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:44
msgid ":ref:`digest.md4_hex() <digest-md4_hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:44
msgid "Get a hexadecimal digest made with MD4"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:47
msgid ":ref:`digest.md5() <digest-md5>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:47
msgid "Get a digest made with MD5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:50
msgid ":ref:`digest.md5_hex() <digest-md5_hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:50
msgid "Get a hexadecimal digest made with MD5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:53
msgid ":ref:`digest.pbkdf2() <digest-pbkdf2>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:53
msgid "Get a digest made with PBKDF2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:56
msgid ":ref:`digest.sha() <digest-sha>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:56
msgid "Get a digest made with SHA-0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:59
msgid ":ref:`digest.sha_hex() <digest-sha_hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:59
msgid "Get a hexadecimal digest made with SHA-0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:62
msgid ":ref:`digest.sha1() <digest-sha1>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:62
msgid "Get a digest made with SHA-1"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:65
msgid ":ref:`digest.sha1_hex() <digest-sha1_hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:65
msgid "Get a hexadecimal digest made with SHA-1"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:68
msgid ":ref:`digest.sha224() <digest-sha224>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:68
msgid "Get a 224-bit digest made with SHA-2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:71
msgid ":ref:`digest.sha224_hex() <digest-sha224_hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:71
msgid "Get a 56-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:74
msgid ":ref:`digest.sha256() <digest-sha256>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:74
msgid "Get a 256-bit digest made with SHA-2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:77
msgid ":ref:`digest.sha256_hex() <digest-sha256_hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:77
msgid "Get a 64-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:80
msgid ":ref:`digest.sha384() <digest-sha384>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:80
msgid "Get a 384-bit digest made with SHA-2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:83
msgid ":ref:`digest.sha384_hex() <digest-sha384_hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:83
msgid "Get a 96-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:86
msgid ":ref:`digest.sha512() <digest-sha512>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:86
msgid "Get a 512-bit digest made with SHA-2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:89
msgid ":ref:`digest.sha512_hex() <digest-sha512_hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:89
msgid "Get a 128-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:92
msgid ":ref:`digest.base64_encode() <digest-base64_encode>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:92
msgid "Encode a string to Base64"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:95
msgid ":ref:`digest.base64_decode() <digest-base64_decode>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:95
msgid "Decode a Base64-encoded string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:98
msgid ":ref:`digest.urandom() <digest-urandom>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:98
msgid "Get an array of random bytes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:101
msgid ":ref:`digest.crc32() <digest-crc32>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:101
msgid "Get a 32-bit checksum made with CRC32"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:104
msgid ":ref:`digest.crc32.new() <digest-crc32_new>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:104
msgid "Initiate incremental CRC32"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:107
msgid ":ref:`digest.guava() <digest-guava>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:107
msgid "Get a number made with a consistent hash"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:110
msgid ":ref:`digest.murmur() <digest-murmur>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:110
msgid "Get a digest made with MurmurHash"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:113
msgid ":ref:`digest.murmur.new() <digest-murmur_new>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:113
msgid "Initiate incremental MurmurHash"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:122
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:128
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:134
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:140
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:146
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:152
msgid "Returns binary string = digest made with PBKDF2. |br| For effective encryption the ``iterations`` value should be at least several thousand. The ``digest-length`` value determines the length of the resulting binary string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:161
msgid "Returns 160-bit binary string = digest made with SHA-0. |br| Not recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:168
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:174
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:180
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:186
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:192
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:198
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:204
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:210
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:216
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:222
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:228
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:234
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:238
msgid "``nopad`` -- result must not include '=' for padding at the end,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:239
msgid "``nowrap`` -- result must not include line feed for splitting lines after 72 characters,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:241
msgid "``urlsafe`` -- result must not include '=' or line feed, and may contain '-' or '_' instead of '+' or '/' for positions 62 and 63 in the index table."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:245
msgid "Options may be ``true`` or ``false``, the default value is ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:249
msgid "digest.base64_encode(string_variable,{nopad=true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:257
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:263
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:269
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:271
msgid "The ``crc32`` and ``crc32_update`` functions use the `CRC-32C (Castagnoli)`_ polynomial value: ``0x1EDC6F41`` / ``4812730177``. If it is necessary to be compatible with other checksum functions in other programming languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:276
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:278
msgid ""
">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:285
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:287
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => 0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:294
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:302
msgid "Initiates incremental crc32. See :ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:309
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:311
msgid "The guava function uses the `Consistent Hashing`_ algorithm of the Google guava library. The first parameter should be a hash code; the second parameter should be the number of buckets; the returned value will be an integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:316
msgid ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:327
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:333
msgid "Initiates incremental MurmurHash. See :ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:340
msgid "Incremental methods in the ``digest`` module"
msgstr "Инкрементальные методы в модуле ``digest``"

#: ../doc/1.7/reference/reference_lua/digest.rst:342
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:348
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:370
msgid "In the following example, the user creates two functions, ``password_insert()`` which inserts a SHA-1_ digest of the word \"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` which requires input of a password."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:374
msgid ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:400
msgid "If a later user calls the ``password_check()`` function and enters the wrong password, the result is an error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:403
msgid ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:5
msgid "Database error codes"
msgstr "Коды ошибок от базы данных"

#: ../doc/1.7/reference/reference_lua/errcodes.rst:7
msgid "In the current version of the binary protocol, error messages, which are normally more descriptive than error codes, are not present in server responses. The actual message may contain a file name, a detailed reason or operating system error code. All such messages, however, are logged in the error log. Below are general descriptions of some popular codes. A complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:18
msgid "**List of error codes**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:24
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:24
msgid "(In replication) A server instance cannot modify data unless it is a master."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:27
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:27
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:30
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:30
msgid "Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has been reached."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:34
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:34
msgid "Failed to write to disk. May mean: failed to record a change in the write-ahead log. Some sort of disk error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:38
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:38
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:41
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:41
msgid "The specified space does not exist."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:44
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:44
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:47
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:47
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:50
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:50
msgid "The recursion limit was reached when creating a new fiber. This usually indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:55
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:55
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:58
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:58
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:64
msgid "Handling errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:66
msgid "Here are some procedures that can make Lua functions more robust when there are errors, particularly database errors."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:69
msgid "Invoke with pcall."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "Take advantage of Lua's mechanisms for `\"Error handling and exceptions\" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, instead of simply invoking with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ":samp:`box.space.{имя-спейса}:{имя-функции}()`"

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-name}) ...`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "For some Tarantool box functions, pcall also returns error details including a file-name and line-number within Tarantool's source code. This can be seen by unpacking. For example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr "``x, y = pcall(function() box.schema.space.create('') end)``"

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "``y:unpack()``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:84
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:87
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:89
msgid "To make a new error and pass it on, the box.error module provides :ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:92
msgid "To find the last error, the box.error module provides :ref:`box.error.last() <box_error-last>`. (There is also a way to find the text of the last operating-system error for certain functions -- :ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:97
msgid "Log."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:99
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:101
msgid "And filter messages that are automatically generated, with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:105
msgid "Generally, for Tarantool built-in functions which are designed to return objects: the result will be an object, or nil, or `a Lua error <https://www.lua.org/pil/8.3.html>`_. For example consider the :ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:123
msgid "After a function call that might fail, like fio.open() above, it is common to see syntax like ``if not f then ...`` or ``if f == nil then ...``, which check for common failures. But if there had been a syntax error, for example fio.opex instead of fio.open, then there would have been a Lua error and f would not have been changed. If checking for such an obvious error had been a concern, the programmer would probably have used pcall()."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:133
msgid "All functions in Tarantool modules should work this way, unless the manual explicitly says otherwise."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:5
msgid "Module `errno`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:13
msgid "The ``errno`` module is typically used within a function or within a Lua program, in association with a module whose functions can return operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:21
msgid "Below is a list of all ``errno`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:31
msgid ":ref:`errno() <errno-errno>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:31
msgid "Get an error number for the last OS-related function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:34
msgid ":ref:`errno.strerror() <errno-strerror>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:34
msgid "Get an error message for the corresponding error number"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:42
msgid "Return an error number for the last operating-system-related function, or 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:51
msgid "Return a string, given an error number. The string will contain the text of the conventional error message for the current operating system. If ``code`` is not supplied, the error message will be for the last operating-system-related function, or 0."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:56
msgid "number of an operating-system error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:62
msgid "This function displays the result of a call to :ref:`fio.open() <fio-open>` which causes error 2 (``errno.ENOENT``). The display includes the error number, the associated error string, and the error name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:66
msgid ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:91
msgid "To see all possible error names stored in the ``errno`` metatable, say ``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:94
msgid ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:11
msgid "With the ``fiber`` module, you can:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:13
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:14
msgid "send and receive messages between different processes (i.e. different connections, sessions, or fibers) via :ref:`channels <fiber_ipc-channel>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:16
msgid "use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, similar to \"condition variables\" and similar to operating-system functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:24
msgid "Below is a list of all ``fiber`` functions and members."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:34
msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:34
msgid "Create and start a fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:37
msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:37
msgid "Get a fiber object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:40
msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:40
msgid "Get a fiber object by ID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:43
msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:43
msgid "Make a fiber go to sleep"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:46
msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:46
msgid "Yield control"
msgstr "Передача управления"

#: ../doc/1.7/reference/reference_lua/fiber.rst:49
msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:49
msgid "Get the current fiber's status"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:52
msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:52
msgid "Get information about all fibers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:55
msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ":ref:`fiber.kill() <fiber-kill>`"

#: ../doc/1.7/reference/reference_lua/fiber.rst:55
#: ../doc/1.7/reference/reference_lua/fiber.rst:73
msgid "Cancel a fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:58
msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:58
msgid "Check if the current fiber has been cancelled"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:61
msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:61
msgid "Get a fiber's ID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:64
msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:64
msgid "Get a fiber's name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:67
msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:67
msgid "Set a fiber's name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:70
msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:70
msgid "Get a fiber's status"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:73
msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:76
msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:76
msgid "Local storage within the fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:79
msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:79
msgid "Get the system time in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:82
msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:82
msgid "Get the system time in microseconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:85
msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:85
msgid "Create a communication channel"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:88
msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:88
msgid "Send a message via a channel"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:91
msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:91
msgid "Close a channel"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:94
msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:94
msgid "Fetch a message from a channel"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:97
msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:97
msgid "Check if a channel is empty"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:100
msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:100
msgid "Count messages in a channel"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:103
msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:103
msgid "Check if a channel is full"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:106
msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:106
msgid "Check if an empty channel has any readers waiting"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:109
msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:109
msgid "Check if a full channel has any writers waiting"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:112
msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:112
msgid "Check if a channel is closed"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:115
msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:115
msgid "Create a condition variable"
msgstr "Создание условной переменной"

#: ../doc/1.7/reference/reference_lua/fiber.rst:118
msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:118
msgid "Make a fiber go to sleep until woken by another fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:121
msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:121
msgid "Wake up a single fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:124
msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:124
msgid "Wake up all fibers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:134
msgid "A **fiber** is a set of instructions which are executed with cooperative multitasking. Fibers managed by the fiber module are associated with a user-supplied function called the *fiber function*."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:138
msgid "A fiber has three possible states: **running**, **suspended** or **dead**. When a fiber is created with :ref:`fiber.create() <fiber-create>`, it is running. When a fiber yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is suspended. When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:143
msgid "All fibers are part of the fiber registry. This registry can be searched with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a numeric identifier."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:147
msgid "A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is advisory — it works only if the runaway fiber calls :ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*`` functions, such as :ref:`box.space...delete() <box_space-delete>` or :ref:`box.space...update() <box_space-update>`, do call :ref:`fiber.testcancel() <fiber-testcancel>` but :ref:`box.space...select{} <box_space-select>` does not. In practice, a runaway fiber can only become unresponsive if it does many computations and does not check whether it has been cancelled."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:158
msgid "The other potential problem comes from fibers which never get scheduled, because they are not subscribed to any events, or because no relevant events occur. Such morphing fibers can be killed with :ref:`fiber.kill() <fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() <fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:165
msgid "Like all Lua objects, dead fibers are garbage collected. The garbage collector frees pool allocator memory owned by the fiber, resets all fiber data, and returns the fiber (now called a fiber carcass) to the fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:170
msgid "A fiber has all the features of a Lua coroutine_ and all the programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:182
msgid "Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:184
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/string.rst
#: ../doc/1.7/reference/reference_lua/table.rst
msgid "Return"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:187
msgid "created fiber object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/string.rst
#: ../doc/1.7/reference/reference_lua/table.rst
msgid "Rtype"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:192
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:211
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:216
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:229
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:231
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:236
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:249
msgid "Yield control to the scheduler and sleep for the specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:252
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:256
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:266
msgid "Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-sleep>`, except that `fiber.sleep(0)` depends on a timer, `fiber.yield()` does not."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:271
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:281
msgid "Return the status of the current fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:283
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:288
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:299
msgid "Return information about all fibers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:301
msgid "number of context switches, backtrace, id, total memory, used memory, name for each fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:307
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:325
msgid "Locate a fiber by its numeric id and cancel it. In other words, :ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:329
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
msgid "Exception"
msgstr "Исключение"

#: ../doc/1.7/reference/reference_lua/fiber.rst:330
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:334
msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:346
msgid "Check if the current fiber has been cancelled and throw an exception if this is the case."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:351
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:364
#: ../doc/1.7/reference/reference_lua/fiber.rst:385
#: ../doc/1.7/reference/reference_lua/fiber.rst:409
#: ../doc/1.7/reference/reference_lua/fiber.rst:429
#: ../doc/1.7/reference/reference_lua/fiber.rst:453
msgid "fiber object, for example the fiber object returned by :ref:`fiber.create <fiber-create>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:366
msgid "id of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:371
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:387
msgid "name of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:392
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:403
msgid "Change the fiber name. By default a Tarantool server's interactive-mode fiber is named 'interactive' and new fibers created due to :ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers distinct names makes it easier to distinguish them when using :ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:411
msgid "the new name of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:417
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:427
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:432
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:437
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:448
msgid "Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber has been cancelled, attempts to operate on it will cause errors, for example :ref:`fiber_object:id() <fiber_object-id>` will cause ``error: the fiber is dead``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:458
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:462
msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program send\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:473
msgid "Local storage within the fiber. The storage can contain any number of named values, subject to memory limitations. Naming may be done with :samp:`{fiber_object}.storage.{name}` or :samp:`{fiber_object}.storage['{name}'].` or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or strings. The storage is garbage-collected when :samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:482
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: fiber.create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:513
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:519
msgid "current system time (in seconds since the epoch) as a Lua number. The time is taken from the event loop clock, which makes this call very cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:523
#: ../doc/1.7/reference/reference_lua/fiber.rst:542
msgid "num"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:527
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:539
msgid "current system time (in microseconds since the epoch) as a 64-bit integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:546
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:558
msgid "Make the function which will be associated with the fiber. This function contains an infinite loop (``while 0 == 0`` is always true). Each iteration of the loop adds 1 to a global variable named gvar, then goes to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:563
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while 0 == 0 do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:576
msgid "Make a fiber, associate function_x with the fiber, and start function_x. It will immediately \"detach\" so it will be running independently of the caller."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:579
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:587
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:589
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:595
msgid "Pause for a while, while the detached function runs. Then ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit depending how long the pause lasted). The status is suspended because the fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:600
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:607
msgid "Pause for a while, while the detached function runs. Then ... Cancel the fiber. Then, once again ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit more depending how long the pause lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:612
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:628
msgid "Channels"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:630
msgid "Call ``fiber.channel()`` to allocate space and get a channel object, which will be called channel for examples in this section."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:633
msgid "Call the other routines, via channel, to send messages, receive messages, or check channel status."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:636
msgid "Message exchange is synchronous. The channel is garbage collected when no one is using it, as with any other Lua object. Use object-oriented syntax, for example ``channel:put(message)`` rather than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:644
msgid "Create a new communication channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:646
msgid "the maximum number of slots (spaces for ``channel:put`` messages) that can be in use at once. The default is 0."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:650
msgid "new channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:651
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:659
msgid "Send a message using a channel. If the channel is full, ``channel:put()`` waits until there is a free slot in the channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:662
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:663
msgid "maximum number of seconds to wait for a slot to become free"
msgstr "максимальное количество секунд ожидания, чтобы слот освободился"

#: ../doc/1.7/reference/reference_lua/fiber.rst:664
msgid "If timeout is specified, and there is no free slot in the channel for the duration of the timeout, then the return value is ``false``. If the channel is closed, then the return value is ``false``. Otherwise, the return value is ``true``, indicating success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:674
msgid "Close the channel. All waiters in the channel will stop waiting. All following ``channel:get()`` operations will return ``nil``, and all following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:682
msgid "Fetch and remove a message from a channel. If the channel is empty, ``channel:get()`` waits for a message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:685
msgid "maximum number of seconds to wait for a message"
msgstr "максимальное количество секунд ожидания сообщения"

#: ../doc/1.7/reference/reference_lua/fiber.rst:686
msgid "If timeout is specified, and there is no message in the channel for the duration of the timeout, then the return value is ``nil``. If the channel is closed, then the return value is ``nil``. Otherwise, the return value is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:691
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:697
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:699
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:706
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:708
msgid "the number of messages."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:715
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:717
msgid "``true`` if the channel is full (the number of messages in the channel equals the number of slots so there is no room for a new message). Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:726
msgid "Check whether readers are waiting for a message because they have issued ``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:729
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:736
msgid "Check whether writers are waiting because they have issued ``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:739
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:746
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:754
msgid "This example should give a rough idea of what some functions for fibers should look like. It's assumed that the functions would be referenced in :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:758
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:824
msgid "Condition variables"
msgstr "Условные переменные"

#: ../doc/1.7/reference/reference_lua/fiber.rst:826
msgid "Call ``fiber.cond()`` to create a named condition variable, which will be called 'cond' for examples in this section."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:829
msgid "Call ``cond:wait()`` to make a fiber wait for a signal via a condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:831
msgid "Call ``cond:signal()`` to send a signal to wake up a single fiber that has executed ``cond:wait()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:834
msgid "Call ``cond:broadcast()`` to send a signal to all fibers that have executed ``cond:wait()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:841
msgid "Create a new condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:843
msgid "new condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:844
msgid "Lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:852
msgid "Make the current fiber go to sleep, waiting until another fiber invokes the ``signal()`` or ``broadcast()`` method on the cond object. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:856
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:857
msgid "If timeout is provided, and a signal doesn't happen for the duration of the timeout, ``wait()`` returns false. If a signal or broadcast happens, ``wait()`` returns true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:866
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:875
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:883
msgid "Assume that a tarantool instance is running and listening for connections on localhost port 3301. Assume that guest users have privileges to connect. We will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:887
msgid "On terminal #1, say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:889
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:896
msgid "The job will hang because ``cond:wait()`` -- without an optional timeout argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:899
msgid "On terminal #2, say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:901
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:906
msgid "Now look again at terminal #1. It will show that the waiting stopped, and the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:909
msgid "This example depended on the use of a global conditional variable with the arbitrary name ``cond``. In real life, programmers would make sure to use different conditional variable names for different applications."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:5
msgid "Module `fio`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:13
msgid "Tarantool supports file input/output with an API that is similar to POSIX syscalls. All operations are performed asynchronously. Multiple fibers can access the same file simultaneously."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:17
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:19
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:20
msgid "functions for :ref:`directory or file existence and type checks<fio-checks>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:21
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:22
msgid ":ref:`constants <fio-c>` which are the same as POSIX flag values (for example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:29
msgid "Below is a list of all ``fio`` functions and members."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:39
msgid ":ref:`fio.pathjoin() <fio-pathjoin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:39
msgid "Form a path name from one or more partial strings"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:42
msgid ":ref:`fio.basename() <fio-basename>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:42
msgid "Get a file name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:45
msgid ":ref:`fio.dirname() <fio-dirname>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:45
msgid "Get a directory name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:48
msgid ":ref:`fio.abspath() <fio-abspath>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:48
msgid "Get a directory and file name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:51
msgid ":ref:`fio.path_exists() <fio-path_exists>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:51
#: ../doc/1.7/reference/reference_lua/fio.rst:63
msgid "Check if file or directory exists"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:54
msgid ":ref:`fio.path.is_dir() <fio-path_is_dir>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:54
msgid "Check if file or directory is a directory"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:57
msgid ":ref:`fio.path.is_file() <fio-path_is_file>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:57
msgid "Check if file or directory is a file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:60
msgid ":ref:`fio.path.is_link() <fio-path_is_link>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:60
msgid "Check if file or directory is a link"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:63
msgid ":ref:`fio.path.lexists() <fio-path_lexists>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:66
msgid ":ref:`fio.umask() <fio-umask>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:66
msgid "Set mask bits"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:69
msgid ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:70
msgid "Get information about a file object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:74
msgid ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:75
msgid "Create or delete a directory"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:79
msgid ":ref:`fio.chdir() <fio-chdir>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:79
msgid "Change working directory"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:82
msgid ":ref:`fio.listdir() <fio-listdir>`"
msgstr ":ref:`fio.listdir() <fio-listdir>`"

#: ../doc/1.7/reference/reference_lua/fio.rst:82
msgid "List files in a directory"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:85
msgid ":ref:`fio.glob() <fio-glob>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:85
msgid "Get files whose names match a given string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:88
msgid ":ref:`fio.tempdir() <fio-tempdir>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:88
msgid "Get the name of a directory for storing temporary files"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:91
msgid ":ref:`fio.cwd() <fio-cwd>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:91
msgid "Get the name of the current working directory"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:94
msgid ":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:97
msgid "Create and delete directories"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:101
msgid ":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| :ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:104
msgid "Create and delete links"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:110
msgid ":ref:`fio.rename() <fio-rename>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:110
#: ../doc/1.7/reference/reference_lua/osmodule.rst:43
msgid "Rename a file or directory"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:113
msgid ":ref:`fio.copyfile() <fio-copyfile>`"
msgstr ":ref:`fio.copyfile() <fio-copyfile>`"

#: ../doc/1.7/reference/reference_lua/fio.rst:113
msgid "Copy a file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:116
msgid ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:117
msgid "Manage rights to and ownership of file objects"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:121
msgid ":ref:`fio.truncate() <fio-truncate>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:121
msgid "Reduce the file size"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:124
msgid ":ref:`fio.sync() <fio-sync>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:124
msgid "Ensure that changes are written to disk"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:127
msgid ":ref:`fio.open() <fio-open>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:127
msgid "Open a file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:130
msgid ":ref:`file-handle:close() <file_handle-close>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:130
msgid "Close a file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:133
msgid ":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-handle:pwrite() <file_handle-pwrite>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:134
msgid "Perform random-access read or write on a file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:138
msgid ":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-handle:write() <file_handle-write>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:139
msgid "Perform non-random-access read or write on a file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:143
msgid ":ref:`file-handle:truncate() <file_handle-truncate>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:143
msgid "Change the size of an open file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:146
msgid ":ref:`file-handle:seek() <file_handle-seek>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:146
msgid "Change position in a file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:149
msgid ":ref:`file-handle:stat() <file_handle-stat>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:149
msgid "Get statistics about an open file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:152
msgid ":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-handle:fdatasync() <file_handle-fsync>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:153
msgid "Ensure that changes made to an open file are written to disk"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:157
msgid ":ref:`fio.c <fio-c_table>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:157
msgid "Table of constants similar to POSIX flag values"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:167
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:173
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:175
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:176
#: ../doc/1.7/reference/reference_lua/fio.rst:195
#: ../doc/1.7/reference/reference_lua/fio.rst:216
msgid "path name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:181
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:192
msgid "Given a full path name, remove all but the final part (the file name). Also remove the suffix, if it is passed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:196
msgid "suffix"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:198
#: ../doc/1.7/reference/reference_lua/fio.rst:235
msgid "file name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:203
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:214
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:218
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:223
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:233
msgid "Given a final part (the file name), return the full path name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:237
msgid "directory name, that is, path name including file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:242
msgid ""
"tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:253
msgid "Directory or file existence and type checks"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:255
msgid "Functions in this section are similar to some `Python os.path <https://docs.python.org/2/library/os.path.htmll>`_ functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:263
#: ../doc/1.7/reference/reference_lua/fio.rst:271
#: ../doc/1.7/reference/reference_lua/fio.rst:279
#: ../doc/1.7/reference/reference_lua/fio.rst:287
#: ../doc/1.7/reference/reference_lua/fio.rst:295
msgid "path to directory or file."
msgstr "путь к директории или файлу."

#: ../doc/1.7/reference/reference_lua/fio.rst:264
msgid "true if path-name refers to a directory or file that exists and is not a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:272
msgid "true if path-name refers to a directory; otherwise false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:280
msgid "true if path-name refers to a file; otherwise false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:288
msgid "true if path-name refers to a symbolic link; otherwise false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:296
msgid "true if path-name refers to a directory or file that exists or is a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:303
msgid "Common file manipulations"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:309
msgid "Set the mask bits used when creating files or directories. For a detailed description type ``man 2 umask``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:312
msgid "mask bits."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:313
msgid "previous mask bits."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:318
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:330
msgid "Returns information about a file object. For details type ``man 2 lstat`` or ``man 2 stat``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:333
msgid "path name of file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:334
msgid "(If no error) table of fields which describe the file's block size, creation time, size, and other attributes. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:337
msgid "table."
msgstr "таблица."

#: ../doc/1.7/reference/reference_lua/fio.rst:339
msgid "Additionally, the result of ``fio.stat('file-name')`` will include methods equivalent to POSIX macros:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:342
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:343
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:344
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:345
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:346
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:347
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:348
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:350
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:354
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:380
msgid "Create or delete a directory. For details type ``man 2 mkdir`` or ``man 2 rmdir``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:383
#: ../doc/1.7/reference/reference_lua/fio.rst:407
#: ../doc/1.7/reference/reference_lua/fio.rst:427
msgid "path of directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:384
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:387
#: ../doc/1.7/reference/reference_lua/fio.rst:507
#: ../doc/1.7/reference/reference_lua/fio.rst:529
#: ../doc/1.7/reference/reference_lua/fio.rst:604
#: ../doc/1.7/reference/reference_lua/fio.rst:627
#: ../doc/1.7/reference/reference_lua/fio.rst:675
msgid "(If no error) true. |br| (If error) two return values: false, error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:393
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:404
msgid "Change working directory. For details type ``man 2 chdir``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:408
msgid "(If success) true. (If failure) false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:413
msgid ""
"tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fio.chdir('/etc')\n"
"      ---\n"
"      - true\n"
"      ..."

#: ../doc/1.7/reference/reference_lua/fio.rst:424
msgid "List files in directory. The result is similar to the result from the ``ls`` command."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:428
msgid "(If no error) a list of files. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:434
msgid ""
"tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:445
msgid "Return a list of files that match an input string. The list is constructed with a single flag that controls the behavior of the function: ``GLOB_NOESCAPE``. For details type ``man 3 glob``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:449
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:450
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:453
#: ../doc/1.7/reference/reference_lua/fio.rst:759
#: ../doc/1.7/reference/reference_lua/fio.rst:992
msgid "**Possible errors:** nil."
msgstr "**Возможные ошибки:** nil."

#: ../doc/1.7/reference/reference_lua/fio.rst:457
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:470
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:474
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:485
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:489
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:500
msgid "Copy everything in the from-path, including subdirectory contents, to the to-path. The result is similar to the result that one gets from the ``cp -r`` command. The to-path should be empty."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:505
#: ../doc/1.7/reference/reference_lua/fio.rst:506
#: ../doc/1.7/reference/reference_lua/fio.rst:528
#: ../doc/1.7/reference/reference_lua/fio.rst:551
msgid "path-name."
msgstr "путь."

#: ../doc/1.7/reference/reference_lua/fio.rst:513
msgid ""
"tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:524
msgid "Create the path, including subdirectories, but without file contents. The result is similar to the result that one gets from the ``mkdir`` command."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:535
msgid ""
"tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:546
msgid "Remove the directory indicated by path-name, including subdirectories. The result is similar to the result that one gets from the ``rmdir`` command, recursively. The directory must be empty."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:552
msgid "(If no error) true. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:558
msgid ""
"tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:572
msgid "Functions to create and delete links. For details type ``man readlink``, ``man 2 link``, ``man 2 symlink``, ``man 2 unlink``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:575
msgid "existing file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:576
msgid "linked name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:578
msgid "(If no error) ``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true, ``fio.readlink`` returns the link value. |br| (If error) two return values: false|null, error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:584
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:599
msgid "Rename a file or directory. For details type ``man 2 rename``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:601
msgid "original name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:602
msgid "new name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:610
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:621
msgid "Copy a file. The effect is similar to the effect that one gets with the ``cp`` command."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:624
msgid "path to original file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:625
msgid "path to new file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:633
msgid ""
"tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:645
msgid "Manage the rights to file objects, or ownership of file objects. For details type ``man 2 chown`` or ``man 2 chmod``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:648
msgid "new user uid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:649
msgid "new group uid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:650
msgid "new permissions"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:655
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:670
msgid "Reduce file size to a specified value. For details type ``man 2 truncate``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:681
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:692
msgid "Ensure that changes are written to disk. For details type ``man 2 sync``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:694
#: ../doc/1.7/reference/reference_lua/fio.rst:795
#: ../doc/1.7/reference/reference_lua/fio.rst:854
#: ../doc/1.7/reference/reference_lua/fio.rst:939
#: ../doc/1.7/reference/reference_lua/fio.rst:966
#: ../doc/1.7/reference/reference_lua/fio.rst:1046
msgid "true if success, false if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:699
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:714
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:716
msgid "Full path to the file to open."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:717
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:  * O_APPEND (start at end of file), * O_ASYNC (signal when IO is possible), * O_CLOEXEC (enable a flag related to closing), * O_CREAT (create file if it doesn't exist), * O_DIRECT (do less caching or no caching), * O_DIRECTORY (fail if it's not a directory), * O_EXCL (fail if file cannot be created), * O_LARGEFILE (allow 64-bit file offsets), * O_NOATIME (no access-time updating), * O_NOCTTY (no console tty), * O_NOFOLLOW (no following symbolic links), * O_NONBLOCK (no blocking), * O_PATH (get a path for low-level use), * O_SYNC (force writing if it's possible), * O_TMPFILE (the file will be temporary and nameless), * O_TRUNC (truncate)  ... and, always, one of:  * O_RDONLY (read only), * O_WRONLY (write only), or * O_RDWR (either read or write)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:717
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:726
msgid "O_APPEND (start at end of file),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:727
msgid "O_ASYNC (signal when IO is possible),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:728
msgid "O_CLOEXEC (enable a flag related to closing),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:729
msgid "O_CREAT (create file if it doesn't exist),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:730
msgid "O_DIRECT (do less caching or no caching),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:731
msgid "O_DIRECTORY (fail if it's not a directory),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:732
msgid "O_EXCL (fail if file cannot be created),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:733
msgid "O_LARGEFILE (allow 64-bit file offsets),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:734
msgid "O_NOATIME (no access-time updating),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:735
msgid "O_NOCTTY (no console tty),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:736
msgid "O_NOFOLLOW (no following symbolic links),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:737
msgid "O_NONBLOCK (no blocking),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:738
msgid "O_PATH (get a path for low-level use),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:739
msgid "O_SYNC (force writing if it's possible),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:740
msgid "O_TMPFILE (the file will be temporary and nameless),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:741
msgid "O_TRUNC (truncate)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:743
msgid "... and, always, one of:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:745
msgid "O_RDONLY (read only),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:746
msgid "O_WRONLY (write only), or"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:747
msgid "O_RDWR (either read or write)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:749
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits are significant if flags include ``O_CREAT`` or ``O_TMPFILE``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:754
msgid "(If no error) file handle (abbreviated as 'fh' in later description). |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:761
msgid "**Example 1:**"
msgstr "**Пример 1:**"

#: ../doc/1.7/reference/reference_lua/fio.rst:763
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:773
msgid "**Example 2:**"
msgstr "**Пример 2:**"

#: ../doc/1.7/reference/reference_lua/fio.rst:775
msgid "Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an octal number:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:778
msgid ""
"tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
"---\n"
"- fh: 12\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:791
msgid "Close a file that was opened with ``fio.open``. For details type ``man 2 close``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:794
#: ../doc/1.7/reference/reference_lua/fio.rst:816
#: ../doc/1.7/reference/reference_lua/fio.rst:849
#: ../doc/1.7/reference/reference_lua/fio.rst:890
#: ../doc/1.7/reference/reference_lua/fio.rst:935
#: ../doc/1.7/reference/reference_lua/fio.rst:965
#: ../doc/1.7/reference/reference_lua/fio.rst:985
#: ../doc/1.7/reference/reference_lua/fio.rst:1011
#: ../doc/1.7/reference/reference_lua/fio.rst:1045
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:800
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:812
msgid "Perform random-access read operation on a file, without affecting the current seek position of the file. For details type ``man 2 pread``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:817
msgid "where to read into (if the format is ``pread(buffer, count, offset)``)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:819
#: ../doc/1.7/reference/reference_lua/fio.rst:893
msgid "number of bytes to read"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:820
msgid "offset within file where reading begins"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:822
msgid "If the format is ``pread(count, offset)`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:825
msgid "If the format is ``pread(buffer, count, offset)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:831
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:845
msgid "Perform random-access write operation on a file, without affecting the current seek position of the file. For details type ``man 2 pwrite``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:850
#: ../doc/1.7/reference/reference_lua/fio.rst:936
msgid "value to write"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:851
msgid "number of bytes to write (if the format is ``pwrite(buffer, count, offset)``)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:853
msgid "offset within file where writing begins"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:857
msgid "If the format is ``pwrite(new-string, offset)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:860
msgid "If the format is ``pwrite(buffer, count, offset)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:864
msgid ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:880
msgid "Perform non-random-access read on a file. For details type ``man 2 read`` or ``man 2 write``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:885
#: ../doc/1.7/reference/reference_lua/fio.rst:930
msgid "``fh:read`` and ``fh:write`` affect the seek position within the file, and this must be taken into account when working on the same file from multiple fibers. It is possible to limit or prevent file access from other fibers with ``fiber.ipc``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:891
msgid "where to read into (if the format is ``read(buffer, count)``)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:895
msgid "If the format is ``read()`` -- omitting ``count`` -- then read all bytes in the file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:898
msgid "If the format is ``read()``  or ``read([count])`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:901
msgid "If the format is ``read(buffer, count)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:905
msgid ""
"ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:925
msgid "Perform non-random-access write on a file. For details type ``man 2 write``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:937
msgid "number of bytes to write (if the format is ``write(buffer, count)``)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:942
msgid "If the format is ``write(new-string)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:945
msgid "If the format is ``write(buffer, count)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:951
msgid ""
"tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."
msgstr ""
"tarantool> fh:write(\"new data\")\n"
"      ---\n"
"      - true\n"
"      ..."

#: ../doc/1.7/reference/reference_lua/fio.rst:962
msgid "Change the size of an open file. Differs from ``fio.truncate``, which changes the size of a closed file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:971
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:982
msgid "Shift position in the file to the specified position. For details type ``man 2 seek``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:986
msgid "position to seek to"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:987
msgid "'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, '``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:989
msgid "the new position if success"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:996
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:1007
msgid "Return statistics about an open file. This differs from ``fio.stat`` which return statistics about a closed file. For details type ``man 2 stat``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:1012
msgid "details about the file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:1017
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:1041
msgid "Ensure that file changes are written to disk, for an open file. Compare ``fio.sync``, which is for all files. For details type ``man 2 fsync`` or ``man 2 fdatasync``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:1050
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:1061
msgid "FIO constants"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:1067
msgid "Table with constants which are the same as POSIX flag values on the target platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:1072
msgid ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:5
msgid "Module `fun`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:7
msgid "Luafun, also known as the Lua Functional Library, takes advantage of the features of LuaJIT to help users create complex functions. Inside the module are \"sequence processors\" such as ``map``, ``filter``, ``reduce``, ``zip`` -- they take a user-written function as an argument and run it against every element in a sequence, which can be faster or more convenient than a user-written loop. Inside the module are \"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they return a bounded or boundless series of values. Within the module are \"reducers\", \"filters\", \"composers\" ... or, in short, all the important features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:17
msgid "The full documentation is `On the luafun section of github`_. However, the first chapter can be skipped because installation is already done, it's inside Tarantool. All that is needed is the usual ``require`` request. After that, all the operations described in the Lua fun manual will work, provided they are preceded by the name returned by the ``require`` request. For example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:23
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:5
msgid "Module `http`"
msgstr "Модуль `http`"

#: ../doc/1.7/reference/reference_lua/http.rst:13
msgid "The ``http`` module, specifically the ``http.client`` submodule, provides the functionality of an HTTP client with support for HTTPS and keepalive. It uses routines in the `libcurl <https://curl.haxx.se/libcurl/>`_ library."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:21
msgid "Below is a list of all ``http`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:31
msgid ":ref:`http.client.new() <http-new>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:31
msgid "Create an HTTP client instance"
msgstr "Создание экземпляра HTTP-клиента"

#: ../doc/1.7/reference/reference_lua/http.rst:34
msgid ":ref:`client_object:request() <client_object-request>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:34
msgid "Perform an HTTP request"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:37
msgid ":ref:`client_object:stat() <client_object-stat>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:37
msgid "Get a table with statistics"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:45
msgid "Construct a new HTTP client instance."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:47
msgid "the maximum number of entries in the connection cache."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:49
msgid "a new HTTP client instance"
msgstr "новый экземпляр HTTP-клиента"

#: ../doc/1.7/reference/reference_lua/http.rst:54
msgid ""
"tarantool> http_client = require('http.client').new({5})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:66
msgid "If ``http_client`` is an HTTP client instance, ``http_client:request()`` will perform an HTTP request and, if there is a successful connection, will return a table with connection information."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:70
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:71
msgid "location, for example 'https://tarantool.org/doc'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:72
msgid "optional initial message, for example 'My text string!'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:73
msgid "table of connection options, with any of these components:   * ``timeout`` - number of seconds to wait for a curl API read request    before timing out  * ``ca_path`` - path to a directory holding one or more certificates to    verify the peer with  * ``ca_file`` - path to an SSL certificate file to verify the peer with  * ``verify_host`` - set on/off verification of the certificate's name    (CN) against host. See also    `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * ``verify_peer`` - set on/off verification of the peer's SSL    certificate. See also    `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * ``ssl_key`` - path to a private key file for a TLS and SSL client    certificate. See also    `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` - path to a SSL client certificate file. See also    `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``headers`` - table of HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the operating system    will wait while the connection is idle before sending keepalive    probes. See also    `CURLOPT_TCP_KEEPALIVE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * ``keepalive_interval`` - the interval, in seconds, that the operating    system will wait between sending keepalive probes. See also    `CURLOPT_TCP_KEEPALIVE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * ``low_speed_time`` - set the \"low speed time\" -- the time that the    transfer speed should be below the \"low speed limit\" for the library    to consider it too slow and abort. See also    `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * ``low_speed_limit`` - set the \"low speed limit\" -- the average    transfer speed in bytes per second that the transfer should be below    during \"low speed time\" seconds for the library to consider it to be    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * ``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:73
msgid "table of connection options, with any of these components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:76
msgid "``timeout`` - number of seconds to wait for a curl API read request before timing out"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:78
msgid "``ca_path`` - path to a directory holding one or more certificates to verify the peer with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:80
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:81
msgid "``verify_host`` - set on/off verification of the certificate's name (CN) against host. See also `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:84
msgid "``verify_peer`` - set on/off verification of the peer's SSL certificate. See also `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:87
msgid "``ssl_key`` - path to a private key file for a TLS and SSL client certificate. See also `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:90
msgid "``ssl_cert`` - path to a SSL client certificate file. See also `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:92
msgid "``headers`` - table of HTTP headers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:93
msgid "``keepalive_idle`` - delay, in seconds, that the operating system will wait while the connection is idle before sending keepalive probes. See also `CURLOPT_TCP_KEEPALIVE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:97
msgid "``keepalive_interval`` - the interval, in seconds, that the operating system will wait between sending keepalive probes. See also `CURLOPT_TCP_KEEPALIVE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:100
msgid "``low_speed_time`` - set the \"low speed time\" -- the time that the transfer speed should be below the \"low speed limit\" for the library to consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:104
msgid "``low_speed_limit`` - set the \"low speed limit\" -- the average transfer speed in bytes per second that the transfer should be below during \"low speed time\" seconds for the library to consider it to be too slow and abort. See also `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:109
msgid "``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:111
msgid "connection information, with all of these components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:113
msgid "``status`` - HTTP response status"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:114
msgid "``reason`` - HTTP response status text"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:115
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:116
msgid "``body`` - response body"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:117
msgid "``proto`` - protocol version"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:121
msgid "The following \"shortcuts\" exist for requests:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:123
msgid "``http_client:get(url, options)`` - shortcut for ``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:125
msgid "``http_client:post (url, body, options)`` - shortcut for ``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:127
msgid "``http_client:put(url, body, options)`` - shortcut for ``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:129
msgid "``http_client:patch(url, body, options)`` - shortcut for ``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:131
msgid "``http_client:options(url, options)`` - shortcut for ``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:133
msgid "``http_client:head(url, options)`` - shortcut for ``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:135
msgid "``http_client:delete(url, options)`` - shortcut for ``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:137
msgid "``http_client:trace(url, options)`` - shortcut for ``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:139
msgid "``http_client:connect:(url, options)`` - shortcut for ``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:146
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:148
msgid "``active_requests`` - number of currently executing requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:149
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:150
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:151
msgid "``total_requests`` - total number of requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:152
msgid "``http_200_responses`` - total number of requests which have returned code HTTP 200"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:154
msgid "``http_other_responses`` - total number of requests which have not returned code HTTP 200"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:156
msgid "``failed_requests`` - total number of requests which have failed including system errors, curl errors, and HTTP errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:161
msgid "Connect to an HTTP server, look at the size of the response for a 'GET' request, and look at the statistics for the session."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:164
msgid ""
"tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:5
msgid "Module `iconv`"
msgstr "Модуль `iconv`"

#: ../doc/1.7/reference/reference_lua/iconv.rst:13
msgid "The ``iconv`` module provides a way to convert a string with one encoding to a string with another encoding, for example from ASCII to UTF-8. It is based on the POSIX iconv routines."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:17
msgid "An exact list of the available encodings may depend on environment. Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, and about 100 others. For a complete list, type ``iconv --list`` on a terminal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:26
msgid "Below is a list of all ``iconv`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:36
msgid ":ref:`iconv.new() <iconv-new>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:36
msgid "Create an iconv instance"
msgstr "Создание экземпляра iconv"

#: ../doc/1.7/reference/reference_lua/iconv.rst:39
msgid ":ref:`iconv.converter() <iconv-converter>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:39
msgid "Perform conversion on a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:47
msgid "Construct a new iconv instance."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:49
msgid "the name of the encoding that we will convert to."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:50
msgid "the name of the encoding that we will convert from."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:52
msgid "a new iconv instance -- in effect, a callable function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:55
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:59
msgid ""
"tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:69
msgid "Convert."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst
msgid "param string input-string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:71
msgid "the string to be converted (the \"from\" string)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:73
msgid "the string that results from the conversion (the \"to\" string)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:75
msgid "If anything in input-string cannot be converted, there will be an error message and the result string will be unchanged."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:80
msgid "We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER DE) is hexadecimal 0414 according to the character database of Unicode_. Therefore that is what it will look like in UTF-16. We know that Tarantool typically uses the UTF-8 character set. So make a from-UTF-8-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks like in the UTF-8 source, and use string.hex('Д'-after-conversion) to show what it looks like in the UTF-16 target. Since the result is 0414, we see that iconv conversion works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:89
msgid ""
"tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:5
msgid "Built-in modules reference"
msgstr "Справочник по встроенным модулям"

#: ../doc/1.7/reference/reference_lua/index.rst:7
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr "В данном справочнике рассматриваются встроенные Lua-модули Tarantool'а."

#: ../doc/1.7/reference/reference_lua/index.rst:11
msgid "Some functions in these modules are analogs to functions from `standard Lua libraries <http://www.lua.org/manual/>`_. For better results, we recommend using functions from Tarantool's built-in modules."
msgstr "Некоторые функции в данных модулях представляют собой аналоги функций из `стандартных Lua-библиотек <http://www.lua.org/manual/>`_. Для достижения наилучшего результата мы рекомендуем использовать функции из встроенных модулей Tarantool'а."

#: ../doc/1.7/reference/reference_lua/index.rst:15
msgid "List of Lua modules"
msgstr "Перечень Lua-модулей"

#: ../doc/1.7/reference/reference_lua/json.rst:5
msgid "Module `json`"
msgstr "Модуль `json`"

#: ../doc/1.7/reference/reference_lua/json.rst:11
msgid "The ``json`` module provides JSON manipulation routines. It is based on the `Lua-CJSON module by Mark Pulford`_. For a complete manual on Lua-CJSON please read `the official documentation`_."
msgstr "Модуль ``json`` обеспечивает процедуры работы с форматом JSON. Он основан на `модуле Lua-CJSON от Mark Pulford`_. Полное руководство по Lua-CJSON включено в официальную документацию (`the official documentation`_)."

#: ../doc/1.7/reference/reference_lua/json.rst:19
msgid "Below is a list of all ``json`` functions and members."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``json``."

#: ../doc/1.7/reference/reference_lua/json.rst:29
msgid ":ref:`json.encode() <json-encode>`"
msgstr ":ref:`json.encode() <json-encode>`"

#: ../doc/1.7/reference/reference_lua/json.rst:29
msgid "Convert a Lua object to a JSON string"
msgstr "Конвертация Lua-объекта в JSON-строку"

#: ../doc/1.7/reference/reference_lua/json.rst:32
msgid ":ref:`json.decode() <json-decode>`"
msgstr ":ref:`json.decode() <json-decode>`"

#: ../doc/1.7/reference/reference_lua/json.rst:32
msgid "Convert a JSON string to a Lua object"
msgstr "Конвертация JSON-строки в Lua-объект"

#: ../doc/1.7/reference/reference_lua/json.rst:35
msgid ":ref:`json.NULL <json-null>`"
msgstr ":ref:`json.NULL <json-null>`"

#: ../doc/1.7/reference/reference_lua/json.rst:35
#: ../doc/1.7/reference/reference_lua/msgpack.rst:39
#: ../doc/1.7/reference/reference_lua/yaml.rst:34
msgid "Analog of Lua's \"nil\""
msgstr "Аналог \"nil\" в языке Lua "

#: ../doc/1.7/reference/reference_lua/json.rst:45
msgid "Convert a Lua object to a JSON string."
msgstr "Конвертация Lua-объекта в JSON-строку."

#: ../doc/1.7/reference/reference_lua/json.rst:47
#: ../doc/1.7/reference/reference_lua/msgpack.rst:51
#: ../doc/1.7/reference/reference_lua/yaml.rst:46
msgid "either a scalar value or a Lua table value."
msgstr "скалярное значеное или значение из Lua-таблицы."

#: ../doc/1.7/reference/reference_lua/json.rst:48
msgid "the original value reformatted as a JSON string."
msgstr "оригинальное значение, преобразованное в JSON-строку."

#: ../doc/1.7/reference/reference_lua/json.rst:53
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""
"tarantool> json=require('json')\n"
"   ---\n"
"   ...\n"
"   tarantool> json.encode(123)\n"
"   ---\n"
"   - '123'\n"
"   ...\n"
"   tarantool> json.encode({123})\n"
"   ---\n"
"   - '[123]'\n"
"   ...\n"
"   tarantool> json.encode({123, 234, 345})\n"
"   ---\n"
"   - '[123,234,345]'\n"
"   ...\n"
"   tarantool> json.encode({abc = 234, cde = 345})\n"
"   ---\n"
"   - '{\"cde\":345,\"abc\":234}'\n"
"   ...\n"
"   tarantool> json.encode({hello = {'world'}})\n"
"   ---\n"
"   - '{\"hello\":[\"world\"]}'\n"
"   ..."

#: ../doc/1.7/reference/reference_lua/json.rst:83
msgid "Convert a JSON string to a Lua object."
msgstr "Конвертация JSON-строки в Lua-объект."

#: ../doc/1.7/reference/reference_lua/json.rst:85
msgid "a string formatted as JSON."
msgstr "строка в формате JSON."

#: ../doc/1.7/reference/reference_lua/json.rst:86
#: ../doc/1.7/reference/reference_lua/yaml.rst:57
msgid "the original contents formatted as a Lua table."
msgstr "оригинальное содержание в формате Lua-таблицы."

#: ../doc/1.7/reference/reference_lua/json.rst:91
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""
"tarantool> json = require('json')\n"
"   ---\n"
"   ...\n"
"   tarantool> json.decode('123')\n"
"   ---\n"
"   - 123\n"
"   ...\n"
"   tarantool> json.decode('[123, \"hello\"]')\n"
"   ---\n"
"   - [123, 'hello']\n"
"   ...\n"
"   tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"   ---\n"
"   - world\n"
"   ..."

#: ../doc/1.7/reference/reference_lua/json.rst:109
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how ``json.decode()`` can fit in an application."
msgstr "Чтобы увидеть применение ``json.decode()`` в приложении, см. практическое задание :ref:`Подсчет суммы по JSON-полям во всех кортежах <c_lua_tutorial-sum_a_json_field>`."

#: ../doc/1.7/reference/reference_lua/json.rst:117
#: ../doc/1.7/reference/reference_lua/msgpack.rst:94
#: ../doc/1.7/reference/reference_lua/yaml.rst:64
msgid "A value comparable to Lua \"nil\" which may be useful as a placeholder in a tuple."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:122
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:144
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:146
msgid "``__serialize=\"seq\"`` for an array"
msgstr "``__serialize=\"seq\"`` для массива"

#: ../doc/1.7/reference/reference_lua/json.rst:147
msgid "``__serialize=\"map\"`` for a map"
msgstr "``__serialize=\"map\"`` для ассоциативного массива"

#: ../doc/1.7/reference/reference_lua/json.rst:149
#: ../doc/1.7/reference/reference_lua/yaml.rst:101
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:152
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"   ---\n"
"   - '[\"A\",\"B\"]'\n"
"   ...\n"
"   tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"   ---\n"
"   - '{\"1\":\"A\",\"2\":\"B\"}'\n"
"   ...\n"
"   tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"   ---\n"
"   - '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"   ...\n"
"   tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq\"})})\n"
"   ---\n"
"   - '[[]]'\n"
"   ..."

#: ../doc/1.7/reference/reference_lua/json.rst:176
msgid "Configuration settings"
msgstr "Параметры конфигурации"

#: ../doc/1.7/reference/reference_lua/json.rst:178
msgid "There are configuration settings which affect the way that Tarantool encodes invalid numbers or types. They are all boolean ``true``/``false`` values"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:181
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:182
msgid "``cfg.encode_use_tostring`` (default is false) -- use tostring for unrecognizable types"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:184
msgid "``cfg.encode_invalid_as_nil`` (default is false) -- use null for all unrecognizable types"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:186
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:188
msgid "For example, the following code will interpret 0/0 (which is \"not a number\") and 1/0 (which is \"infinity\") as special values rather than nulls or errors:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:191
msgid ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""
"json = require('json')\n"
"   json.cfg{encode_invalid_numbers = true}\n"
"   x = 0/0\n"
"   y = 1/0\n"
"   json.encode({1, x, y, 2})"

#: ../doc/1.7/reference/reference_lua/json.rst:199
msgid "The result of the ``json.encode()`` request will look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:201
msgid ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""
"tarantool> json.encode({1, x, y, 2})\n"
"   ---\n"
"   - '[1,nan,inf,2]\n"
"   ..."

#: ../doc/1.7/reference/reference_lua/json.rst:208
msgid "The same configuration settings exist for json, for :ref:`MsgPack <msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:5
msgid "Module `log`"
msgstr "Модуль `log`"

#: ../doc/1.7/reference/reference_lua/log.rst:13
msgid "The Tarantool server puts all diagnostic messages in a log file specified by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic messages may be either system-generated by the server's internal code, or user-generated with the :samp:`log.{log_level_function_name}` function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:22
msgid "Below is a list of all ``log`` functions."
msgstr "Ниже приведен перечень всех функций и элементов модуля ``log``."

#: ../doc/1.7/reference/reference_lua/log.rst:32
msgid ":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| :ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-ug_message>`"
msgstr ":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| :ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-ug_message>`"

#: ../doc/1.7/reference/reference_lua/log.rst:36
msgid "Write a user-generated message to a log file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:43
msgid ":ref:`log.logger_pid() <log-logger_pid>`"
msgstr ":ref:`log.logger_pid() <log-logger_pid>`"

#: ../doc/1.7/reference/reference_lua/log.rst:43
msgid "Get the PID of a logger"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:46
msgid ":ref:`log.rotate() <log-rotate>`"
msgstr ":ref:`log.rotate() <log-rotate>`"

#: ../doc/1.7/reference/reference_lua/log.rst:46
msgid "Rotate a log file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:58
msgid "Output a user-generated message to the :ref:`log file <cfg_logging-log>`, given log_level_function_name = ``error`` or ``warn`` or ``info`` or ``verbose`` or ``debug``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:62
msgid "As explained in the description of the configuration setting for :ref:`log_level <cfg_logging-log_level>`, there are seven levels of detail:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:66
msgid "2 – ``ERROR`` -- this corresponds to ``log.error(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:68
msgid "4 – ``WARNING``  -- this corresponds to ``log.warn(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:69
msgid "5 – ``INFO`` -- this corresponds to ``log.info(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:70
msgid "6 – ``VERBOSE``  -- this corresponds to ``log.verbose(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:71
msgid "7 – ``DEBUG`` -- this corresponds to ``log.debug(...)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:73
msgid "For example, if ``box.cfg.log_level`` is currently 5 (the default value), then ``log.error(...)``, ``log.warn(...)`` and ``log.info(...)`` messages will go to the log file. However, ``log.verbose(...)`` and ``log.debug(...)`` messages will not go to the log file, because they correspond to higher levels of detail."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:79
#, python-format
msgid "The actual output will be a line containing:  * the current timestamp, * a module name, * 'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and * ``message``.  Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <cfg_logging-log_level>`.  Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:79
msgid "The actual output will be a line containing:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:81
msgid "the current timestamp,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:82
msgid "a module name,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:83
msgid "'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:84
msgid "``message``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:86
msgid "Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <cfg_logging-log_level>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:90
#, python-format
msgid "Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:100
msgid "PID of a logger"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:106
msgid "Rotate the log."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:114
#, python-format
msgid ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:123
msgid ""
"$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version 1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:130
msgid "The 'Error' line is visible in ``tarantool.txt`` preceded by the letter E."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:132
msgid "The 'Info' line is not present because the ``log_level`` is 3."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:5
msgid "Module `msgpack`"
msgstr "Модуль `msgpack`"

#: ../doc/1.7/reference/reference_lua/msgpack.rst:11
msgid "The ``msgpack`` module takes strings in MsgPack_ format and decodes them, or takes a series of non-MsgPack values and encodes them. Tarantool makes heavy internal use of MsgPack because tuples in Tarantool are :ref:`stored <index-box_lua-vs-msgpack>` as MsgPack arrays."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:20
msgid "Below is a list of all ``msgpack`` functions and members."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:30
msgid ":ref:`msgpack.encode() <msgpack-encode>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:30
msgid "Convert a Lua object to an MsgPack string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:33
msgid ":ref:`msgpack.decode() <msgpack-decode>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:33
#: ../doc/1.7/reference/reference_lua/msgpack.rst:36
msgid "Convert a MsgPack string to a Lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:36
msgid ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:39
msgid ":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:49
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:52
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:59
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:61
#: ../doc/1.7/reference/reference_lua/msgpack.rst:81
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:62
msgid "where to start, minimum = 1, maximum = string length"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:66
#: ../doc/1.7/reference/reference_lua/msgpack.rst:85
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:67
#: ../doc/1.7/reference/reference_lua/msgpack.rst:86
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:69
#: ../doc/1.7/reference/reference_lua/msgpack.rst:88
msgid "lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:75
msgid "Convert a MsgPack string to a Lua object. Because checking is skipped, ``decode_unchecked()`` can operate with string pointers to buffers which ``decode()`` cannot handle. For an example see the :ref:`buffer <buffer-module>` module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:101
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:126
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:128
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:129
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:131
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results. To show this, here is a routine which encodes `{'A','B'}` both as an array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:135
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) .. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:155
msgid "**Result:**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:194
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:163
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:202
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:170
msgid "and the second encoding means:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:209
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:177
msgid "Here are examples for all the common types, with the Lua-table representation on the left, with the MsgPack format name and encoding on the right."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:185
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:191
msgid "{}"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:191
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:194
msgid "'a'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:194
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:196
msgid "'false' = c2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:198
msgid "'true' = c3"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:200
msgid "127"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:200
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:202
msgid "65535"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:202
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:204
msgid "4294967295"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:204
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:206
msgid "'nil' = c0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:208
msgid "same as nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:210
msgid "[0] = 5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:210
msgid "'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for the value) = 81 00 05"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:213
msgid "[0] = nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:213
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:216
msgid "1.5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:216
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:219
msgid "Also, some MsgPack configuration settings for encoding can be changed, in the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:5
msgid "Module `net.box`"
msgstr "Модуль `net.box`"

#: ../doc/1.7/reference/reference_lua/net_box.rst:11
msgid "The ``net.box`` module contains connectors to remote database systems. One variant, to be discussed later, is connecting to MySQL or MariaDB or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other variant, which is discussed in this section, is connecting to Tarantool server instances via a network using the built-in ``net.box`` module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:17
msgid "You can call the following methods:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:19
msgid "``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for examples in this section),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:21
msgid "``net_box.connect()`` to connect and get a connection object (named ``conn`` for examples in this section),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:23
msgid "other ``net.box()`` routines, passing ``conn:``, to execute requests on a remote box,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:25
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:27
msgid "All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the same connection object across multiple concurrent fibers. In fact, it's perhaps the best programming practice with Tarantool. When multiple fibers use the same connection, all requests are pipelined through the same network socket, but each fiber gets back a correct response. Reducing the number of active sockets lowers the overhead of system calls and increases the overall server performance. There are, however, cases when a single connection is not enough — for example, when it's necessary to prioritize requests or to use different authentication IDs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:36
msgid "Most ``net.box`` methods allow a final ``{options}`` argument, which can be:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:38
msgid "``{timeout=...}``. For example, a method whose final argument is ``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although this does not guarantee that execution will stop on the remote server node."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:41
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:43
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:51
msgid "On this diagram:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:53
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:55
msgid "``net_box.connect()`` method changes the state to 'connecting' and spawns a worker fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:57
msgid "If authentication and schema upload are required, it's possible later on to re-enter the 'fetch_schema' state from 'active' if a request fails due to a schema version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:61
msgid "``conn.close()`` method sets the state to 'closed' and kills the worker. If the transport is already in the 'error' state, ``close()`` does nothing."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:68
msgid "Below is a list of all ``net.box`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:78
msgid ":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() <net_box-new>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:79
msgid "Create a connection"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:83
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:83
msgid "Execute a PING command"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:86
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:86
msgid "Wait for a connection to be active or closed"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:89
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:89
msgid "Check if a connection is active or closed"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:92
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:92
msgid "Wait for a target state"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:95
msgid ":ref:`conn:close() <conn-close>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:95
msgid "Close a connection"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:98
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ":ref:`conn.space.space-name:select{field-value} <conn-select>`"

#: ../doc/1.7/reference/reference_lua/net_box.rst:101
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:104
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:107
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:110
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:113
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:116
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:119
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:119
msgid "Call a stored procedure"
msgstr "Вызов хранимой процедуры"

#: ../doc/1.7/reference/reference_lua/net_box.rst:122
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:122
msgid "Evaluate and execute the expression in a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:125
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:125
msgid "Set a timeout"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:141
msgid "The names ``connect()`` and ``new()`` are synonymous with the only difference that ``connect()`` is the preferred name, while ``new()`` is retained for backward compatibility."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:145
msgid "Create a new connection. The connection is established on demand, at the time of the first request. It can be re-established automatically after a disconnect (see ``reconnect_after`` option below). The returned ``conn`` object supports methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:151
msgid "For a local Tarantool server, there is a pre-created always-established connection object named :samp:`{net_box}.self`. Its purpose is to make polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = {net_box}.self`. However, there is an important difference between the embedded connection and a remote one. With the embedded connection, requests which do not modify data do not yield. When using a remote connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any request can yield, and database state may have changed by the time it regains control."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:163
msgid "Possible options:"
msgstr "Возможные опции"

#: ../doc/1.7/reference/reference_lua/net_box.rst:165
msgid "`wait_connected`: by default, connection creation is blocked until the connection is established, but passing ``wait_connected=false`` makes it return immediately. Also, passing a timeout makes it wait before returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 seconds)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:171
msgid "In the presence of ``reconnect_after``, ``wait_connected`` ignores transient failures. The wait completes once the connection is established or is closed explicitly."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:174
msgid "`reconnect_after`: a ``net.box`` instance automatically reconnects any time the connection is broken or if a connection attempt fails. This makes transient network failures become transparent to the application. Reconnect happens automatically in the background, so queries/requests that suffered due to connectivity loss are transparently retried. The number of retries is unlimited, connection attempts are done over the specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a connection is explicitly closed (or garbage-collected), reconnects stop."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:183
msgid "`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with a new binary protocol command for CALL, which is not backward compatible with previous versions. The new CALL no longer restricts a function to returning an array of tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility. It will be removed in the next major release. All programming language drivers will be gradually changed to use the new CALL. To connect to a Tarantool instance that uses the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:192
msgid "`console`: depending on the option's value, the connection supports different methods (as if instances of different classes were returned). With ``console = true``, you can use ``conn`` methods ``close()``, ``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both binary and Lua console network protocols are supported). With ``console = false`` (default), you can also use ``conn`` database methods (in this case, only the binary protocol is supported)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:198
msgid "`connect_timeout`: number of seconds to wait before returning \"error: Connection timed out\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:200
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:201
msgid "possible options are `wait_connected`, `reconnect_after`, `call_16` and `console`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:202
msgid "conn object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:207
msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:219
msgid "Execute a PING command."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:221
msgid "true on success, false on error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:226
msgid "net_box.self:ping()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:234
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:236
#: ../doc/1.7/reference/reference_lua/net_box.rst:268
msgid "in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:237
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:242
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:250
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:252
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:257
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:265
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:267
msgid "target states"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:269
msgid "true when a target state is reached, false on timeout or connection closure"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:274
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:289
msgid "Close a connection."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:291
msgid "Connection objects are garbage collected just like any other objects in Lua, so an explicit destruction is not mandatory. However, since close() is a system call, it is good programming practice to close a connection explicitly when it is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:298
msgid "conn:close()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:306
msgid ":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:311
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:317
msgid "Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, so global variables or database tuples data may change when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:328
msgid ":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:333
msgid "conn.space.testspace:get({1})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:341
msgid ":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:346
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:354
msgid ":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:359
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:367
msgid ":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:372
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:380
msgid ":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:387
msgid ":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:394
msgid "``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of ``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure call."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:398
msgid "Limitation: the called function cannot return a function, for example if ``func2`` is defined as ``function func2 () return func end`` then ``conn:call(func2)`` will return \"error: unsupported Lua type 'function'\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:404
msgid ""
"conn:call('function5')\n"
"conn:call('fx',{1,'B'},{timeout=99})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:413
msgid ":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-string, which may be any statement or series of statements. An :ref:`execute privilege <authentication-owners_privileges>` is required; if the user does not have it, an administrator may grant it with :samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:421
msgid ""
"conn:eval('return 5+5')\n"
"conn:eval('return ...', {1,2,3})\n"
"conn:eval('return 5+5, {}, {timeout=0.1})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:431
msgid "``timeout(...)`` is a wrapper which sets a timeout for the request that follows it. Since version 1.7.4 this method is deprecated -- it is better to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:437
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:441
msgid "Although ``timeout(...)`` is deprecated, all remote calls support its use. Using a wrapper object makes the remote connection API compatible with the local one, removing the need for a separate ``timeout`` argument, which the local version would ignore. Once a request is sent, it cannot be revoked from the remote server even if a timeout expires: the timeout expiration only aborts the wait for the remote server response, not the request itself."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:453
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:455
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:457
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:458
msgid "there is a space named ``tester`` with a numeric primary key and with a tuple that contains a key value = 800,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:460
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:462
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:464
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"box.cfg{listen = 3301}\n"
"        s = box.schema.space.create('tester')\n"
"        s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"        t = s:insert({800, 'TEST'})\n"
"        box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../doc/1.7/reference/reference_lua/net_box.rst:472
msgid "And here starts the example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:474
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not 3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:5
msgid "Module `os`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:13
msgid "The ``os`` module contains the functions :ref:`execute() <os-execute>`, :ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() <os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, :ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, :ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most of these functions are described in the Lua manual Chapter 22 `The Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:30
msgid "Below is a list of all ``os`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:40
msgid ":ref:`os.execute() <os-execute>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:40
msgid "Execute by passing to the shell"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:43
msgid ":ref:`os.rename() <os-rename>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:46
msgid ":ref:`os.getenv() <os-getenv>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:46
msgid "Get an environment variable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:49
msgid ":ref:`os.remove() <os-remove>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:49
msgid "Remove a file or directory"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:52
msgid ":ref:`os.date() <os-date>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:52
msgid "Get a formatted date"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:55
msgid ":ref:`os.exit() <os-exit>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:55
msgid "Exit the program"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:58
msgid ":ref:`os.time() <os-time>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:58
msgid "Get the number of seconds since the epoch"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:61
msgid ":ref:`os.clock() <os-clock>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:61
msgid "Get the number of CPU seconds since the program start"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:64
msgid ":ref:`os.tmpname() <os-tmpname>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:64
msgid "Get the name of a temporary file"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:67
msgid ":ref:`os.environ() <os-environ>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:67
msgid "Get a table with all environment variables"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:70
msgid ":ref:`os.setenv() <os-setenv>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:70
msgid "Set an environment variable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:73
msgid ":ref:`os.setlocale() <os-setlocale>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:73
msgid "Change the locale"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:76
msgid ":ref:`os.difftime() <os-difftime>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:76
msgid "Get the number of seconds between two times"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:84
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:86
msgid "what to execute."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:90
msgid ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:106
msgid "Rename a file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:108
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:109
msgid "changed name of file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:113
msgid ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:126
msgid "Get environment variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:128
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:132
msgid ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:143
msgid "Remove file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:145
msgid "Parameters: (string) name = name of file or directory which will be removed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:149
msgid ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:160
msgid "Return a formatted date."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:162
msgid "Parameters: (string) format-string = instructions; (string) time-since-epoch = number of seconds since 1970-01-01. If time-since-epoch is omitted, it is assumed to be the current time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:167
#, python-format
msgid ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:178
msgid "Exit the program. If this is done on a server instance, then the instance stops."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:182
msgid ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:191
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:195
msgid ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:206
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:210
msgid ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:221
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:225
msgid ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:236
msgid "Return a table containing all environment variables."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:240
msgid ""
"tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:251
msgid "Set an environment variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:255
msgid ""
"tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:266
msgid "Change the locale. If new-locale-string is not specified, return the current locale."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:271
msgid ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:282
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:286
msgid ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:3
msgid "Miscellaneous"
msgstr "Разное"

#: ../doc/1.7/reference/reference_lua/other.rst:9
msgid "Below is a list of miscellaneous functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:19
msgid ":ref:`tonumber64() <other-tonumber64>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:19
msgid "Convert a string or a Lua number to a 64-bit integer"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:22
msgid ":ref:`dostring() <other-dostring>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:22
msgid "Parse and execute an arbitrary chunk of Lua code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:30
msgid "Convert a string or a Lua number to a 64-bit integer. The input value can be expressed in decimal, binary (for example 0b1010), or hexadecimal (for example -0xffff). The result can be used in arithmetic, and the arithmetic will be 64-bit integer arithmetic rather than floating-point arithmetic. (Operations on an unconverted Lua number use floating-point arithmetic.) The ``tonumber64()`` function is added by Tarantool; the name is global."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:40
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:65
msgid "Parse and execute an arbitrary chunk of Lua code. This function is mainly useful to define and run Lua code without having to introduce changes to the global Lua environment."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:69
msgid "Lua code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:70
msgid "zero or more scalar values which will be appended to, or substitute for, items in the Lua chunk."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:73
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:75
msgid "Possible errors: If there is a compilation error, it is raised as a Lua error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:80
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:3
msgid "Module `pickle`"
msgstr "Модуль `pickle`"

#: ../doc/1.7/reference/reference_lua/pickle.rst:9
msgid "Below is a list of all ``pickle`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:19
msgid ":ref:`pickle.pack() <pickle-pack>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:19
msgid "Convert Lua variables to binary format"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:22
msgid ":ref:`pickle.unpack() <pickle-unpack>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:22
msgid "Convert Lua variables back from binary format"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:32
msgid "To use Tarantool binary protocol primitives from Lua, it's necessary to convert Lua variables to binary format. The ``pickle.pack()`` helper function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:38
msgid "**Format specifiers**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:43
msgid "b, B"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:43
msgid "converts Lua scalar value to a 1-byte integer, and stores the integer in the resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:46
msgid "s, S"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:46
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:50
msgid "i, I"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:50
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:54
msgid "l, L"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:54
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:58
msgid "n"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:58
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:62
msgid "N"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:62
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, big"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:65
msgid "q, Q"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:65
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:69
msgid "f"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:69
msgid "converts Lua scalar value to a 4-byte float, and stores the float in the resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:72
msgid "d"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:72
msgid "converts Lua scalar value to a 8-byte double, and stores the double in the resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:75
msgid "a, A"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:75
msgid "converts Lua scalar value to a sequence of bytes, and stores the sequence in the resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:79
msgid "string containing format specifiers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:80
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:81
msgid "a binary string containing all arguments, packed according to the format specifiers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:85
msgid "A scalar value can be either a variable or a literal. Remember that large integers should be entered with :ref:`tonumber64() or LL or ULL suffixes <index-box_number>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:89
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:93
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:129
msgid "Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, it must be the last item."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:135
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:140
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:5
msgid "Module `socket`"
msgstr "Модуль `socket`"

#: ../doc/1.7/reference/reference_lua/socket.rst:11
msgid "The ``socket`` module allows exchanging data via BSD sockets with a local or remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. Semantics of the calls in the ``socket`` API closely follow semantics of the corresponding POSIX calls. Function names and signatures are mostly compatible with `luasocket`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:17
msgid "The functions for setting up and connecting are ``socket``, ``sysconnect``, ``tcp_connect``. The functions for sending data are ``send``, ``sendto``, ``write``, ``syswrite``. The functions for receiving data are ``recv``, ``recvfrom``, ``read``. The functions for waiting before sending/receiving data are ``wait``, ``readable``, ``writable``. The functions for setting flags are ``nonblock``, ``setsockopt``. The functions for stopping and disconnecting are ``shutdown``, ``close``. The functions for error checking are ``errno``, ``error``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:30
msgid "Below is a list of all ``socket`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:40
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:40
msgid "Create a socket"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:42
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:42
#: ../doc/1.7/reference/reference_lua/socket.rst:51
msgid "Connect a socket to a remote host"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:45
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:45
msgid "Get information about a remote site"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:48
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:48
msgid "Make Tarantool act as a TCP server"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:51
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:54
msgid ":ref:`socket_object:send() <socket-send>` |br| :ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:54
msgid "Send data over a connected socket"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:57
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:57
msgid "Write data to the socket buffer if non-blocking"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:60
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:60
msgid "Read from a connected socket"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:62
msgid ":ref:`socket_object:sysread() <socket-sysread>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:62
msgid "Read data from the socket buffer if non-blocking"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:65
msgid ":ref:`socket_object:bind() <socket-bind>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:65
msgid "Bind a socket to the given host/port"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:68
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:68
msgid "Start listening for incoming connections"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:71
msgid "Accept a client connection + create a connected socket"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:74
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:74
msgid "Send a message on a UDP socket to a specified host"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:77
msgid "Receive a message on a UDP socket"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:80
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:80
msgid "Shut down a reading end, a writing end, or both"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:83
msgid "Close a socket"
msgstr "Закрытие сокета"

#: ../doc/1.7/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:error() <socket-error>` |br| :ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:85
msgid "Get information about the last error on a socket"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:88
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:88
msgid "Set socket flags"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:90
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:90
msgid "Get socket flags"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:92
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:92
msgid "Set/clear the SO_LINGER flag"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:94
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:94
msgid "Set/get the flag value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:96
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:96
msgid "Wait until something is readable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:99
msgid "Wait until something is writable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:102
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:102
msgid "Wait until something is either readable or writable"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:105
msgid "Get information about the connection's near side"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:108
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:108
msgid "Get information about the connection's far side"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:111
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:111
msgid "Wait for read/write activity"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:114
msgid "Typically a socket session will begin with the setup functions, will set one or more flags, will have a loop with sending and receiving functions, will end with the teardown functions -- as an example at the end of this section will show. Throughout, there may be error-checking and waiting functions for synchronization. To prevent a fiber containing socket functions from \"blocking\" other fibers, the :ref:`implicit yield rules <atomic-implicit-yields>` will cause a yield so that other processes may take over, as is the norm for :ref:`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:123
msgid "For all examples in this section the socket name will be sock and the function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:132
msgid "Create a new TCP or UDP socket. The argument values are the same as in the `Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:135
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:140
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:148
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:150
#: ../doc/1.7/reference/reference_lua/socket.rst:340
#: ../doc/1.7/reference/reference_lua/socket.rst:380
msgid "URL or IP address"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:151
#: ../doc/1.7/reference/reference_lua/socket.rst:341
#: ../doc/1.7/reference/reference_lua/socket.rst:381
msgid "port number"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:152
msgid "timeout"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:153
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:158
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:166
msgid "The ``socket.getaddrinfo()`` function is useful for finding information about a remote site so that the correct arguments for ``sock:sysconnect()`` can be passed. This function may use the :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:172
#: ../doc/1.7/reference/reference_lua/socket.rst:544
#: ../doc/1.7/reference/reference_lua/socket.rst:556
msgid "A table containing these fields: \"host\", \"family\", \"type\", \"protocol\", \"port\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:177
msgid ""
"tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:197
msgid "The ``socket.tcp_server()`` function makes Tarantool act as a server that can accept connections. Usually the same objective is accomplished with :ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:201
msgid "host name or IP"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:202
msgid "host port, may be 0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:203
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:205
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:208
msgid "The handler-function parameter may be a function name (for example ``function_55``), a function declaration (for example ``function () print('!') end``), or a table including handler = function (for example ``{handler=function_55, name='A'}``)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:215
msgid "``socket.tcp_server('localhost', 3302, function () end)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:223
msgid "Connect an existing socket to a remote host. The argument values are the same as in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an IP address."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:240
msgid "Parameters:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:230
msgid "Either:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:229
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:231
msgid "port - a number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:233
#: ../doc/1.7/reference/reference_lua/socket.rst:240
msgid "Or:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:233
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:234
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:236
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:238
msgid "port - a number. If a port number is 0 (zero), the socket will be bound to a random local port."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:242
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:247
msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:258
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:260
#: ../doc/1.7/reference/reference_lua/socket.rst:382
msgid "what is to be sent"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:261
#: ../doc/1.7/reference/reference_lua/socket.rst:384
msgid "the number of bytes sent."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:264
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:270
msgid "Write as much data as possible to the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:277
msgid "Read ``size`` bytes from a connected socket. An internal read-ahead buffer is used to reduce the cost of this call."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:281
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:284
msgid "Possible errors: On error, returns an empty string, followed by status, errno, errstr. In case the writing side has closed its end, returns the remainder read from the socket (possibly an empty string), followed by \"eof\" status."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:297
msgid "Read from a connected socket until some condition is true, and return the bytes that were read. Reading goes on until ``limit`` bytes have been read, or a delimiter has been read, or a timeout has expired."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:302
#: ../doc/1.7/reference/reference_lua/socket.rst:324
msgid "maximum number of bytes to read, for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:304
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:306
msgid "maximum number of seconds to wait for example 50 means \"stop after 50 seconds\"."
msgstr "максимальное количество секунд ожидания, например, 50 означает \"остановиться через 50 секунд\"."

#: ../doc/1.7/reference/reference_lua/socket.rst:309
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``limit`` bytes long, which may include the bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:319
msgid "Return data from the socket buffer if non-blocking. In case the socket is blocking, ``sysread()`` can block the calling process. Rarely used. For details, see also `this description <https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:327
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:335
msgid "Bind a socket to the given host/port. A UDP socket after binding can be used to receive data (see :ref:`socket_object.recvfrom <socket-recvfrom>`). A TCP socket can be used to accept new connections, after it has been put in listen mode."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:346
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:352
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:354
msgid "On Linux the listen ``backlog`` backlog may be from /proc/sys/net/core/somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:358
msgid "true for success, false for error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:359
msgid "boolean."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:365
msgid "Accept a new client connection and create a new connected socket. It is good practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:369
msgid "new socket if success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:372
msgid "Possible errors: nil."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:378
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:387
msgid "Possible errors: on error, returns nil and may return status, errno, errstr."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:393
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:396
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:397
msgid "string, table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:399
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:403
msgid "After ``message_content, message_sender = recvfrom(1)`` the value of ``message_content`` might be a string containing 'X' and the value of ``message_sender`` might be a table containing"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:407
msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:417
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:419
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:421
#: ../doc/1.7/reference/reference_lua/tap.rst:142
#: ../doc/1.7/reference/reference_lua/tap.rst:165
#: ../doc/1.7/reference/reference_lua/tap.rst:199
#: ../doc/1.7/reference/reference_lua/tap.rst:234
#: ../doc/1.7/reference/reference_lua/tap.rst:247
#: ../doc/1.7/reference/reference_lua/tap.rst:257
#: ../doc/1.7/reference/reference_lua/tap.rst:272
#: ../doc/1.7/reference/reference_lua/tap.rst:293
#: ../doc/1.7/reference/reference_lua/tap.rst:312
msgid "true or false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:428
msgid "Close (destroy) a socket. A closed socket should not be used any more. A socket is closed automatically when its userdata is garbage collected by Lua."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:431
msgid "true on success, false on error. For example, if sock is already closed, sock:close() returns false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:440
msgid "Retrieve information about the last error that occurred on a socket, if any. Errors do not cause throwing of exceptions so these functions are usually necessary."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:443
msgid "result for ``sock:errno()``, result for ``sock:error()``. If there is no error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:445
msgid "number, string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:451
msgid "Set socket flags. The argument values are the same as in the `Linux getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:455
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:456
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:457
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:458
msgid "SO_DEBUG"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:459
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:460
msgid "SO_ERROR"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:461
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:462
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:463
msgid "SO_MARK"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:464
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:465
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:466
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:467
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:468
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:469
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:470
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:471
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:472
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:473
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:474
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:475
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:476
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:477
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:478
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:479
msgid "SO_TYPE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:481
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:487
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:493
msgid "Set or clear the SO_LINGER flag. For a description of the flag, see the `Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:498
msgid "new active and timeout values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:504
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:505
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:506
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:508
msgid "This function may be useful before invoking a function which might otherwise block indefinitely."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:515
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:517
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:523
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:525
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:531
msgid "Wait until something is either readable or writable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:533
msgid "'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' if the socket is now both readable and writable, '' (empty string) if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:539
msgid "The ``sock:name()`` function is used to get information about the near side of the connection. If a socket was bound to ``xyz.com:45``, then ``sock:name`` will return information about ``[host:xyz.com, port:45]``. The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:551
msgid "The ``sock:peer()`` function is used to get information about the far side of a connection. If a TCP connection has been made to a distant host ``tarantool.org:80``, ``sock:peer()`` will return information about ``[host:tarantool.org, port:80]``. The equivalent POSIX function is ``getpeername()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:563
msgid "The ``socket.iowait()`` function is used to wait until read-or-write activity occurs for a file descriptor."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:566
msgid "file descriptor"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:567
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:568
msgid "number of seconds to wait"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:570
msgid "If the fd parameter is nil, then there will be a sleep until the timeout. If the timeout parameter is nil or unspecified, then timeout is infinite."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:573
msgid "Ordinarily the return value is the activity that occurred ('R' or 'W' or 'RW' or 1 or 2 or 3). If the timeout period goes by without any reading or writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:577
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:585
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:587
msgid "In this example a connection is made over the internet between a Tarantool instance and tarantool.org, then an HTTP \"head\" message is sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something else if the site has moved. This is not a useful way to communicate with this particular site, but shows that the system works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:593
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:624
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:626
msgid "Here is an example with datagrams. Set up two connections on 127.0.0.1 (localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to ``sock_1``. Using ``sock_1``, receive a message. Display the received message. Close both connections. |br| This is not a useful way for a computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:632
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:669
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:671
msgid "Here is an example of the tcp_server function, reading strings from the client and printing them. On the client side, the Linux socat utility will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:676
msgid "Start two shells. The first shell will be a server instance. The second shell will be the client."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:679
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:681
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:696
msgid "The above code means: use `tcp_server()` to wait for a connection from any host on port 3302. When it happens, enter a loop that reads on the socket and prints what it reads. The \"delimiter\" for the read function is \"\\\\n\" so each `read()` will read a string as far as the next line feed, including the line feed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:703
msgid "On the second shell, create a file that contains a few lines. The contents don't matter. Suppose the first line contains A, the second line contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:708
msgid "On the second shell, use the socat utility to ship the tmp.txt file to the server instance's host and port:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:711
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:715
msgid "Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" are printed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:5
msgid "Module `strict`"
msgstr "Модуль `strict`"

#: ../doc/1.7/reference/reference_lua/strict.rst:9
msgid "The :code:`strict` module has functions for turning \"strict mode\" on or off. When strict mode is on, an attempt to use an undeclared global variable will cause an error. A global variable is considered \"undeclared\" if it has never had a value assigned to it. Often this is an indication of a programming error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:14
msgid "By default strict mode is off, unless tarantool was built with the ``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:20
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:5
msgid "Module `string`"
msgstr "Модуль `string`"

#: ../doc/1.7/reference/reference_lua/string.rst:13
msgid "The :code:`string` module has everything in the `standard Lua string library <https://www.lua.org/pil/20.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:17
msgid "In this section we only discuss the additional functions that the Tarantool developers have added."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:20
msgid "Below is a list of all additional ``string`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:30
msgid ":ref:`string.ljust() <string-ljust>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:30
msgid "Left-justify a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:33
msgid ":ref:`string.rjust() <string-rjust>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:33
msgid "Right-justify a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:36
msgid ":ref:`string.hex() <string-hex>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:36
msgid "Get the hexadecimal value of a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:39
msgid ":ref:`string.startswith() <string-startswith>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:39
msgid "Check if a string starts with a given substring"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:42
msgid ":ref:`string.endswith() <string-endswith>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:42
msgid "Check if a string ends with a given substring"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:45
msgid ":ref:`string.lstrip() <string-lstrip>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:45
msgid "Remove spaces on the left of a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:48
msgid ":ref:`string.rstrip() <string-rstrip>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:48
msgid "Remove spaces on the right of a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:51
msgid ":ref:`string.strip() <string-strip>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:51
msgid "Remove spaces on the left and right of a string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:59
msgid "Return the string left-justified in a string of length ``width``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:61
msgid "(string) the string to left-justify"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:62
msgid "(integer) the width of the string after left-justifying"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:63
#: ../doc/1.7/reference/reference_lua/string.rst:88
msgid "(string) a single character, default = 1 space"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:65
msgid "left-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:70
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:84
msgid "Return the string right-justified in a string of length ``width``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:86
msgid "(string) the string to right-justify"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:87
msgid "(integer) the width of the string after right-justifying"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:90
msgid "right-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:95
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:109
msgid "Return the hexadecimal value of the input string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:111
#: ../doc/1.7/reference/reference_lua/string.rst:222
#: ../doc/1.7/reference/reference_lua/string.rst:245
#: ../doc/1.7/reference/reference_lua/string.rst:268
msgid "(string) the string to process"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:113
msgid "hexadecimal, 2 hex-digit characters for each input character"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:118
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:132
msgid "Return True if ``input-string`` starts with ``start-string``, otherwise return False."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:135
msgid "(string) the string where ``start-string`` should be looked for"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:136
#: ../doc/1.7/reference/reference_lua/string.rst:166
msgid "(string) the string to look for"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:137
#: ../doc/1.7/reference/reference_lua/string.rst:167
msgid "(integer) position: where to start looking within ``input-string``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:138
#: ../doc/1.7/reference/reference_lua/string.rst:168
msgid "(integer) position: where to end looking within ``input-string``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:143
#: ../doc/1.7/reference/reference_lua/string.rst:173
msgid "``start-pos`` and ``end-pos`` may be negative, meaning the position should be calculated from the end of the string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:148
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:162
msgid "Return True if ``input-string`` ends with ``end-string``, otherwise return False."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:165
msgid "(string) the string where ``end-string`` should be looked for"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:178
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:192
msgid "Split ``input-string`` into one or more output strings in a table. The places to split are the places where ``split-string`` occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:196
msgid "(string) the string to split"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:197
msgid "(string) the string to find within ``input-string``. Default = space."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:200
msgid "table of strings that were split from ``input-string``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:205
msgid ""
"tarantool> fiber = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A*BXX C\", \"XX\")\n"
"---\n"
"- - A*B\n"
"  - ' C'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:220
msgid "Return the value of the input string, but without spaces on the left."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:224
#: ../doc/1.7/reference/reference_lua/string.rst:247
#: ../doc/1.7/reference/reference_lua/string.rst:270
msgid "result after stripping spaces from input string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:229
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:243
msgid "Return the value of the input string, but without spaces on the right."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:252
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:266
msgid "Return the value of the input string, but without spaces on the left or the right."
msgstr ""

#: ../doc/1.7/reference/reference_lua/string.rst:275
msgid ""
"tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/table.rst:5
msgid "Module `table`"
msgstr "Модуль `table`"

#: ../doc/1.7/reference/reference_lua/table.rst:9
msgid "The :code:`table` module has everything in the `standard Lua table library <https://www.lua.org/pil/19.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/table.rst:13
msgid "You can see this by saying \"table\":"
msgstr ""

#: ../doc/1.7/reference/reference_lua/table.rst:15
msgid ""
"tarantool> table\n"
"---\n"
"- maxn: 'function: builtin#90'\n"
"  copy: 'function: 0x41e9d300'\n"
"  new: 'function: builtin#94'\n"
"  clear: 'function: builtin#95'\n"
"  move: 'function: 0x41e918e0'\n"
"  foreach: 'function: 0x41e91588'\n"
"  sort: 'function: builtin#93'\n"
"  remove: 'function: 0x41e917c8'\n"
"  foreachi: 'function: 0x41e914b8'\n"
"  deepcopy: 'function: 0x41e9d2e0'\n"
"  getn: 'function: 0x41e91620'\n"
"  concat: 'function: builtin#92'\n"
"  insert: 'function: builtin#91'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/table.rst:34
msgid "In this section we only discuss the additional function that the Tarantool developers have added: ``deepcopy``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/table.rst:41
msgid "Return a \"deep\" copy of the table -- a copy which follows nested structures to any depth and does not depend on pointers, it copies the contents."
msgstr ""

#: ../doc/1.7/reference/reference_lua/table.rst:45
msgid "(table) the table to copy"
msgstr ""

#: ../doc/1.7/reference/reference_lua/table.rst:47
msgid "the copy of the table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/table.rst:52
msgid ""
"tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:3
msgid "Module `tap`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:9
msgid "The ``tap`` module streamlines the testing of other modules. It allows writing of tests in the `TAP protocol`_. The results from the tests can be parsed by standard TAP-analyzers so they can be passed to utilities such as `prove`_. Thus one can run tests and then use the results for statistics, decision-making, and so on."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:19
msgid "Below is a list of all ``tap`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:29
msgid ":ref:`tap.test() <tap-test>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:29
msgid "Initialize"
msgstr "Инициализация"

#: ../doc/1.7/reference/reference_lua/tap.rst:32
msgid ":ref:`taptest:test() <taptest-test>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:32
msgid "Create a subtest and print the results"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:35
msgid ":ref:`taptest:plan() <taptest-plan>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:35
msgid "Indicate how many tests to perform"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:38
msgid ":ref:`taptest:check() <taptest-check>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:38
msgid "Check the number of tests performed"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:41
msgid ":ref:`taptest:diag() <taptest-diag>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:41
msgid "Display a diagnostic message"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:44
msgid ":ref:`taptest:ok() <taptest-ok>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:44
#: ../doc/1.7/reference/reference_lua/tap.rst:47
#: ../doc/1.7/reference/reference_lua/tap.rst:50
msgid "Evaluate the condition and display the message"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:47
msgid ":ref:`taptest:fail() <taptest-fail>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:50
msgid ":ref:`taptest:skip() <taptest-skip>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:53
msgid ":ref:`taptest:is() <taptest-is>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:53
msgid "Check if the two arguments are equal"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:56
msgid ":ref:`taptest:isnt() <taptest-isnt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:56
msgid "Check if the two arguments are different"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:59
msgid ":ref:`taptest:is_deeply() <taptest-is_deeply>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:59
msgid "Recursively check if the two arguments are equal"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:62
msgid ":ref:`taptest:like() <taptest-like>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:62
msgid "Check if the argument matches a pattern"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:65
msgid ":ref:`taptest:unlike() <taptest-unlike>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:65
msgid "Check if the argument does not match a pattern"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:68
msgid ":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() <taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| :ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() <taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| :ref:`taptest:iscdata() <taptest-istype>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:74
msgid "Check if a value has a particular type"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:90
msgid "Initialize."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:92
msgid "The result of ``tap.test`` is an object, which will be called taptest in the rest of this discussion, which is necessary for ``taptest:plan()`` and all the other methods."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:96
#: ../doc/1.7/reference/reference_lua/tap.rst:117
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:97
#: ../doc/1.7/reference/reference_lua/tap.rst:119
msgid "taptest"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:100
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:111
msgid "Create a subtest (if no ``func`` argument specified), or (if all arguments are specified) create a subtest, run the test function and print the result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:115
msgid "See the :ref:`example <tap-example>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:118
msgid "the test logic to run."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:120
msgid "userdata or string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:126
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:135
msgid "Checks the number of tests performed. This check should only be done after all planned tests are complete, so ordinarily ``taptest:check()`` will only appear at the end of a script."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:139
msgid "Will display ``# bad plan: ...`` if the number of completed tests is not equal to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:149
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:151
msgid "the message to be displayed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:158
msgid "This is a basic function which is used by other functions. Depending on the value of ``condition``, print 'ok' or 'not ok' along with debugging information. Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:162
msgid "an expression which is true or false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:163
#: ../doc/1.7/reference/reference_lua/tap.rst:197
#: ../doc/1.7/reference/reference_lua/tap.rst:210
#: ../doc/1.7/reference/reference_lua/tap.rst:233
#: ../doc/1.7/reference/reference_lua/tap.rst:245
#: ../doc/1.7/reference/reference_lua/tap.rst:262
#: ../doc/1.7/reference/reference_lua/tap.rst:277
#: ../doc/1.7/reference/reference_lua/tap.rst:291
#: ../doc/1.7/reference/reference_lua/tap.rst:310
msgid "name of the test"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:170
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:194
msgid "``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:206
msgid "``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# skip')``. Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:216
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:228
msgid "Check whether the first argument equals the second argument. Displays extensive message if the result is false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:231
#: ../doc/1.7/reference/reference_lua/tap.rst:243
#: ../doc/1.7/reference/reference_lua/tap.rst:260
#: ../doc/1.7/reference/reference_lua/tap.rst:275
#: ../doc/1.7/reference/reference_lua/tap.rst:289
msgid "actual result"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:232
#: ../doc/1.7/reference/reference_lua/tap.rst:244
#: ../doc/1.7/reference/reference_lua/tap.rst:261
msgid "expected result"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:241
msgid "This is the negation of :ref:`taptest:is() <taptest-is>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:254
msgid "Recursive version of ``taptest:is(...)``, which can be be used to compare tables as well as scalar values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:268
msgid "Verify a string against a `pattern <http://lua-users.org/wiki/PatternsTutorial>`_. Ok if match is found."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:276
#: ../doc/1.7/reference/reference_lua/tap.rst:290
msgid "pattern"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:279
msgid "test:like(tarantool.version, '^[1-9]', \"version\")"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:287
msgid "This is the negation of :ref:`taptest:like() <taptest-like>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:306
msgid "Test whether a value has a particular type. Displays a long message if the value is not of the specified type."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:324
msgid "To run this example: put the script in a file named ./tap.lua, then make tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:328
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:342
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:344
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:5
msgid "Module `tarantool`"
msgstr "Модуль `tarantool`"

#: ../doc/1.7/reference/reference_lua/tarantool.rst:9
msgid "By saying ``require('tarantool')``, one can answer some questions about how the tarantool server was built, such as \"what flags were used\", or \"what was the version of the compiler\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:15
msgid "Additionally one can see the uptime and the server version and the process id. Those information items can also be accessed with :ref:`box.info() <box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:22
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector -fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""
"tarantool> tarantool = require('tarantool')\n"
"        ---\n"
"        ...\n"
"        tarantool> tarantool\n"
"        ---\n"
"        - build:\n"
"            target: Linux-x86_64-RelWithDebInfo\n"
"            options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"            mod_format: so\n"
"            flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector -fexceptions\n"
"              -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign- compare -Wno-strict-aliasing\n"
"              -fno-gnu89-inline'\n"
"            compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++ \n"
"          uptime: 'function: 0x408668e0'\n"
"          version: 1.7.0-66-g9093daa\n"
"          pid: 'function: 0x40866900'\n"
"        ...\n"
"        tarantool> tarantool.pid()\n"
"        ---\n"
"        - 30155\n"
"        ...\n"
"        tarantool> tarantool.uptime()\n"
"        ---\n"
"        - 108.64641499519\n"
"        ..."

#: ../doc/1.7/reference/reference_lua/uri.rst:3
msgid "Module `uri`"
msgstr "Модуль `uri`"

#: ../doc/1.7/reference/reference_lua/uri.rst:9
msgid "A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard <https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:13
msgid "[scheme:]scheme-specific-part[#fragment]"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:17
msgid "A common type, a hierarchical URI, looks like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:19
msgid "[scheme:][//authority][path][?query][#fragment]"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:23
msgid "For example the string ``'https://tarantool.org/x.html#y'`` has three components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:26
msgid "``https`` is the scheme,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:27
msgid "``tarantool.org/x.html`` is the path,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:28
msgid "``y`` is the fragment."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:30
msgid "Tarantool's URI module provides routines which convert URI strings into their components, or turn components into URI strings."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:37
msgid "Below is a list of all ``uri`` functions."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:47
msgid ":ref:`uri.parse() <uri-parse>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:47
msgid "Get a table of URI components"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:50
msgid ":ref:`uri.format() <uri-format>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:50
msgid "Construct a URI from components"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:60
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:61
msgid "URI-components-table. Possible components are fragment, host, login, password, path, query, scheme, service."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:63
msgid "Table"
msgstr "Таблица"

#: ../doc/1.7/reference/reference_lua/uri.rst:67
msgid ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:84
msgid "a series of name:value pairs, one for each component"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:86
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:91
msgid ""
"tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:3
msgid "Module `uuid`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:9
msgid "A \"UUID\" is a `Universally unique identifier`_. If an application requires that a value be unique only within a single computer or on a single database, then a simple counter is better than a UUID, because getting a UUID is time-consuming (it requires a syscall_). For clusters of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:19
msgid "Below is list of all ``uuid`` functions and members."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:29
msgid ":ref:`uuid.nil <uuid-nil>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:29
#: ../doc/1.7/reference/reference_lua/uuid.rst:54
msgid "A nil object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:31
msgid ":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| :ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:32
msgid "Get a UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:35
msgid ":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| :ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:38
msgid "Get a converted UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:44
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:44
msgid "Check if a UUID is an all-zero value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:60
#: ../doc/1.7/reference/reference_lua/uuid.rst:67
#: ../doc/1.7/reference/reference_lua/uuid.rst:74
msgid "a UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:68
msgid "16-byte string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:75
msgid "36-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:81
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:82
#: ../doc/1.7/reference/reference_lua/uuid.rst:90
msgid "converted UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:89
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:99
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:101
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:102
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:103
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:104
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:106
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:108
#: ../doc/1.7/reference/reference_lua/uuid.rst:115
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:109
msgid "16-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:116
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:122
msgid "The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an all-zero value can also be expressed as ``uuid_with_type_cdata == uuid.NULL``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:127
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:134
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:5
msgid "Module `xlog`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:7
msgid "The xlog module contains one function: ``pairs()``. It can be used to read Tarantool's :ref:`snapshot files<index-box_persistence>` or :ref:`write-ahead-log (WAL) <internals-wal>` files. A description of the file format is in section :ref:`Data persistence and the WAL file format <internals-data_persistence>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:19
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst
msgid "returns"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:21
msgid "iterator  which can be used in a for/end loop."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:22
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:24
msgid "Possible errors: File does not contain properly formatted snapshot or write-ahead-log information."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:29
msgid "This will read the first write-ahead-log (WAL) file that was created in the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting started\" exercises <getting_started>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:33
msgid "Each result from ``pairs()`` is formatted with MsgPack so its structure can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:36
msgid ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:45
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:47
msgid ""
"(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:5
msgid "Module `yaml`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:11
msgid "The ``yaml`` module takes strings in YAML_ format and decodes them, or takes a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:18
msgid "Below is a list of all ``yaml`` functions and members."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:28
msgid ":ref:`yaml.encode() <yaml-encode>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:28
msgid "Convert a Lua object to a YAML string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:31
msgid ":ref:`yaml.decode() <yaml-decode>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:31
msgid "Convert a YAML string to a Lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:34
msgid ":ref:`yaml.NULL <yaml-null>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:44
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:47
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:54
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:56
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:70
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:93
msgid "The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:96
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:97
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:98
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:99
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:104
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:140
msgid "Also, some YAML configuration settings for encoding can be changed, in the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:5
msgid "SQL DBMS Modules"
msgstr "Модули SQL СУБД"

#: ../doc/1.7/reference/reference_rock/dbms.rst:7
msgid "The discussion here in the reference is about incorporating and using two modules that have already been created: the \"SQL DBMS rocks\" for MySQL and PostgreSQL."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:11
msgid "To call another DBMS from Tarantool, the essential requirements are: another DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be called a \"connector\". Within the module there is a shared library which may be called a \"driver\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:16
msgid "Tarantool supplies DBMS connector modules with the module manager for Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:19
msgid "The Tarantool rocks allow for connecting to SQL servers and executing SQL statements the same way that a MySQL or PostgreSQL client does. The SQL statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that was all Tarantool could do. But of course Tarantool is also a DBMS, so the module also is useful for any operations, such as database copying and accelerating, which work best when the application can work on both SQL and Tarantool inside the same Lua routine. The methods for connect/select/insert/etc. are similar to the ones in the :ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:30
msgid "From a user's point of view the MySQL and PostgreSQL rocks are very similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- contain some redundancy."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:38
msgid "MySQL Example"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:40
msgid "This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been installed. Recent MariaDB versions will also work, the MariaDB C connector is used. The package that matters most is the MySQL client developer package, typically named something like libmysqlclient-dev. The file that matters most from this package is libmysqlclient.so or a similar name. One can use ``find`` or ``whereis`` to see what directories these files are installed in."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:47
msgid "It will be necessary to install Tarantool's MySQL driver shared library, load it, and use it to connect to a MySQL server instance. After that, one can pass any MySQL statement to the server instance and receive results, including multiple result sets."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:53
#: ../doc/1.7/reference/reference_rock/dbms.rst:406
msgid "Installation"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:55
#: ../doc/1.7/reference/reference_rock/dbms.rst:408
msgid "Check the instructions for `downloading and installing a binary package <http://tarantool.org/download.html>`_ that apply for the environment where Tarantool was installed. In addition to installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:65
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:69
#: ../doc/1.7/reference/reference_rock/dbms.rst:422
msgid "With LuaRocks"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:71
#: ../doc/1.7/reference/reference_rock/dbms.rst:424
msgid "Begin by installing luarocks and making sure that tarantool is among the upstream servers, as in the instructions on `rocks.tarantool.org`_, the Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:112
msgid ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:84
msgid "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:90
#: ../doc/1.7/reference/reference_rock/dbms.rst:443
msgid "With GitHub"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:92
msgid "Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:94
msgid ""
"$ git clone https://github.com/tarantool/mysql.git\n"
"$ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:101
#: ../doc/1.7/reference/reference_rock/dbms.rst:454
msgid "At this point it is a good idea to check that the installation produced a file named ``driver.so``, and to check that this file is on a directory that is searched by the ``require`` request."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:107
#: ../doc/1.7/reference/reference_rock/dbms.rst:460
msgid "Connecting"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:109
msgid "Begin by making a ``require`` request for the mysql driver. We will assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:112
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:116
#: ../doc/1.7/reference/reference_rock/dbms.rst:469
msgid "Now, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:123
#: ../doc/1.7/reference/reference_rock/dbms.rst:476
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:125
#: ../doc/1.7/reference/reference_rock/dbms.rst:478
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:126
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:127
#: ../doc/1.7/reference/reference_rock/dbms.rst:480
msgid ":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:128
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:129
#: ../doc/1.7/reference/reference_rock/dbms.rst:482
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:130
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:132
msgid "The option names, except for `raise`, are similar to the names that MySQL's mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option should be set to :codenormal:`true` if errors should be raised when encountered. To connect with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:139
#: ../doc/1.7/reference/reference_rock/dbms.rst:486
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:141
msgid ""
"conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:157
#: ../doc/1.7/reference/reference_rock/dbms.rst:498
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:159
msgid ""
"tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:175
#: ../doc/1.7/reference/reference_rock/dbms.rst:517
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:179
#: ../doc/1.7/reference/reference_rock/dbms.rst:521
msgid "How to ping"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:181
#: ../doc/1.7/reference/reference_rock/dbms.rst:523
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:220
#: ../doc/1.7/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:190
#: ../doc/1.7/reference/reference_rock/dbms.rst:532
msgid ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:199
#: ../doc/1.7/reference/reference_rock/dbms.rst:541
msgid "Executing a statement"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:201
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:240
#: ../doc/1.7/reference/reference_rock/dbms.rst:582
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:208
#: ../doc/1.7/reference/reference_rock/dbms.rst:550
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any question marks (\"?\"s) in the SQL statement."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:214
msgid ""
"tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:227
#: ../doc/1.7/reference/reference_rock/dbms.rst:568
msgid "Closing connection"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:229
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:268
#: ../doc/1.7/reference/reference_rock/dbms.rst:609
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:238
#: ../doc/1.7/reference/reference_rock/dbms.rst:579
msgid ""
"tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:244
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:251
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of MySQL had been installed on ~/mysql-5.5. The mysqld server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:255
msgid ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:336
msgid "Configure tarantool and load mysql module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:339
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:347
msgid "Create a Lua function that will connect to the MySQL server instance, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:352
msgid ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:376
msgid "Observe the result. It contains \"MySQL row\". So this is the row that was inserted into the MySQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:383
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:385
msgid "This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More recent versions should also work. The package that matters most is the PostgreSQL developer package, typically named something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:390
msgid "$ sudo apt-get install libpq-dev"
msgstr "$ sudo apt-get install libpq-dev"

#: ../doc/1.7/reference/reference_rock/dbms.rst:394
msgid "However, because not all platforms are alike, for this example the assumption is that the user must check that the appropriate PostgreSQL files are present and must explicitly state where they are when building the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to see what directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:400
msgid "It will be necessary to install Tarantool's PostgreSQL driver shared library, load it, and use it to connect to a PostgreSQL server instance. After that, one can pass any PostgreSQL statement to the server instance and receive results."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:418
msgid "Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:465
msgid ""
"luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:437
msgid "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:445
msgid "Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:447
msgid ""
"$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:462
msgid "Begin by making a ``require`` request for the pg driver. We will assume that the name is ``pg`` in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:465
msgid "pg = require('pg')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:479
msgid ":samp:`port = {port-number}` - number, default value = 5432"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:481
msgid ":samp:`pass = {password}` or :samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:484
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:488
msgid ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:500
msgid ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:543
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:556
msgid ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:570
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:585
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:592
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of PostgreSQL had been installed on /usr. The PostgreSQL server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:596
msgid ""
"$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:670
msgid "Configure tarantool and load pg module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:673
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:681
msgid "Create a Lua function that will connect to a PostgreSQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:686
msgid ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:711
msgid "Observe the result. It contains \"PostgreSQL row\". So this is the row that was inserted into the PostgreSQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:5
msgid "Module `expirationd`"
msgstr "Модуль `expirationd`"

#: ../doc/1.7/reference/reference_rock/expirationd.rst:7
msgid "For a commercial-grade example of a Lua rock that works with Tarantool, let us look at expirationd, which Tarantool supplies on GitHub_ with an Artistic license. The expirationd.lua program is lengthy (about 500 lines), so here we will only highlight the matters that will be enhanced by studying the full source later."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:12
msgid ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:20
msgid "Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done with a :doc:`fiber<../reference_lua/fiber>`. The program is making a fiber and turning control over to it so it runs occasionally, goes to sleep, then comes back for more."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:25
msgid ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:34
msgid "The \"for\" instruction can be translated as \"iterate through the index of the space that is being scanned\", and within it, if the tuple is \"expired\" (for example, if the tuple has a timestamp field which is less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:39
msgid ""
"-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    local key = fun.map(\n"
"        function(x) return tuple[x.fieldno] end,\n"
"        box.space[space_id].index[0].parts\n"
"    ):totable()\n"
"    box.space[space_id]:delete(key)\n"
"end"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:50
msgid "Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which does a \"delete\" of a tuple from its original space. First the fun :ref:`fun <fun-module>` module is used, specifically fun.map_. Remembering that :codenormal:`index[0]` is always the space's primary key, and :codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is always the field number for key part :codeitalic:`N`, fun.map() is creating a table from the primary-key values of the tuple. The result of fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:60
msgid ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, options)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:65
msgid "At this point, if the above explanation is worthwhile, it's clear that ``expirationd.lua`` starts a background routine (fiber) which iterates through all the tuples in a space, sleeps cooperatively so that other fibers can operate at the same time, and - whenever it finds a tuple that has expired - deletes it from this space. Now the \"``expirationd_run_task()``\" function can be used in a test which creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:74
msgid "For those who like to see things run, here are the exact steps to get expirationd through the test."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:77
msgid "Get ``expirationd.lua``. There are standard ways - it is after all part of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_  - but for this purpose just copy the contents of expirationd.lua_ to a default directory."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:80
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:81
msgid "Execute these requests:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:83
msgid ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:106
msgid "The database-specific requests (``cfg``, :ref:`space.create <box_schema-space_create>`, :ref:`create_index <box_space-create_index>`) should already be familiar."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:111
msgid "The function which will be supplied to expirationd is :codenormal:`is_tuple_expired`, which is saying \"if the second field of the tuple is less than the :ref:`current time <fiber-time>`  , then return true, otherwise return false\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:116
msgid "The key for getting the rock rolling is ``expd = require('expirationd')``. The \"``require``\" function is what reads in the program; it will appear in many later examples in this manual, when it's necessary to get a module that's not part of the Tarantool kernel. After the Lua variable expd has been assigned the value of the expirationd module, it's possible to invoke the module's ``run_task()`` function."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:123
msgid "After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had time to do its iterations through the spaces, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 0\". After sleeping for two more seconds, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 1\". This shows that the is_tuple_expired() function eventually returned \"true\" for one of the tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:133
msgid "Of course, expirationd can be customized to do different things by passing different parameters, which will be evident after looking in more detail at the source code."
msgstr ""

#: ../doc/1.7/reference/reference_rock/index.rst:3
msgid "Rocks reference"
msgstr "Справочник по сторонним библиотекам"

#: ../doc/1.7/reference/reference_rock/index.rst:5
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:5
msgid "Module `shard`"
msgstr "Модуль `shard`"

#: ../doc/1.7/reference/reference_rock/shard.rst:9
msgid "With sharding, the tuples of a tuple set are distributed to multiple nodes, with a Tarantool database server instance on each node. With this arrangement, each instance is handling only a subset of the total data, so larger loads can be handled by simply adding more computers to a network."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:14
msgid "The Tarantool `shard` module has facilities for creating shards, as well as analogues for the data-manipulation functions of the box library (select, insert, replace, update, delete)."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:18
msgid "First some terminology:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:21
msgid "**Consistent hash**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:23
msgid "The `shard` module distributes according to a hash algorithm, that is, it applies a hash function to a tuple's primary-key value in order to decide which shard the tuple belongs to. The hash function is `consistent <https://en.wikipedia.org/wiki/Consistent_hashing>`_ so that changing the number of servers will not affect results for many keys. The specific hash function that the `shard` module uses is :ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:30
msgid "**Instance**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:32
msgid "A currently-running in-memory copy of the Tarantool server, sometimes called a \"server instance\". Usually each shard is associated with one instance, or, if both sharding and replicating are going on, each shard is associated with one replica set."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:36
msgid "**Queue**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:38
msgid "A temporary list of recent update requests. Sometimes called \"batching\". Since updates to a sharded database can be slow, it may speed up throughput to send requests to a queue rather than wait for the update to finish on every node. The `shard` module has functions for adding requests to the queue, which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:44
msgid "**Redundancy**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:46
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:47
msgid "**Replica**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:49
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:50
msgid "**Replica set**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:52
msgid "Often a single shard is associated with a single instance; however, often the shard is replicated. When a shard is replicated, the multiple instances (\"replicas\"), which handle the shard's replicated data, are a \"replica set\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:56
msgid "**Replicated data**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:58
msgid "A complete copy of the data. The `shard` module handles both sharding and replication. One shard can contain one or more replicated data copies. When a write occurs, the write is attempted on every replicated data copy in turn. The `shard` module does not use the built-in replication feature."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:62
msgid "**Shard**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:64
msgid "A subset of the tuples in the database partitioned according to the value returned by the consistent hash function. Usually each shard is on a separate node, or a separate set of nodes (for example if redundancy = 3 then the shard will be on three nodes)."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:68
msgid "**Zone**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:70
msgid "A physical location where the nodes are closely connected, with the same security and backup and access points. The simplest example of a zone is a single computer with a single Tarantool-server instance. A shard's replicated data copies should be in different zones."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:75
msgid "The `shard` package is distributed separately from the main `tarantool` package. To acquire it, do a separate installation:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:78
msgid "with Tarantool 1.7.4+, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:80
msgid "$ tarantoolctl rocks install shard"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:84
msgid "install with `yum` or `apt`, for example on Ubuntu say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:90
msgid "or download from GitHub `tarantool/shard` and use the Lua files as described in the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:93
msgid "Then, before using the module, say ``shard = require('shard')``."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:95
msgid "The most important function is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:134
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:102
msgid "This must be called for every shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:104
msgid "The shard configuration is a table with these fields:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:106
msgid "`servers` (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:107
msgid "`login` (the user name which applies for accessing via the `shard` module)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:108
msgid "`password` (the password for the login)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:109
msgid "`redundancy` (a number, minimum 1)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:110
msgid "`binary` (a port number that this host is listening on, on the current host, (distinguishable from the 'listen' port specified by `box.cfg`)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:113
msgid "Possible errors:"
msgstr "Возможные ошибки:"

#: ../doc/1.7/reference/reference_rock/shard.rst:115
msgid "redundancy should not be greater than the number of servers;"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:116
msgid "the servers must be alive;"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:117
msgid "two replicated data copies of the same shard should not be in the same zone."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:121
msgid "Example: `shard.init` syntax for one shard"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:123
msgid "The number of replicated data copies per shard (redundancy) is 3."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:124
msgid "The number of instances is 3."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:125
msgid "The `shard` module will conclude that there is only one shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:127
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:148
msgid "Example: `shard.init` syntax for three shards"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:150
msgid "This describes three shards. Each shard has two replicated data copies. Since the number of servers is 7, and the number of replicated data copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be used. This is not necessarily an error, because perhaps one of the servers in the list is not alive."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:155
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:178
msgid "Every data-access function in the `box` module has an analogue in the `shard` module:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:218
msgid ""
"shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:191
msgid "For example, to insert in table T in a sharded database you simply say ``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:194
msgid "A ``shard.T:select{}`` request without a primary key will search all shards."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:196
msgid "Every queued data-access function has an analogue in the `shard` module:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:235
msgid ""
"shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:208
msgid "The user must add an `operation_id`. For details of queued data-access functions, and of maintenance-related functions, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:214
msgid "Example: shard, minimal configuration"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:216
msgid "There is only one shard, and that shard contains only one replicated data copy. So this isn't illustrating the features of either replication or sharding, it's only illustrating what the syntax is, and what the messages look like, that anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:222
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_1\n"
"        $ cd ~/tarantool_sandbox_1\n"
"        $ rm -r *.snap\n"
"        $ rm -r *.xlog\n"
"        $ ~/tarantool-1.7/src/tarantool\n"
"        \n"
"        tarantool> box.cfg{listen = 3301}\n"
"        tarantool> box.schema.space.create('tester')\n"
"        tarantool> box.space.tester:create_index('primary', {})\n"
"        tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"        tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"        tarantool> cfg = {\n"
"                 >   servers = {\n"
"                 >       { uri = 'localhost:3301', zone = '1' },\n"
"                 >   },\n"
"                 >   login = 'test_user';\n"
"                 >   password = 'pass';\n"
"                 >   redundancy = 1;\n"
"                 >   binary = 3301;\n"
"                 > }\n"
"        tarantool> shard = require('shard')\n"
"        tarantool> shard.init(cfg)\n"
"        tarantool> -- Теперь ввести что-то...\n"
"        tarantool> shard.tester:insert{1,'Tuple #1'}"

#: ../doc/1.7/reference/reference_rock/shard.rst:249
msgid "If you cut and paste the above, then the result, showing only the requests and responses for `shard.init` and `shard.tester`, should look approximately like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:253
msgid ""
"<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:278
msgid "Example: shard, scaling out"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:280
msgid "There are two shards, and each shard contains one replicated data copy. This requires two nodes. In real life the two nodes would be two computers, but for this illustration the requirement is merely: start two shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:285
msgid "On Terminal #1, say:"
msgstr "В первом терминале (Terminal #1) введите:"

#: ../doc/1.7/reference/reference_rock/shard.rst:287
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_1\n"
"        $ cd ~/tarantool_sandbox_1\n"
"        $ rm -r *.snap\n"
"        $ rm -r *.xlog\n"
"        $ ~/tarantool-1.7/src/tarantool\n"
"        \n"
"        tarantool> box.cfg{listen = 3301}\n"
"        tarantool> box.schema.space.create('tester')\n"
"        tarantool> box.space.tester:create_index('primary', {})\n"
"        tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"        tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"        tarantool> console = require('console')\n"
"        tarantool> cfg = {\n"
"                 >   servers = {\n"
"                 >     { uri = 'localhost:3301', zone = '1' },\n"
"                 >     { uri = 'localhost:3302', zone = '2' },\n"
"                 >   },\n"
"                 >   login = 'test_user',\n"
"                 >   password = 'pass',\n"
"                 >   redundancy = 1,\n"
"                 >   binary = 3301,\n"
"                 > }\n"
"        tarantool> shard = require('shard')\n"
"        tarantool> shard.init(cfg)\n"
"        tarantool> -- Теперь ввести что-то ...\n"
"        tarantool> shard.tester:insert{1,'Tuple #1'}"

#: ../doc/1.7/reference/reference_rock/shard.rst:316
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:318
msgid ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""
"$ mkdir ~/tarantool_sandbox_2\n"
"        $ cd ~/tarantool_sandbox_2\n"
"        $ rm -r *.snap\n"
"        $ rm -r *.xlog\n"
"        $ ~/tarantool-1.7/src/tarantool\n"
"        \n"
"        tarantool> box.cfg{listen = 3302}\n"
"        tarantool> box.schema.space.create('tester')\n"
"        tarantool> box.space.tester:create_index('primary', {})\n"
"        tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"        tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"        tarantool> console = require('console')\n"
"        tarantool> cfg = {\n"
"                 >   servers = {\n"
"                 >     { uri = 'localhost:3301', zone = '1' };\n"
"                 >     { uri = 'localhost:3302', zone = '2' };\n"
"                 >   };\n"
"                 >   login = 'test_user';\n"
"                 >   password = 'pass';\n"
"                 >   redundancy = 1;\n"
"                 >   binary = 3302;\n"
"                 > }\n"
"        tarantool> shard = require('shard')\n"
"        tarantool> shard.init(cfg)\n"
"        tarantool> -- Теперь вывести что-то ...\n"
"        tarantool> shard.tester:select{1}"

#: ../doc/1.7/reference/reference_rock/shard.rst:347
msgid "What will appear on Terminal #1 is: a loop of error messages saying \"Connection refused\" and \"server check failure\". This is normal. It will go on until Terminal #2 process starts."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:351
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:353
msgid ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:360
msgid "This shows that what was inserted by Terminal #1 can be selected by Terminal #2, via the `shard` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:363
msgid "For details, see the `README <https://github.com/tarantool/shard>`_."
msgstr "Для получения подробной информации см. файл `README <https://github.com/tarantool/shard>`_."

#: ../doc/1.7/reference/reference_rock/tdb.rst:3
msgid "Module `tdb`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:5
msgid "The Tarantool Debugger (abbreviation = ``tdb``) can be used with any Lua program. The operational features include: setting breakpoints, examining variables, going forward one line at a time, backtracing, and showing information about fibers. The display features include: using different colors for different situations, including line numbers, and adding hints."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:11
msgid "It is not supplied as part of the Tarantool repository; it must be installed separately. Here is the usual way:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:14
msgid ""
"$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"
msgstr ""
"$ git clone --recursive https://github.com/Sulverus/tdb\n"
"      $ cd tdb\n"
"      $ make\n"
"      $ sudo make install prefix=/usr/share/tarantool/"

#: ../doc/1.7/reference/reference_rock/tdb.rst:21
msgid "To initiate ``tdb`` within a Lua program and set a breakpoint, edit the program to include these lines:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:24
msgid ""
"tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:29
msgid "To start the debugging session, execute the Lua program. Execution will stop at the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:34
msgid "Debugger Commands"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:38
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:37
msgid "Backtrace -- show the stack (in red), with program/function names and line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:41
msgid ":codebold:`c`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:41
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:48
msgid ":codebold:`e`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:44
msgid "Enter evaluation mode. When the program is in evaluation mode, one can execute certain Lua statements that would be valid in the context. This is particularly useful for displaying the values of the program's variables. Other debugger commands will not work until one exits evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:51
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:51
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:55
msgid ":codebold:`f`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:54
msgid "Display the fiber id, the program name, and the percentage of memory used, as a table."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:58
msgid ":codebold:`n`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:58
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:61
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:61
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:64
msgid ":codebold:`h`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:64
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:68
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:67
msgid "Display names and values of variables, for example the control variables of a Lua \"for\" statement."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:71
msgid ":codebold:`q`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:71
msgid "Quit immediately."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:75
msgid "Example Session"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:77
msgid "Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:79
msgid ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:87
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:89
msgid "$ tarantool example.lua"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:93
#: ../doc/1.7/reference/reference_rock/tdb.rst:118
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:132
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:105
msgid "Debugger prompts are blue, debugger hints and information are green, and the current line -- line 3 of example.lua -- is the default color. Now enter six debugger commands:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:109
msgid ""
"n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:157
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:140
msgid "Another debugger example can be found `here <https://github.com/sulverus/tdb>`_."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:5
msgid "Utility `tarantoolctl`"
msgstr "Утилита `tarantoolctl`"

#: ../doc/1.7/reference/tarantoolctl.rst:7
msgid "``tarantoolctl`` is a utility for administering Tarantool :ref:`instances <tarantoolctl-instance_management>`, :ref:`checkpoint files <tarantoolctl-checkpoint_management>` and :ref:`modules <tarantoolctl-module_management>`. It is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:13
msgid "See also ``tarantoolctl`` usage examples in :ref:`Server administration <admin>` section."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:20
msgid "Command format"
msgstr "Формат команд"

#: ../doc/1.7/reference/tarantoolctl.rst:22
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:26
msgid "``COMMAND`` is one of the following: ``start``, ``stop``, ``status``, ``restart``, ``logrotate``, ``check``, ``enter``, ``eval``, ``connect``, ``cat``, ``play``, ``rocks``."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:30
msgid "``NAME`` is the name of an :ref:`instance file <admin-instance_file>` or a :ref:`module <app_server-modules>`."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:33
msgid "``FILE`` is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:35
msgid "``URI`` is the URI of some Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:37
msgid "``OPTIONS`` are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:43
msgid "Commands for managing Tarantool instances"
msgstr "Команды для управления экземплярами Tarantool'а"

#: ../doc/1.7/reference/tarantoolctl.rst:46
msgid "``tarantoolctl start NAME``"
msgstr "``tarantoolctl start NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:46
msgid "Start a Tarantool instance."
msgstr "Запуск экземпляра Tarantool’а."

#: ../doc/1.7/reference/tarantoolctl.rst:49
msgid "``tarantoolctl stop NAME``"
msgstr "``tarantoolctl stop NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:49
msgid "Stop a Tarantool instance."
msgstr "Остановка экземпляра Tarantool'а."

#: ../doc/1.7/reference/tarantoolctl.rst:57
msgid "``tarantoolctl status NAME``"
msgstr "``tarantoolctl status NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:52
msgid "Show an instance's status (started/stopped). If pid file exists and an alive control socket exists, the return code is ``0``. Otherwise, the return code is not ``0``."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:56
msgid "Reports typical problems to stderr (e.g. pid file exists and control socket doesn't)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:60
msgid "``tarantoolctl restart NAME``"
msgstr "``tarantoolctl restart NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:60
msgid "Stop and start a Tarantool instance."
msgstr "Остановка и запуск экземпляра Tarantool’а."

#: ../doc/1.7/reference/tarantoolctl.rst:65
msgid "``tarantoolctl logrotate NAME``"
msgstr "``tarantoolctl logrotate NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:63
msgid "Rotate logs of a started Tarantool instance. Works only if logging-into-file is enabled in the instance file. Pipe/syslog make no effect."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:68
msgid "``tarantoolctl check NAME``"
msgstr "``tarantoolctl check NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:68
msgid "Check an instance file for syntax errors."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:71
msgid "``tarantoolctl enter NAME``"
msgstr "``tarantoolctl enter NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:71
msgid "Enter an instance's interactive Lua console."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:74
msgid "``tarantoolctl eval NAME FILE``"
msgstr "``tarantoolctl eval NAME FILE``"

#: ../doc/1.7/reference/tarantoolctl.rst:74
msgid "Evaluate a local Lua file on a running Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:78
msgid "``tarantoolctl connect URI``"
msgstr "``tarantoolctl connect URI``"

#: ../doc/1.7/reference/tarantoolctl.rst:77
msgid "Connect to a Tarantool instance on an admin-console port. Supports both TCP/Unix sockets."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:84
msgid "Commands for managing checkpoint files"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:87
msgid "``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:87
msgid "Print into stdout the contents of .snap/.xlog files."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:90
msgid "``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:90
msgid "Play the contents of .snap/.xlog files to another Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:92
msgid "Supported options:"
msgstr "Поддерживаемые опции:"

#: ../doc/1.7/reference/tarantoolctl.rst:94
msgid "``--space=space_no`` to filter the output by space number. May be passed more than once."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:96
msgid "``--show-system`` to show the contents of system spaces."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:97
msgid "``--from=from_lsn`` to show operations starting from the given lsn."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:98
msgid "``--to=to_lsn`` to show operations ending with the given lsn."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:99
msgid "``--replica=replica_id`` to filter the output by replica id. May be passed more than once."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:106
msgid "Commands for managing Tarantool modules"
msgstr "Команды для управления модулями Tarantool'а"

#: ../doc/1.7/reference/tarantoolctl.rst:109
msgid "``tarantoolctl rocks install NAME``"
msgstr "``tarantoolctl rocks install NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:109
msgid "Install a module in the current directory."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:112
msgid "``tarantoolctl rocks remove NAME``"
msgstr "``tarantoolctl rocks remove NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:112
msgid "Remove a module."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:115
msgid "``tarantoolctl rocks show NAME``"
msgstr "``tarantoolctl rocks show NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:115
msgid "Show information about an installed module."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:118
msgid "``tarantoolctl rocks search NAME``"
msgstr "``tarantoolctl rocks search NAME``"

#: ../doc/1.7/reference/tarantoolctl.rst:118
msgid "Search the repository for modules."
msgstr "Поиск модулей по репозиторию."

#: ../doc/1.7/reference/tarantoolctl.rst:120
msgid "``tarantoolctl rocks list``"
msgstr "``tarantoolctl rocks list``"

#: ../doc/1.7/reference/tarantoolctl.rst:121
msgid "List all installed modules."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:3
msgid "C tutorial"
msgstr "Практическое задание на C"

#: ../doc/1.7/tutorials/c_tutorial.rst:5
msgid "Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-c_stored_procedures>`."
msgstr "Ниже приводится практическое занятие на языке C: :ref:`Хранимые процедуры на языке C <f_c_tutorial-c_stored_procedures>`."

#: ../doc/1.7/tutorials/c_tutorial.rst:12
msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

#: ../doc/1.7/tutorials/c_tutorial.rst:14
msgid "Tarantool can call C code with :ref:`modules <app_server-modules>`, or with :ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This tutorial only is about the third option, C stored procedures. In fact the routines are always \"C functions\" but the phrase \"stored procedure\" is commonly used for historical reasons."
msgstr "Tarantool может вызывать код на языке C с помощью :ref:`модулей <app_server-modules>`, :ref:`ffi <cookbook-ffi_printf>` или хранимых процедур на C. В данном практическом задании рассматривается только третий метод, хранимые процедуры на языке C. На самом деле, программы всегда представляют собой функции на языке C, но исторически сложилось так, что широко используется фраза \"хранимая процедура\"."

#: ../doc/1.7/tutorials/c_tutorial.rst:21
msgid "In this tutorial, which can be followed by anyone with a Tarantool development package and a C compiler, there are five tasks:"
msgstr "Данное практическое задание могут выполнить те, у кого есть пакет программ для разработки Tarantool'а и компилятор языка программирования C. Оно состоит из пяти задач:"

#: ../doc/1.7/tutorials/c_tutorial.rst:24
msgid ":ref:`easy.c <f_c_tutorial-easy>` -- prints \"hello world\";"
msgstr ":ref:`easy.c <f_c_tutorial-easy>` — выводит \"hello world\";"

#: ../doc/1.7/tutorials/c_tutorial.rst:25
msgid ":ref:`harder.c <f_c_tutorial-harder>` -- decodes a passed parameter value;"
msgstr ":ref:`harder.c <f_c_tutorial-harder>` — декодирует переданное значение параметра;"

#: ../doc/1.7/tutorials/c_tutorial.rst:26
msgid ":ref:`hardest.c <f_c_tutorial-hardest>` -- uses the C API to do a DBMS insert;"
msgstr ":ref:`hardest.c <f_c_tutorial-hardest>` — использует API для языка C для вставки в базу данных;"

#: ../doc/1.7/tutorials/c_tutorial.rst:27
msgid ":ref:`read.c <f_c_tutorial-read>` -- uses the C API to do a DBMS select;"
msgstr ":ref:`read.c <f_c_tutorial-read>` — использует API для языка C для выборки из базы данных;"

#: ../doc/1.7/tutorials/c_tutorial.rst:28
msgid ":ref:`write.c <f_c_tutorial-write>` -- uses the C API to do a DBMS replace."
msgstr ":ref:`write.c <f_c_tutorial-write>` — использует API для языка C для замены в базе данных."

#: ../doc/1.7/tutorials/c_tutorial.rst:30
msgid "After following the instructions, and seeing that the results are what is described here, users should feel confident about writing their own stored procedures."
msgstr "По окончании задания, вы увидите описанные здесь результаты и сможете самостоятельно написать хранимые процедуры."

#: ../doc/1.7/tutorials/c_tutorial.rst:34
msgid "**Preparation**"
msgstr "**Подготовка**"

#: ../doc/1.7/tutorials/c_tutorial.rst:36
msgid "Check that these items exist on the computer:"
msgstr "Проверьте наличие следующих элементов на компьютере:"

#: ../doc/1.7/tutorials/c_tutorial.rst:38
msgid "Tarantool 1.7"
msgstr "Tarantool 1.7"

#: ../doc/1.7/tutorials/c_tutorial.rst:39
msgid "A gcc compiler, any modern version should work"
msgstr "Компилятор GCC, подойдет любая современная версия"

#: ../doc/1.7/tutorials/c_tutorial.rst:40
msgid "``module.h`` and files #included in it"
msgstr "``module.h`` и включенные в него файлы"

#: ../doc/1.7/tutorials/c_tutorial.rst:41
msgid "``msgpuck.h``"
msgstr "``msgpuck.h``"

#: ../doc/1.7/tutorials/c_tutorial.rst:42
msgid "``libmsgpuck.a`` (only for some recent msgpuck versions)"
msgstr "``libmsgpuck.a`` (только для некоторых последних версий msgpuck)"

#: ../doc/1.7/tutorials/c_tutorial.rst:44
msgid "The ``module.h`` file will exist if Tarantool 1.7 was installed from source. Otherwise Tarantool's \"developer\" package must be installed. For example on Ubuntu say:"
msgstr "Файл ``module.h`` есть в системе, если Tarantool 1.7 был установлен из исходных файлов. В противном случае, следует установить пакет Tarantool'а \"developer\". Например, на Ubuntu введите команду:"

#: ../doc/1.7/tutorials/c_tutorial.rst:52
msgid "or on Fedora say:"
msgstr "или на Fedora введите команду:"

#: ../doc/1.7/tutorials/c_tutorial.rst:54
msgid "$ dnf -y install tarantool-devel"
msgstr "$ dnf -y install tarantool-devel"

#: ../doc/1.7/tutorials/c_tutorial.rst:58
msgid "The ``msgpuck.h`` file will exist if Tarantool 1.7 was installed from source. Otherwise the \"msgpuck\" package must be installed from `https://github.com/rtsisyk/msgpuck <https://github.com/rtsisyk/msgpuck>`_."
msgstr "Файл ``msgpuck.h`` есть в системе, если Tarantool 1.7 был установлен из исходных файлов. В противном случае, следует установить пакет \"msgpuck\" по ссылке `https://github.com/rtsisyk/msgpuck <https://github.com/rtsisyk/msgpuck>`_."

#: ../doc/1.7/tutorials/c_tutorial.rst:62
msgid "Both ``module.h`` and ``msgpuck.h`` must be on the include path for the C compiler to see them. For example, if ``module.h`` address is ``/usr/local/include/tarantool/module.h``, and ``msgpuck.h`` address is ``/usr/local/include/msgpuck/msgpuck.h``, and they are not currently on the include path, say:"
msgstr "Чтобы компилятор C увидел файлы ``module.h`` и ``msgpuck.h``, путь к ним следует сохранить в переменной. Например, если адрес файла ``module.h`` — ``/usr/local/include/tarantool/module.h``, а адрес файла ``msgpuck.h`` — ``/usr/local/include/msgpuck/msgpuck.h``, введите команду:"

#: ../doc/1.7/tutorials/c_tutorial.rst:68
msgid "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"
msgstr "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"

#: ../doc/1.7/tutorials/c_tutorial.rst:72
msgid "The ``libmsgpuck.a`` static library is necessary with msgpuck versions produced after February 2017. If and only if you encounter linking problems when using the gcc statements in the examples for this tutorial, you should put ``libmsgpuck.a`` on the path (``libmsgpuck.a`` is produced from both msgpuck and Tarantool source downloads so it should be easy to find). For example, instead of \":code:`gcc -shared -o harder.so -fPIC harder.c`\" for the second example below, you will need to say \":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr "Статическая библиотека ``libmsgpuck.a`` нужна для версий msgpuck старше февраля 2017 года. Только в том случае, если встречаются проблемы соединения при использовании операторов GCC в примерах данного практического задания, в пути следует указывать ``libmsgpuck.a`` (``libmsgpuck.a`` создан из исходных файлов загрузки msgpuck и Tarantool, поэтому его легко найти). Например, вместо \":code:`gcc -shared -o harder.so -fPIC harder.c`\" во втором примере ниже, необходимо ввести \":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."

#: ../doc/1.7/tutorials/c_tutorial.rst:81
msgid "Requests will be done using Tarantool as a :ref:`client <admin-using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr "Tarantool выполняет запросы в качестве :ref:`клиента <admin-using_tarantool_as_a_client>`. Запустите Tarantool и введите эти запросы."

#: ../doc/1.7/tutorials/c_tutorial.rst:85
msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""
"box.cfg{listen=3306}\n"
"    box.schema.space.create('capi_test')\n"
"    box.space.capi_test:create_index('primary')\n"
"    net_box = require('net.box')\n"
"    capi_connection = net_box:new(3306)"

#: ../doc/1.7/tutorials/c_tutorial.rst:93
msgid "In plainer language: create a space named ``capi_test``, and make a connection to self named ``capi_connection``."
msgstr "Проще говоря: создайте спейс под названием ``capi_test``, и выполните соединение с одноименным ``capi_connection``."

#: ../doc/1.7/tutorials/c_tutorial.rst:96
msgid "Leave the client running. It will be necessary to enter more requests later."
msgstr "Не закрывайте клиент. Он понадобится для последующих запросов."

#: ../doc/1.7/tutorials/c_tutorial.rst:100
msgid "**easy.c**"
msgstr "**easy.c**"

#: ../doc/1.7/tutorials/c_tutorial.rst:102
msgid "Start another shell. Change directory (``cd``) so that it is the same as the directory that the client is running on."
msgstr "Запустите еще один терминал. Измените директорию (``cd``), чтобы она совпадала с директорией, где запущен клиент."

#: ../doc/1.7/tutorials/c_tutorial.rst:105
msgid "Create a file. Name it ``easy.c``. Put these six lines in it."
msgstr "Создайте файл. Назовите его ``easy.c``. Запишите в него следующие шесть строк."

#: ../doc/1.7/tutorials/c_tutorial.rst:107
msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"    int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"    {\n"
"      printf(\"hello world\\n\");\n"
"      return 0;\n"
"    }\n"
"    int easy2(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"    {\n"
"      printf(\"hello world -- easy2\\n\");\n"
"      return 0;\n"
"    }"

#: ../doc/1.7/tutorials/c_tutorial.rst:122
msgid "Compile the program, producing a library file named ``easy.so``:"
msgstr "Скомпилируйте программу, что создаст файл библиотеки под названием ``easy.so``:"

#: ../doc/1.7/tutorials/c_tutorial.rst:124
msgid "$ gcc -shared -o easy.so -fPIC easy.c"
msgstr "$ gcc -shared -o easy.so -fPIC easy.c"

#: ../doc/1.7/tutorials/c_tutorial.rst:128
#: ../doc/1.7/tutorials/c_tutorial.rst:216
#: ../doc/1.7/tutorials/c_tutorial.rst:303
#: ../doc/1.7/tutorials/c_tutorial.rst:407
#: ../doc/1.7/tutorials/c_tutorial.rst:488
msgid "Now go back to the client and execute these requests:"
msgstr "Теперь вернитесь в клиент и выполните следующие запросы:"

#: ../doc/1.7/tutorials/c_tutorial.rst:130
msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""
"box.schema.func.create('easy', {language = 'C'})\n"
"    box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"    capi_connection:call('easy')"

#: ../doc/1.7/tutorials/c_tutorial.rst:136
msgid "If these requests appear unfamiliar, re-read the descriptions of :ref:`box.schema.func.create() <box_schema-func_create>`, :ref:`box.schema.user.grant() <box_schema-user_grant>` and :ref:`conn:call() <net_box-call>`."
msgstr "Если эти запросы вам незнакомы, перечитайте описание :ref:`box.schema.func.create() <box_schema-func_create>`, :ref:`box.schema.user.grant() <box_schema-user_grant>` и :ref:`conn:call() <net_box-call>`."

#: ../doc/1.7/tutorials/c_tutorial.rst:142
msgid "The function that matters is ``capi_connection:call('easy')``."
msgstr "Важна функция ``capi_connection:call('easy')``."

#: ../doc/1.7/tutorials/c_tutorial.rst:144
msgid "Its first job is to find the 'easy' function, which should be easy because by default Tarantool looks on the current directory for a file named ``easy.so``."
msgstr "Во-первых, она ищет функцию easy, что должно быть легко, потому что по умолчанию Tarantool ищет в текущей директории файл под названием ``easy.so``."

#: ../doc/1.7/tutorials/c_tutorial.rst:148
msgid "Its second job is to call the 'easy' function. Since the ``easy()`` function in ``easy.c`` begins with ``printf(\"hello world\\n\")``, the words \"hello world\" will appear on the screen."
msgstr "Во-вторых, она вызывает функцию easy. Поскольку функция ``easy()`` в ``easy.c`` начинается с ``printf(\"hello world\\n\")``, слова \"hello world\" появятся на экране."

#: ../doc/1.7/tutorials/c_tutorial.rst:152
msgid "Its third job is to check that the call was successful. Since the ``easy()`` function in ``easy.c`` ends with :code:`return 0`, there is no error message to display and the request is over."
msgstr "В-третьих, она проверяет, что вызов прошел успешно. Поскольку функция ``easy()`` в ``easy.c`` оканчивается на :code:`return 0`, сообщение об ошибке отсутствует, и запрос выполнен."

#: ../doc/1.7/tutorials/c_tutorial.rst:156
#: ../doc/1.7/tutorials/c_tutorial.rst:332
msgid "The result should look like this:"
msgstr "Результат должен выглядеть следующим образом:"

#: ../doc/1.7/tutorials/c_tutorial.rst:158
msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('easy')\n"
"    hello world\n"
"    ---\n"
"    - []\n"
"    ..."

#: ../doc/1.7/tutorials/c_tutorial.rst:166
msgid "Now let's call the other function in easy.c -- ``easy2()``. This is almost the same as the ``easy()`` function, but there's a detail: when the file name is not the same as the function name, then we have to specify :samp:`{file-name}.{function-name}`."
msgstr "Теперь вызовем другую функцию в easy.c — ``easy2()``. Она практически совпадает с функцией ``easy()``, но есть небольшое отличие: если имя файла не совпадет с именем функции, нужно будет указать :samp:`{file-name}.{function-name}`."

#: ../doc/1.7/tutorials/c_tutorial.rst:172
msgid ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"
msgstr ""
"box.schema.func.create('easy.easy2', {language = 'C'})\n"
"    box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"    capi_connection:call('easy.easy2')"

#: ../doc/1.7/tutorials/c_tutorial.rst:178
msgid "... and this time the result will be \"hello world -- easy2\"."
msgstr "... и на этот раз результатом будет: \"hello world -- easy2\"."

#: ../doc/1.7/tutorials/c_tutorial.rst:180
msgid "Conclusion: calling a C function is easy."
msgstr "Вывод: вызвать C-функцию легко."

#: ../doc/1.7/tutorials/c_tutorial.rst:184
msgid "**harder.c**"
msgstr "**harder.c**"

#: ../doc/1.7/tutorials/c_tutorial.rst:186
msgid "Go back to the shell where the ``easy.c`` program was created."
msgstr "Вернитесь в терминал, где была создана программа ``easy.c``."

#: ../doc/1.7/tutorials/c_tutorial.rst:188
msgid "Create a file. Name it ``harder.c``. Put these 17 lines in it:"
msgstr "Создайте файл. Назовите его ``harder.c``. Запишите в него следующие 17 строк:"

#: ../doc/1.7/tutorials/c_tutorial.rst:190
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"    #include \"msgpuck.h\"\n"
"    int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"    {\n"
"      uint32_t arg_count = mp_decode_array(&args);\n"
"      printf(\"arg_count = %d\\n\", arg_count);\n"
"      uint32_t field_count = mp_decode_array(&args);\n"
"      printf(\"field_count = %d\\n\", field_count);\n"
"      uint32_t val;\n"
"      int i;\n"
"      for (i = 0; i < field_count; ++i)\n"
"      {\n"
"        val = mp_decode_uint(&args);\n"
"        printf(\"val=%d.\\n\", val);\n"
"      }\n"
"      return 0;\n"
"    }"

#: ../doc/1.7/tutorials/c_tutorial.rst:210
msgid "Compile the program, producing a library file named ``harder.so``:"
msgstr "Скомпилируйте программу, что создаст файл библиотеки под названием ``harder.so``:"

#: ../doc/1.7/tutorials/c_tutorial.rst:212
msgid "$ gcc -shared -o harder.so -fPIC harder.c"
msgstr "$ gcc -shared -o harder.so -fPIC harder.c"

#: ../doc/1.7/tutorials/c_tutorial.rst:218
msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""
"box.schema.func.create('harder', {language = 'C'})\n"
"    box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"    passable_table = {}\n"
"    table.insert(passable_table, 1)\n"
"    table.insert(passable_table, 2)\n"
"    table.insert(passable_table, 3)\n"
"    capi_connection:call('harder', passable_table)"

#: ../doc/1.7/tutorials/c_tutorial.rst:228
msgid "This time the call is passing a Lua table (``passable_table``) to the ``harder()`` function. The ``harder()`` function will see it, it's in the :code:`char *args` parameter."
msgstr "На этот раз вызов передает Lua-таблицу (``passable_table``) в функцию ``harder()``. Функция``harder()`` увидит это, как указано в параметре :code:`char *args`."

#: ../doc/1.7/tutorials/c_tutorial.rst:232
msgid "At this point the ``harder()`` function will start using functions defined in `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. The routines that begin with \"mp\" are msgpuck functions that handle data formatted according to the MsgPack_ specification. Passes and returns are always done with this format so one must become acquainted with msgpuck to become proficient with the C API."
msgstr "На данный момент функция ``harder()`` начнет использовать функции, определенные в `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. Процедуры, которые начинаются с \"mp\" — это функции msgpuck, которые обрабатывают данные в формате MsgPack_. Передача и возврат всегда осуществляются в этом формате, поэтому следует ознакомиться с msgpuck для того, чтобы овладеть навыками работы с API для языка C."

#: ../doc/1.7/tutorials/c_tutorial.rst:240
msgid "For now, though, it's enough to know that ``mp_decode_array()`` returns the number of elements in an array, and ``mp_decode_uint`` returns an unsigned integer, from :code:`args`. And there's a side effect: when the decoding finishes, :code:`args` has changed and is now pointing to the next element."
msgstr "Однако, пока достаточно понимать, что функция ``mp_decode_array()`` возвращает количество элементов в массиве, а функция ``mp_decode_uint`` возвращает целое число без знака из :code:`args`. Есть также побочный эффект: по окончании декодирования :code:`args` изменился и теперь указывает на следующий элемент."

#: ../doc/1.7/tutorials/c_tutorial.rst:246
msgid "Therefore the first displayed line will be \"arg_count = 1\" because there was only one item passed: ``passable_table``. |br| The second displayed line will be \"field_count = 3\" because there are three items in the table. |br| The next three lines will be \"1\" and \"2\" and \"3\" because those are the values in the items in the table."
msgstr "Таким образом, первой будет отображена строка \"arg_count = 1\", поскольку был передан только один элемент: ``passable_table``. |br| Второй будет отображена строка \"field_count = 3\", потому что в таблице находятся три элемента. |br| Следующие три строки будут \"1\", \"2\" и \"3\", потому что это значения элементов в таблице."

#: ../doc/1.7/tutorials/c_tutorial.rst:253
msgid "And now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.7/tutorials/c_tutorial.rst:255
msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"    arg_count = 1\n"
"    field_count = 3\n"
"    val=1.\n"
"    val=2.\n"
"    val=3.\n"
"    ---\n"
"    - []\n"
"    ..."

#: ../doc/1.7/tutorials/c_tutorial.rst:267
msgid "Conclusion: decoding parameter values passed to a C function is not easy at first, but there are routines to do the job, and they're documented, and there aren't very many of them."
msgstr "Вывод: на первый взгляд, декодирование значений параметров, переданных в C-функцию непросто, но существуют документированные процедуры для этих целей, и их не так много."

#: ../doc/1.7/tutorials/c_tutorial.rst:274
msgid "**hardest.c**"
msgstr "**hardest.c**"

#: ../doc/1.7/tutorials/c_tutorial.rst:276
msgid "Go back to the shell where the ``easy.c`` and the ``harder.c`` programs were created."
msgstr "Вернитесь в терминал, где были созданы программы ``easy.c`` и ``harder.c``."

#: ../doc/1.7/tutorials/c_tutorial.rst:279
msgid "Create a file. Name it ``hardest.c``. Put these 13 lines in it:"
msgstr "Создайте файл. Назовите его ```hardest.c``. Запишите в него следующие 13 строк:"

#: ../doc/1.7/tutorials/c_tutorial.rst:281
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"    #include \"msgpuck.h\"\n"
"    int hardest(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"    {\n"
"      uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"      char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"      char *tuple_pointer = tuple;\n"
"      tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"      tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"      tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"      int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"      return n;\n"
"    }"

#: ../doc/1.7/tutorials/c_tutorial.rst:297
msgid "Compile the program, producing a library file named ``hardest.so``:"
msgstr "Скомпилируйте программу, что создаст файл библиотеки под названием ``hardest.so``:"

#: ../doc/1.7/tutorials/c_tutorial.rst:299
msgid "$ gcc -shared -o hardest.so -fPIC hardest.c"
msgstr "$ gcc -shared -o hardest.so -fPIC hardest.c"

#: ../doc/1.7/tutorials/c_tutorial.rst:305
msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"    box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"    box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"    capi_connection:call('hardest')"

#: ../doc/1.7/tutorials/c_tutorial.rst:312
msgid "This time the C function is doing three things:"
msgstr "На этот раз C-функция выполняет три действия:"

#: ../doc/1.7/tutorials/c_tutorial.rst:314
msgid "finding the numeric identifier of the ``capi_test`` space by calling ``box_space_id_by_name()``;"
msgstr "найдет числовой идентификатор спейса ``capi_test`` путем вызова ``box_space_id_by_name()``;"

#: ../doc/1.7/tutorials/c_tutorial.rst:316
msgid "formatting a tuple using more ``msgpuck.h`` functions;"
msgstr "форматирует кортеж, используя другие функции ``msgpuck.h``;"

#: ../doc/1.7/tutorials/c_tutorial.rst:317
msgid "inserting a tuple using ``box_insert()``."
msgstr "вставит кортеж с помощью ``box_insert()``."

#: ../doc/1.7/tutorials/c_tutorial.rst:321
msgid "``char tuple[1024];`` is used here as just a quick way of saying \"allocate more than enough bytes\". For serious programs the developer must be careful to allow enough space for all the bytes that the ``mp_encode`` routines will use up."
msgstr "``char tuple[1024];`` используется здесь просто в качестве быстрого способа ввода команды \"выделить байтов с запасом\". В серьезных программах разработчику следует обратить внимание на то, чтобы выделить достаточно места, которое будут использовать процедуры ``mp_encode``."

#: ../doc/1.7/tutorials/c_tutorial.rst:326
msgid "Now, still on the client, execute this request:"
msgstr "Затем всё еще в клиенте выполните следующий запрос:"

#: ../doc/1.7/tutorials/c_tutorial.rst:328
msgid "box.space.capi_test:select()"
msgstr "box.space.capi_test:select()"

#: ../doc/1.7/tutorials/c_tutorial.rst:334
msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""
"tarantool> box.space.capi_test:select()\n"
"    ---\n"
"    - - [10000, 'String 2']\n"
"    ..."

#: ../doc/1.7/tutorials/c_tutorial.rst:341
msgid "This proves that the ``hardest()`` function succeeded, but where did :ref:`box_space_id_by_name() <box-box_space_id_by_name>` and :ref:`box_insert() <box-box_insert>` come from? Answer: the :ref:`C API <index-c_api_reference>`."
msgstr "Это доказывает, что функция ``hardest()`` была успешно выполнена, но откуда взялись :ref:`box_space_id_by_name() <box-box_space_id_by_name>` и :ref:`box_insert() <box-box_insert>`? Ответ: :ref:`API для языка C <index-c_api_reference>`."

#: ../doc/1.7/tutorials/c_tutorial.rst:348
msgid "**read.c**"
msgstr "**read.c**"

#: ../doc/1.7/tutorials/c_tutorial.rst:350
msgid "Go back to the shell where the ``easy.c`` and the ``harder.c`` and the ``hardest.c`` programs were created."
msgstr "Вернитесь в терминал, где были созданы программы ``easy.c``, ``harder.c`` и ``hardest.c``."

#: ../doc/1.7/tutorials/c_tutorial.rst:353
msgid "Create a file. Name it ``read.c``. Put these 43 lines in it:"
msgstr "Создайте файл. Назовите его ``read.c``. Запишите в него следующие 43 строки:"

#: ../doc/1.7/tutorials/c_tutorial.rst:355
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"    #include <msgpuck.h>\n"
"    int read(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"    {\n"
"      char tuple_buf[1024];      /* where the raw MsgPack tuple will be stored */\n"
"      uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"      uint32_t index_id = 0;     /* The number of the space's first index */\n"
"      uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"      mp_encode_array(tuple_buf, 0); /* clear */\n"
"      box_tuple_format_t *fmt = box_tuple_format_default();\n"
"      box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"      assert(tuple != NULL);\n"
"      char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"      char *key_end = key_buf;\n"
"      key_end = mp_encode_array(key_end, 1);\n"
"      key_end = mp_encode_uint(key_end, key);\n"
"      assert(key_end < key_buf + sizeof(key_buf));\n"
"      /* Get the tuple. There's no box_select() but there's this. */\n"
"      int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"      assert(r == 0);\n"
"      assert(tuple != NULL);\n"
"      /* Get each field of the tuple + display what you get. */\n"
"      int field_no;             /* The first field number is 0. */\n"
"      for (field_no = 0; field_no < 2; ++field_no)\n"
"      {\n"
"        const char *field = box_tuple_field(tuple, field_no);\n"
"        assert(field != NULL);\n"
"        assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"        if (mp_typeof(*field) == MP_UINT)\n"
"        {\n"
"          uint32_t uint_value = mp_decode_uint(&field);\n"
"          printf(\"uint value=%u.\\n\", uint_value);\n"
"        }\n"
"        else /* if (mp_typeof(*field) == MP_STR) */\n"
"        {\n"
"          const char *str_value;\n"
"          uint32_t str_value_length;\n"
"          str_value = mp_decode_str(&field, &str_value_length);\n"
"          printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"        }\n"
"      }\n"
"      return 0;\n"
"    }"

#: ../doc/1.7/tutorials/c_tutorial.rst:401
msgid "Compile the program, producing a library file named ``read.so``:"
msgstr "Скомпилируйте программу, что создаст файл библиотеки под названием ``read.so``:"

#: ../doc/1.7/tutorials/c_tutorial.rst:403
msgid "$ gcc -shared -o read.so -fPIC read.c"
msgstr "$ gcc -shared -o read.so -fPIC read.c"

#: ../doc/1.7/tutorials/c_tutorial.rst:409
msgid ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""
"box.schema.func.create('read', {language = \"C\"})\n"
"    box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"    box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"    capi_connection:call('read')"

#: ../doc/1.7/tutorials/c_tutorial.rst:416
msgid "This time the C function is doing four things:"
msgstr "На этот раз C-функция выполняет четыре действия:"

#: ../doc/1.7/tutorials/c_tutorial.rst:418
#: ../doc/1.7/tutorials/c_tutorial.rst:499
msgid "once again, finding the numeric identifier of the ``capi_test`` space by calling ``box_space_id_by_name()``;"
msgstr "снова найдет числовой идентификатор спейса ``capi_test`` путем вызова ``box_space_id_by_name()``;"

#: ../doc/1.7/tutorials/c_tutorial.rst:420
msgid "formatting a search key = 10000 using more ``msgpuck.h`` functions;"
msgstr "форматирует ключ поиска = 10 000, используя другие функции ``msgpuck.h``;"

#: ../doc/1.7/tutorials/c_tutorial.rst:421
msgid "getting a tuple using ``box_index_get()``;"
msgstr "получает кортеж с помощью ``box_index_get()``;"

#: ../doc/1.7/tutorials/c_tutorial.rst:422
msgid "going through the tuple's fields with ``box_tuple_get()`` and then decoding each field depending on its type. In this case, since what we are getting is the tuple that we inserted with ``hardest.c``, we know in advance that the type is either MP_UINT or MP_STR; however, it's very common to have a case statement here with one option for each possible type."
msgstr "проходит по полям каждого кортежа с помощью ``box_tuple_get()``. а затем декодирует каждое поле в зависимости от его типа. В данном случае, поскольку мы получаем кортеж, который сами вставили с помощью ``hardest.c``, мы знаем заранее, что его тип будет MP_UINT или MP_STR. Однако, весьма часто здесь употребляется оператор выбора case с одной опцией для каждого возможного типа."

#: ../doc/1.7/tutorials/c_tutorial.rst:429
msgid "The result of ``capi_connection:call('read')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('read')`` должны получить:"

#: ../doc/1.7/tutorials/c_tutorial.rst:431
msgid ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""
"tarantool> capi_connection:call('read')\n"
"    uint value=10000.\n"
"    string value=String 2.\n"
"    ---\n"
"    - []\n"
"    ..."

#: ../doc/1.7/tutorials/c_tutorial.rst:440
msgid "This proves that the ``read()`` function succeeded. Once again the important functions that start with `box` -- :ref:`box_index_get() <c_api-box_index-box_index_get>` and :ref:`box_tuple_field() <c_api-tuple-box_tuple_field>` -- came from the :ref:`C API <index-c_api_reference>`."
msgstr "Это доказывает, что функция ``read()`` была успешно выполнена. И снова важные функции, которые начинаются с `box` — :ref:`box_index_get() <c_api-box_index-box_index_get>` и :ref:`box_tuple_field() <c_api-tuple-box_tuple_field>` — пришли из :ref:``API для языка C <index-c_api_reference>`."

#: ../doc/1.7/tutorials/c_tutorial.rst:448
msgid "**write.c**"
msgstr "**write.c**"

#: ../doc/1.7/tutorials/c_tutorial.rst:450
msgid "Go back to the shell where the programs ``easy.c``, ``harder.c``, ``hardest.c`` and ``read.c`` were created."
msgstr "Вернитесь в терминал, где были созданы программы ``easy.c``, ``harder.c``, ``hardest.c`` и ``read.c``."

#: ../doc/1.7/tutorials/c_tutorial.rst:453
msgid "Create a file. Name it ``write.c``. Put these 24 lines in it:"
msgstr "Создайте файл. Назовите его ``write.c``. Запишите в него следующие 24 строки:"

#: ../doc/1.7/tutorials/c_tutorial.rst:455
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Must be big enough for mp_encode results */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"
msgstr ""
"#include \"module.h\"\n"
"    #include <msgpuck.h>\n"
"    int write(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"    {\n"
"      static const char *space = \"capi_test\";\n"
"      char tuple_buf[1024]; /* Must be big enough for mp_encode results */\n"
"      uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"      if (space_id == BOX_ID_NIL) {\n"
"        return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"        \"Can't find space %s\", \"capi_test\");\n"
"      }\n"
"      char *tuple_end = tuple_buf;\n"
"      tuple_end = mp_encode_array(tuple_end, 2);\n"
"      tuple_end = mp_encode_uint(tuple_end, 1);\n"
"      tuple_end = mp_encode_uint(tuple_end, 22);\n"
"      box_txn_begin();\n"
"      if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"        return -1;\n"
"      box_txn_commit();\n"
"      fiber_sleep(0.001);\n"
"      struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                          tuple_buf, tuple_end);\n"
"      return box_return_tuple(ctx, tuple);\n"
"    }"

#: ../doc/1.7/tutorials/c_tutorial.rst:482
msgid "Compile the program, producing a library file named ``write.so``:"
msgstr "Скомпилируйте программу, что создаст файл библиотеки под названием ``write.so``:"

#: ../doc/1.7/tutorials/c_tutorial.rst:484
msgid "$ gcc -shared -o write.so -fPIC write.c"
msgstr "$ gcc -shared -o write.so -fPIC write.c"

#: ../doc/1.7/tutorials/c_tutorial.rst:490
msgid ""
"box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"
msgstr ""
"box.schema.func.create('write', {language = \"C\"})\n"
"    box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"    box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"    capi_connection:call('write')"

#: ../doc/1.7/tutorials/c_tutorial.rst:497
msgid "This time the C function is doing six things:"
msgstr "На этот раз C-функция выполняет шесть действий:"

#: ../doc/1.7/tutorials/c_tutorial.rst:501
msgid "making a new tuple;"
msgstr "создает новый кортеж;"

#: ../doc/1.7/tutorials/c_tutorial.rst:502
msgid "starting a transaction;"
msgstr "начинает транзакцию;"

#: ../doc/1.7/tutorials/c_tutorial.rst:503
msgid "replacing a tuple in ``box.space.capi_test``"
msgstr "заменяет кортеж в ``box.space.capi_test``"

#: ../doc/1.7/tutorials/c_tutorial.rst:504
msgid "ending a transaction;"
msgstr "заканчивает транзакцию;"

#: ../doc/1.7/tutorials/c_tutorial.rst:505
msgid "the final line is a replacement for the loop in ``read.c`` -- instead of getting each field and printing it, use the ``box_return_tuple(...)`` function to return the entire tuple to the caller and let the caller display it."
msgstr "последняя строка заменяет цикл ``read.c`` — вместо получения и вывода каждого поля, использует функцию ``box_return_tuple(...)`` для возврата всего кортежа вызывающему клиенту, чтобы вывести его на экран."

#: ../doc/1.7/tutorials/c_tutorial.rst:510
msgid "The result of ``capi_connection:call('write')`` should look like this:"
msgstr "В результате вызова ``capi_connection:call('write')`` должны получить:"

#: ../doc/1.7/tutorials/c_tutorial.rst:512
msgid ""
"tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."
msgstr ""
"tarantool> capi_connection:call('write')\n"
"    ---\n"
"    - [[1, 22]]\n"
"    ..."

#: ../doc/1.7/tutorials/c_tutorial.rst:519
msgid "This proves that the ``write()`` function succeeded. Once again the important functions that start with `box` -- :ref:`box_txn_begin() <txn-box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` and :ref:`box_return_tuple() <box-box_return_tuple>` -- came from the :ref:`C API <index-c_api_reference>`."
msgstr "Это доказывает, что функция ``write()`` была успешно выполнена. И снова важные функции, которые начинаются с `box` — :ref:`box_txn_begin() <txn-box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` и :ref:`box_return_tuple() <box-box_return_tuple>` — пришли из :ref:``API для языка C <index-c_api_reference>`."

#: ../doc/1.7/tutorials/c_tutorial.rst:526
msgid "Conclusion: the long description of the whole C API is there for a good reason. All of the functions in it can be called from C functions which are called from Lua. So C \"stored procedures\" have full access to the database."
msgstr "Вывод: длинное описание всего API для языка C необходимо в силу весомых причин. Все функции можно вызвать из C-функций, которые вызываются из Lua. Таким образом, хранимые процедуры на языке C получают полный доступ к базе данных."

#: ../doc/1.7/tutorials/c_tutorial.rst:532
msgid "**Cleaning up**"
msgstr "**Очистка данных**"

#: ../doc/1.7/tutorials/c_tutorial.rst:534
msgid "Get rid of each of the function tuples with :ref:`box.schema.func.drop <box_schema-func_drop>`."
msgstr "Удалите все кортежы с функцией с помощью :ref:`box.schema.func.drop <box_schema-func_drop>`."

#: ../doc/1.7/tutorials/c_tutorial.rst:536
msgid "Get rid of the ``capi_test`` space with :ref:`box.schema.capi_test:drop() <box_space-drop>`."
msgstr "Удалите спейс ``capi_test`` с помощью :ref:`box.schema.capi_test:drop() <box_space-drop>`."

#: ../doc/1.7/tutorials/c_tutorial.rst:538
msgid "Remove the ``.c`` and ``.so`` files that were created for this tutorial."
msgstr "Удалите файлы с разрешением ``.c`` и ``.so``, созданные для данного практического задания."

#: ../doc/1.7/tutorials/c_tutorial.rst:541
msgid "**An example in the test suite**"
msgstr "**Пример из набора тестов**"

#: ../doc/1.7/tutorials/c_tutorial.rst:543
msgid "Download the source code of Tarantool. Look in a subdirectory :code:`test/box`. Notice that there is a file named :code:`tuple_bench.test.lua` and another file named :code:`tuple_bench.c`. Examine the Lua file and observe that it is calling a function in the C file, using the same techniques that this tutorial has shown."
msgstr "Скачайте исходный код Tarantool'а. Откройте поддиректорию :code:`test/box`. Проверьте наличие файла под названием :code:`tuple_bench.test.lua` и еще одного файла под названием :code:`tuple_bench.c`. Изучите Lua-файл на предмет вызова функции в C-файле с использованием методов, описанных в данном практическом задании."

#: ../doc/1.7/tutorials/c_tutorial.rst:550
msgid "Conclusion: parts of the standard test suite use C stored procedures, and they must work, because releases don't happen if Tarantool doesn't pass the tests."
msgstr "Вывод: некоторые тесты из стандартного набора используют хранимые процедуры на языке C, а они должны работать, поскольку мы не можем выпустить Tarantool, если он не прошел тестирование."

#: ../doc/1.7/tutorials/index.rst:5
msgid "Tutorials"
msgstr "Практикум"

#: ../doc/1.7/tutorials/libslave.rst:5
msgid "`libslave` tutorial"
msgstr "Практические задания по `libslave`"

#: ../doc/1.7/tutorials/libslave.rst:7
msgid "``libslave`` is a C++ library for reading data changes done by MysQL and, optionally, writing them to a Tarantool database. It works by acting as a replication slave. The MySQL server writes data-change information to a \"binary log\", and transfers the information to any client that says \"I want to see the information starting with this file and this record, continuously\". So, ``libslave`` is primarily good for making a Tarantool database replica (much faster than using a conventional MySQL slave server), and for keeping track of data changes so they can be searched."
msgstr "``libslave`` представляет собой библиотеку C++ для считывания изменений данных, внесенных с помощью MySQL, а также — опционально — для записи их в базу данных Tarantool'а. Она выступает в качестве ведомого в схеме репликации. Сервер MySQL записывает информацию об изменении данных в бинарный журнал и передает ее на любой клиент, который запрашивает: \"Хочу увидеть всю информацию, начиная с этого файла и этой записи, безостановочно\". Таким образом, библиотека ``libslave``, прежде всего, используется для создания реплик базы данных Tarantool'а (намного быстрее, чем используя традиционный ведомый сервер MySQL) и для отслеживания изменений данных, чтобы они были пригодны для поиска."

#: ../doc/1.7/tutorials/libslave.rst:18
msgid "We will not go into the many details here -- the `API documentation <https://github.com/vozbu/libslave/wiki/API>`_ has them. We will only show an exercise: a minimal program that uses the library."
msgstr "Здесь мы не будем подробно рассматривать библиотеку — информация есть в `документации по API <https://github.com/vozbu/libslave/wiki/API>`_. Мы лишь дадим упражнение: минимальная программа с использованием библиотеки."

#: ../doc/1.7/tutorials/libslave.rst:24
msgid "Use a test machine. Do not use a production machine."
msgstr "Используйте тестовый сервер. Не используйте боевой сервер."

#: ../doc/1.7/tutorials/libslave.rst:26
msgid "STEP 1: Make sure you have:"
msgstr "ШАГ 1: Убедитесь в наличии следующего:"

#: ../doc/1.7/tutorials/libslave.rst:28
msgid "a recent version of Linux (versions such as Ubuntu 14.04 will not do),"
msgstr "последняя версия Linux (например, Ubuntu версии 14.04 не подойдет),"

#: ../doc/1.7/tutorials/libslave.rst:29
msgid "a recent version of MySQL 5.6 or MySQL 5.7 server (MariaDB will not do),"
msgstr "сервер MySQL версии 5.6 или 5.7 (MariaDB не подойдет),"

#: ../doc/1.7/tutorials/libslave.rst:30
msgid "MySQL client development package. For example, on Ubuntu you can download it with this command:"
msgstr "пакет программ для разработки клиента MySQL. Например, на Ubuntu можно загрузить его с помощью следующей команды:"

#: ../doc/1.7/tutorials/libslave.rst:33
msgid "$ sudo apt-get install mysql-client-core-5.7"
msgstr "$ sudo apt-get install mysql-client-core-5.7"

#: ../doc/1.7/tutorials/libslave.rst:37
msgid "STEP 2: Download ``libslave``."
msgstr "ШАГ 2: Установите ``libslave``."

#: ../doc/1.7/tutorials/libslave.rst:39
msgid "The recommended source is https://github.com/tarantool/libslave/. Downloads include the source code only."
msgstr "Рекомендуется источник по ссылке https://github.com/tarantool/libslave/. Загрузки включают в себя только исходный код."

#: ../doc/1.7/tutorials/libslave.rst:42
msgid ""
"$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"
msgstr ""
"$ sudo apt-get install libboost-all-dev\n"
"      $ cd ~\n"
"      $ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"      $ cd tarantool-libslave\n"
"      $ git submodule init\n"
"      $ git submodule update\n"
"      $ cmake .\n"
"      $ make"

#: ../doc/1.7/tutorials/libslave.rst:53
msgid "If you see an error message mentioning the word \"vector\", edit ``field.h`` and add this line:"
msgstr "Если система выдаст сообщение с ошибкой со словом \"vector\", отредактируйте ``field.h``, добавив следующую строку:"

#: ../doc/1.7/tutorials/libslave.rst:56
msgid "#include <vector>"
msgstr "#include <vector>"

#: ../doc/1.7/tutorials/libslave.rst:60
msgid "STEP 3: Start the MySQL server. On the command line, add appropriate switches for doing replication. For example:"
msgstr "ШАГ 3: Запустите сервер MySQL. В командной строке добавьте соответствующие коммутаторы для выполнения репликации. Например:"

#: ../doc/1.7/tutorials/libslave.rst:63
msgid "$ mysqld --log-bin=mysql-bin --server-id=1"
msgstr "$ mysqld --log-bin=mysql-bin --server-id=1"

#: ../doc/1.7/tutorials/libslave.rst:67
msgid "STEP 4: For purposes of this exercise, we are assuming you have:"
msgstr "ШАГ 4: Для целей данного упражнения, предполагаем, что у вас есть:"

#: ../doc/1.7/tutorials/libslave.rst:69
msgid "a \"root\" user with password \"root\" with privileges,"
msgstr "пользователь \"root\" с паролем \"root\" с привилегиями,"

#: ../doc/1.7/tutorials/libslave.rst:70
msgid "a \"test\" database with a table named \"test\","
msgstr "тестовая база данных \"test\" с тестовой таблицей под названием \"test\","

#: ../doc/1.7/tutorials/libslave.rst:71
msgid "a binary log named \"mysql-bin\","
msgstr "бинарный журнал под названием \"mysql-bin\","

#: ../doc/1.7/tutorials/libslave.rst:72
msgid "a server with server id = 1."
msgstr "сервер с идентификатором 1."

#: ../doc/1.7/tutorials/libslave.rst:74
msgid "The values are hard-coded in the program, though of course you can change the program -- it's easy to see their settings."
msgstr "Значения заданы в программе, хотя программу, конечно, можно изменить — посмотреть настройки несложно."

#: ../doc/1.7/tutorials/libslave.rst:77
msgid "STEP 5: Look at the program:"
msgstr "ШАГ 5: Обратите внимание на программу:"

#: ../doc/1.7/tutorials/libslave.rst:79
msgid ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"#include <unistd.h>\n"
"    #include <iostream>\n"
"    #include <sstream>\n"
"    #include \"Slave.h\"\n"
"    #include \"DefaultExtState.h\"\n"
"    \n"
"    slave::Slave* sl = NULL;\n"
"    \n"
"    void callback(const slave::RecordSet& event) {\n"
"        slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"        switch (event.type_event) {\n"
"        case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; break;\n"
"        case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; break;\n"
"        case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; break;\n"
"        default: break;\n"
"        }\n"
"    }\n"
"    \n"
"    bool isStopping()\n"
"    {\n"
"        return 0;\n"
"    }\n"
"    \n"
"    int main(int argc, char** argv)\n"
"    {\n"
"        slave::MasterInfo masterinfo;\n"
"        masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"        masterinfo.conn_options.mysql_port = 3306;\n"
"        masterinfo.conn_options.mysql_user = \"root\";\n"
"        masterinfo.conn_options.mysql_pass = \"root\";\n"
"        bool error = false;\n"
"        try {\n"
"            slave::DefaultExtState sDefExtState;\n"
"            slave::Slave slave(masterinfo, sDefExtState);\n"
"            sl = &slave;\n"
"            sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"            slave.setCallback(\"test\", \"test\", callback);\n"
"            slave.init();\n"
"            slave.createDatabaseStructure();\n"
"            try {\n"
"                slave.get_remote_binlog(isStopping);\n"
"            } catch (std::exception& ex) {\n"
"                std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"                error = true;\n"
"            }\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"        return 0;\n"
"    }"

#: ../doc/1.7/tutorials/libslave.rst:133
msgid "Everything unnecessary has been stripped so that you can see quickly how it works. At the start of ``main()``, there are some settings used for connecting -- host, port, user, password. Then there is an initialization call with the binary log file name = \"mysql-bin\". Pay particular attention to the ``setCallback`` statement, which passes database name = \"test\", table name = \"test\", and callback function address = callback. The program will be looping and invoking this callback function. See how, earlier in the program, the callback function prints \"UPDATE\" or \"DELETE\" or \"INSERT\" depending on what is passed to it."
msgstr "Всё лишнее почистили, чтобы можно было ясно увидеть, как это работает. В начале функции ``main()`` есть некоторые настройки, используемые для установки соединения — хост, порт, пользователь, пароль. Затем есть вызов инициализации с именем файла бинарного журнала = \"mysql-bin\". Обратите особое внимание на оператор ``setCallback``, который передает имя базы данных = \"test\", имя таблицы = \"test\" и адрес функции обратного вызова = callback. Программа войдет в цикл и будет вызывать эту функцию обратного вызова. Посмотрите, как на ранних этапах программы функция обратного вызова выводит \"UPDATE\", \"DELETE\" или \"INSERT\" в зависимости от переданных данных."

#: ../doc/1.7/tutorials/libslave.rst:144
msgid "STEP 5: Put the program in the ``tarantool-libslave`` directory and name it ``example.cpp``."
msgstr "ШАГ 5: Поместите программу в директорию ``tarantool-libslave`` и назовите ее ``example.cpp``."

#: ../doc/1.7/tutorials/libslave.rst:147
msgid "Step 6: Compile and build:"
msgstr "ШАГ 6: Выполните компиляцию и сборку:"

#: ../doc/1.7/tutorials/libslave.rst:149
msgid "$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a -ldl -lpthread"
msgstr "$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a -ldl -lpthread"

#: ../doc/1.7/tutorials/libslave.rst:155
msgid "Replace ``tarantool-libslave/include`` with the full directory name."
msgstr "Замените ``tarantool-libslave/include`` на полное имя директории."

#: ../doc/1.7/tutorials/libslave.rst:157
msgid "Notice that the name of the static library is ``libslave_a.a``, not ``libslave.a``."
msgstr "Обратите внимание, что имя статической библиотеки — ``libslave_a.a``, а не ``libslave.a``."

#: ../doc/1.7/tutorials/libslave.rst:160
msgid "Step 7: Run:"
msgstr "ШАГ 7: Выполните:"

#: ../doc/1.7/tutorials/libslave.rst:162
msgid "$ ./example"
msgstr "$ ./example"

#: ../doc/1.7/tutorials/libslave.rst:166
msgid "The result will be nothing -- the program is looping, waiting for the MySQL server to write to the replication binary log."
msgstr "Результат нет — программа в цикле ожидает, пока сервер MySQL запишет данные в бинарный журнал репликации."

#: ../doc/1.7/tutorials/libslave.rst:169
msgid "Step 8: Start a MySQL client program -- any client program will do. Enter these statements:"
msgstr "ШАГ 8: Запустите клиентскую программу MySQL — подойдет любая клиентская программа. Введите следующие операторы:"

#: ../doc/1.7/tutorials/libslave.rst:172
msgid ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"
msgstr ""
"USE test\n"
"    INSERT INTO test VALUES ('A');\n"
"    INSERT INTO test VALUES ('B');\n"
"    DELETE FROM test;"

#: ../doc/1.7/tutorials/libslave.rst:179
msgid "Watch what happens in ``example.cpp`` output -- it displays:"
msgstr "Проверьте, что происходит в выводе программы ``example.cpp`` — отображается следующее:"

#: ../doc/1.7/tutorials/libslave.rst:181
msgid ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"
msgstr ""
"INSERT\n"
"    INSERT\n"
"    DELETE\n"
"    DELETE"

#: ../doc/1.7/tutorials/libslave.rst:188
msgid "This is row-based replication, so you see two DELETEs, because there are two rows."
msgstr "Репликация является построчной, поэтому видим DELETE два раза — потому что есть две строки."

#: ../doc/1.7/tutorials/libslave.rst:191
msgid "What the exercise has shown is:"
msgstr "В результате выполнения упражнения видим:"

#: ../doc/1.7/tutorials/libslave.rst:193
msgid "the library can be built, and"
msgstr "можно собрать библиотеку, а "

#: ../doc/1.7/tutorials/libslave.rst:194
msgid "programs that use the library can access everything that the MySQL server dumps."
msgstr "программы, которые используют библиотеку, могут получить доступ ко всему, что сохраняет сервер MySQL."

#: ../doc/1.7/tutorials/libslave.rst:197
msgid "For the many details and examples of usage in the field, see:"
msgstr "Более подробную информацию и примеры использования см. ниже:"

#: ../doc/1.7/tutorials/libslave.rst
msgid "Our downloadable ``libslave`` version:"
msgstr "Загрузить нашу версию ``libslave`` можно по ссылке:"

#: ../doc/1.7/tutorials/libslave.rst
msgid "https://github.com/tarantool/libslave"
msgstr "https://github.com/tarantool/libslave"

#: ../doc/1.7/tutorials/libslave.rst
msgid "The version it was forked from (with a different README):"
msgstr "Ответвление сделано из версии по ссылке (с другим файлом README):"

#: ../doc/1.7/tutorials/libslave.rst
msgid "https://github.com/vozbu/libslave/wiki/API"
msgstr "https://github.com/vozbu/libslave/wiki/API"

#: ../doc/1.7/tutorials/libslave.rst:205
msgid "`How to speed up your MySQL with replication to in-memory database <http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-with-replication-to-in-memory-dat.html>`_ article"
msgstr "Статья `How to speed up your MySQL with replication to in-memory database <http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-with-replication-to-in-memory-dat.html>`_ (на английском)"

#: ../doc/1.7/tutorials/libslave.rst:207
msgid "`Replicating data from MySQL to Tarantool <https://habrahabr.ru/company/mailru/blog/323870/>`_ article (in Russian)"
msgstr "Статья `Репликация из MySQL в Tarantool <https://habrahabr.ru/company/mailru/blog/323870/>`_"

#: ../doc/1.7/tutorials/libslave.rst:209
msgid "`Asynchronous replication uncensored <https://habrahabr.ru/company/oleg-bunin/blog/313594/>`_ article (in Russian)"
msgstr "Статья `Асинхронная репликация без цензуры <https://habrahabr.ru/company/oleg-bunin/blog/313594/>`_"

#: ../doc/1.7/tutorials/lua_tutorials.rst:5
msgid "Lua tutorials"
msgstr "Практические задания на Lua"

#: ../doc/1.7/tutorials/lua_tutorials.rst:7
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr "Практические задания по использованию хранимых процедур на языке Lua в работе с Tarantool'ом:"

#: ../doc/1.7/tutorials/lua_tutorials.rst:9
msgid ":ref:`Insert one million tuples with a Lua stored procedure <c_lua_tutorial-insert_one_million_tuples>`,"
msgstr ":ref:`Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua <c_lua_tutorial-insert_one_million_tuples>`,"

#: ../doc/1.7/tutorials/lua_tutorials.rst:10
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ":ref:`Подсчет суммы по JSON-полям во всех кортежах <c_lua_tutorial-sum_a_json_field>`,"

#: ../doc/1.7/tutorials/lua_tutorials.rst:11
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ":ref:`Индексированный поиск по шаблонам <c_lua_tutorial-indexed_pattern_search>`."

#: ../doc/1.7/tutorials/lua_tutorials.rst:17
msgid "Insert one million tuples with a Lua stored procedure"
msgstr "Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua"

#: ../doc/1.7/tutorials/lua_tutorials.rst:19
msgid "This is an exercise assignment: “Insert one million tuples. Each tuple should have a constantly-increasing numeric primary-key field and a random alphabetic 10-character string field.”"
msgstr "Задание по данному практикуму: “Вставьте 1 миллион кортежей. В каждом кортеже должно быть поле, которое соответствует ключу в первичном индексе, в виде постоянно возрастающего числа, а также поле в виде буквенной строки со случайным значением из 10 символов.”"

#: ../doc/1.7/tutorials/lua_tutorials.rst:23
msgid "The purpose of the exercise is to show what Lua functions look like inside Tarantool. It will be necessary to employ the Lua math library, the Lua string library, the Tarantool box library, the Tarantool box.tuple library, loops, and concatenations. It should be easy to follow even for a person who has not used either Lua or Tarantool before. The only requirement is a knowledge of how other programming languages work and a memory of the first two chapters of this manual. But for better understanding, follow the comments and the links, which point to the Lua manual or to elsewhere in this Tarantool manual. To further enhance learning, type the statements in with the tarantool client while reading along."
msgstr "Цель данного упражнения состоит в том, чтобы показать, как выглядят Lua-функции в Tarantool'е. Необходимо будет работать с математической библиотекой Lua, библиотекой для работы со строками интерпретатора Lua, Tarantool-библиотекой ``box``, Tarantool-библиотекой ``box.tuple``, циклами и конкатенацией. Инструкции легко будет выполнять даже тем, кто никогда не использовал раньше Lua или Tarantool. Единственное требование — знание того, как работают другие языки программирования, и изучение первых двух глав данного руководства. Но для лучшего понимания можно следовать по комментариям и ссылкам на руководство по Lua или другим пунктам в данном руководстве по Tarantool'у. А чтобы облегчить изучение, читайте инструкции параллельно с вводом операторов в Tarantool-клиент."

#: ../doc/1.7/tutorials/lua_tutorials.rst:35
msgid "Configure"
msgstr "Настройка"

#: ../doc/1.7/tutorials/lua_tutorials.rst:37
msgid "We are going to use the Tarantool sandbox that was created for our :ref:`\"Getting started\" exercises <getting_started>`. So there is a single space, and a numeric primary key, and a running Tarantool server instance which also serves as a client."
msgstr "Будем использовать Tarantool-песочницу, которую создавали для :ref:`упражнений раздела \"Руководство для начинающих\" <getting_started>`. Таким образом, у нас есть один спейс и числовой ключ первичного индекса, а также экземпляр Tarantool'а, который также выступает в виде клиента."

#: ../doc/1.7/tutorials/lua_tutorials.rst:44
msgid "Delimiter"
msgstr "Разделитель"

#: ../doc/1.7/tutorials/lua_tutorials.rst:46
msgid "In earlier versions of Tarantool, multi-line functions had to be enclosed within \"delimiters\". They are no longer necessary, and so they will not be used in this tutorial. However, they are still supported. Users who wish to use delimiters, or users of older versions of Tarantool, should check the syntax description for :ref:`declaring a delimiter <console-delimiter>` before proceeding."
msgstr "В более ранних версиях Tarantool'а многострочные функции обрамляются символами-разделителями. Сейчас в них нет необходимости, поэтому в данном практическом задании они использоваться не будут. Однако они все еще поддерживаются. Если вы хотите использовать разделители или используете более раннюю версию Tarantool'а, перед работой проверьте описание синтаксиса для :ref:`объявления разделителя <console-delimiter>`."

#: ../doc/1.7/tutorials/lua_tutorials.rst:55
msgid "Create a function that returns a string"
msgstr "Создание функции, которая возвращает строку"

#: ../doc/1.7/tutorials/lua_tutorials.rst:57
msgid "We will start by making a function that returns a fixed string, “Hello world”."
msgstr "Начнем с создания функции, которая возвращает заданную строку — “Hello world”."

#: ../doc/1.7/tutorials/lua_tutorials.rst:59
msgid ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""
"function string_function()\n"
"       return \"hello world\"\n"
"     end"

#: ../doc/1.7/tutorials/lua_tutorials.rst:65
msgid "The word \"``function``\" is a Lua keyword -- we're about to go into Lua. The function name is string_function. The function has one executable statement, ``return \"hello world\"``. The string \"hello world\" is enclosed in double quotes here, although Lua doesn't care -- one could use single quotes instead. The word \"``end``\" means “this is the end of the Lua function declaration.” To confirm that the function works, we can say"
msgstr "Слово \"``function``\" (функция) — ключевое слово в языке Lua. Рассмотрим подробно работу с языком Lua. Имя функции — string_function (строковая_функция). В функции есть один исполняемый оператор, ``return \"hello world\"`` (вернуть \"hello world\"). Строка \"hello world\" здесь заключена в двойные кавычки, хотя в Lua это не имеет значения, можно использовать одинарные кавычки. Слово \"``end``\" означает, что “это конец объявления Lua-функции.” Чтобы проверить работу функции, можем выполнить команду"

#: ../doc/1.7/tutorials/lua_tutorials.rst:72
msgid "string_function()"
msgstr "string_function()"

#: ../doc/1.7/tutorials/lua_tutorials.rst:76
msgid "Sending ``function-name()`` means “invoke the Lua function.” The effect is that the string which the function returns will end up on the screen."
msgstr "Отправка ``function-name()`` (имя-функции) означает команду вызова Lua-функции. В результате возвращаемая функцией строка появится на экране."

#: ../doc/1.7/tutorials/lua_tutorials.rst:79
msgid "For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr "Для получения подробной информации о строках в языке Lua, см.  `Главу 2.4 \"Строки\"`_ в руководстве по языку Lua. Для получения подробной информации о функциях см. Главу 5 \"Функции\" в руководстве по языку Lua (`chapter 5 \"Functions\"`_)."

#: ../doc/1.7/tutorials/lua_tutorials.rst:85
#: ../doc/1.7/tutorials/lua_tutorials.rst:129
#: ../doc/1.7/tutorials/lua_tutorials.rst:181
#: ../doc/1.7/tutorials/lua_tutorials.rst:237
#: ../doc/1.7/tutorials/lua_tutorials.rst:283
#: ../doc/1.7/tutorials/lua_tutorials.rst:343
#: ../doc/1.7/tutorials/lua_tutorials.rst:436
msgid "The screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.7/tutorials/lua_tutorials.rst:87
msgid ""
"tarantool> function string_funciton()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_funciton()\n"
"              >   return \"hello world\"\n"
"              > end\n"
"     ---\n"
"     ...\n"
"     tarantool> string_function()\n"
"     ---\n"
"     - hello world\n"
"     ...\n"
"     tarantool>"

#: ../doc/1.7/tutorials/lua_tutorials.rst:102
msgid "Create a function that calls another function and sets a variable"
msgstr "Создание функции, которая вызывает другую функцию и определяет переменную"

#: ../doc/1.7/tutorials/lua_tutorials.rst:104
msgid "Now that ``string_function`` exists, we can invoke it from another function."
msgstr "Теперь у нас есть функция ``string_function``, и можно вызвать ее с помощью другой функции."

#: ../doc/1.7/tutorials/lua_tutorials.rst:107
msgid ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""
"function main_function()\n"
"       local string_value\n"
"       string_value = string_function()\n"
"       return string_value\n"
"     end"

#: ../doc/1.7/tutorials/lua_tutorials.rst:115
msgid "We begin by declaring a variable \"``string_value``\". The word \"``local``\" means that string_value appears only in ``main_function``. If we didn't use \"``local``\" then ``string_value`` would be visible everywhere - even by other users using other clients connected to this server instance! Sometimes that's a very desirable feature for inter-client communication, but not this time."
msgstr "Сначала объявим переменную \"``string_value``\" (значение_строки). Слово \"``local``\" (локально) означает, что string_value появится только в ``main_function`` (основная_функция). Если бы мы не использовали \"``local``\", то ``string_value`` увидели бы даже пользователи других клиентов, которые подключились к данному экземпляру! Иногда это может быть очень полезно при взаимодействии клиентов, но не в нашем случае."

#: ../doc/1.7/tutorials/lua_tutorials.rst:121
msgid "Then we assign a value to ``string_value``, namely, the result of ``string_function()``. Soon we will invoke ``main_function()`` to check that it got the value."
msgstr "Затем определим значение для ``string_value``, а именно, результат функции ``string_function()``. Сейчас вызовем ``main_function()``, чтобы проверить, что значение определено."

#: ../doc/1.7/tutorials/lua_tutorials.rst:125
msgid "For more about Lua variables see Lua manual `chapter 4.2 \"Local Variables and Blocks\"`_ ."
msgstr "Для получения подробной информации о переменных в языке Lua, см. Главу 4.2 \"Локальные переменные и блоки\" в руководстве по языку Lua (`chapter 4.2 \"Local Variables and Blocks\"`_)."

#: ../doc/1.7/tutorials/lua_tutorials.rst:131
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"              >   local string_value\n"
"              >   string_value = string_function()\n"
"              >   return string_value\n"
"              > end\n"
"     ---\n"
"     ...\n"
"     tarantool> main_function()\n"
"     ---\n"
"     - hello world\n"
"     ...\n"
"     tarantool>"

#: ../doc/1.7/tutorials/lua_tutorials.rst:148
msgid "Modify the function so it returns a one-letter random string"
msgstr "Изменение функции для возврата строки из одной случайной буквы"

#: ../doc/1.7/tutorials/lua_tutorials.rst:150
msgid "Now that it's a bit clearer how to make a variable, we can change ``string_function()`` so that, instead of returning a fixed literal \"Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr "Сейчас стало понятно, как задавать переменную, поэтому можно изменить функцию ``string_function()`` так, чтобы вместо возврата заданной фразы \"Hello world\", она возвращала случайным образом выбранную букву от 'A' до 'Z'."

#: ../doc/1.7/tutorials/lua_tutorials.rst:154
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""
"function string_function()\n"
"       local random_number\n"
"       local random_string\n"
"       random_number = math.random(65, 90)\n"
"       random_string = string.char(random_number)\n"
"       return random_string\n"
"     end"

#: ../doc/1.7/tutorials/lua_tutorials.rst:164
msgid "It is not necessary to destroy the old ``string_function()`` contents, they're simply overwritten. The first assignment invokes a random-number function in Lua's math library; the parameters mean “the number must be an integer between 65 and 90.” The second assignment invokes an integer-to-character function in Lua's string library; the parameter is the code point of the character. Luckily the ASCII value of 'A' is 65 and the ASCII value of 'Z' is 90 so the result will always be a letter between A and Z."
msgstr "Нет необходимости стирать содержание старой функции ``string_function()``, оно просто перезаписывается. Первый оператор вызывает функцию из математической библиотеки Lua, которая возвращает случайное число; параметры означают, что число должно быть целым от 65 до 90. Второй оператор вызывает функцию из библиотеки Lua для работы со строками, которая преобразует число в символ; параметр представляет собой кодовую точку символа. К счастью, в кодировке ASCII символу 'A' соответствует значение 65, а 'Z' — 90, так что в результате всегда получим букву от A до Z."

#: ../doc/1.7/tutorials/lua_tutorials.rst:172
msgid "For more about Lua math-library functions see Lua users \"`Math Library Tutorial`_\". For more about Lua string-library functions see Lua users \"`String Library Tutorial`_\" ."
msgstr "Для получения подробной информации о функциях математической библиотеки в языке Lua, см. Практическое задание по математической библиотеке для пользователей Lua (`Math Library Tutorial`_). Для получения подробной информации о функциях библиотеки для работы со строками в языке Lua, см.  Практическое задание по библиотеке для работы со строками для пользователей Lua (`String Library Tutorial`_)."

#: ../doc/1.7/tutorials/lua_tutorials.rst:178
msgid "Once again the ``string_function()`` can be invoked from main_function() which can be invoked with ``main_function()``."
msgstr "И снова функцию ``string_function()`` можно вызвать из main_function(), которую можно вызвать с помощью ``main_function()``."

#: ../doc/1.7/tutorials/lua_tutorials.rst:183
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"              >   local random_number\n"
"              >   local random_string\n"
"              >   random_number = math.random(65, 90)\n"
"              >   random_string = string.char(random_number)\n"
"              >   return random_string\n"
"              > end\n"
"     ---\n"
"     ...\n"
"     tarantool> main_function()\n"
"     ---\n"
"     - C\n"
"     ...\n"
"     tarantool>"

#: ../doc/1.7/tutorials/lua_tutorials.rst:200
msgid "... Well, actually it won't always look like this because ``math.random()`` produces random numbers. But for the illustration purposes it won't matter what the random string values are."
msgstr "... На самом деле, вывод не всегда будет именно таким, поскольку функция ``math.random()`` вызывает случайные числа. Но для наглядности случайные значения в строке не важны."

#: ../doc/1.7/tutorials/lua_tutorials.rst:206
msgid "Modify the function so it returns a ten-letter random string"
msgstr "Изменение функции для возврата строки из десяти случайных букв"

#: ../doc/1.7/tutorials/lua_tutorials.rst:208
msgid "Now that it's clear how to produce one-letter random strings, we can reach our goal of producing a ten-letter string by concatenating ten one-letter strings, in a loop."
msgstr "Сейчас стало понятно, как вызывать строки из одной случайной буквы, поэтому можно перейти к нашей цели — возврату строки из десяти букв с помощью конкатенации десяти строк из одной случайной буквы в цикле."

#: ../doc/1.7/tutorials/lua_tutorials.rst:212
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""
"function string_function()\n"
"       local random_number\n"
"       local random_string\n"
"       random_string = \"\"\n"
"       for x = 1,10,1 do\n"
"         random_number = math.random(65, 90)\n"
"         random_string = random_string .. string.char(random_number)\n"
"       end\n"
"       return random_string\n"
"     end"

#: ../doc/1.7/tutorials/lua_tutorials.rst:225
msgid "The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x equals 10, increment x by 1 for each iteration.” The symbol \"..\" means \"concatenate\", that is, add the string on the right of the \"..\" sign to the string on the left of the \"..\" sign. Since we start by saying that random_string is \"\" (a blank string), the end result is that random_string has 10 random letters. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with ``main_function()``."
msgstr "Слова \"for x = 1,10,1\" означают: “начать с x, равного 1, зацикливать до тех пор, пока x не будет равен 10, увеличивать x на 1 на каждом шаге цикла”. Символ \"..\" означает \"конкатенацию\", то есть добавление строки справа от знака \"..\" к строке слева от знака \"..\". Поскольку в начале определяется, что random_string (случайная_строка) представляет собой \"\" (пустую строку), в результате получим, что в random_string 10 случайных букв. И снова функцию ``string_function()`` можно вызвать из ``main_function()``, которую можно вызвать с помощью ``main_function()``."

#: ../doc/1.7/tutorials/lua_tutorials.rst:233
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr "Для получения подробной информации о циклах в языке Lua, см. Главу 4.3.4 \"Числовой оператор for\" в руководстве по языку Lua (`chapter 4.3.4 \"Numeric for\"`_)."

#: ../doc/1.7/tutorials/lua_tutorials.rst:239
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"              >   local random_number\n"
"              >   local random_string\n"
"              >   random_string = \"\"\n"
"              >   for x = 1,10,1 do\n"
"              >     random_number = math.random(65, 90)\n"
"              >     random_string = random_string .. string.char(random_number)\n"
"              >   end\n"
"              >   return random_string\n"
"              > end\n"
"     ---\n"
"     ...\n"
"     tarantool> main_function()\n"
"     ---\n"
"     - 'ZUDJBHKEFM'\n"
"     ...\n"
"     tarantool>"

#: ../doc/1.7/tutorials/lua_tutorials.rst:261
msgid "Make a tuple out of a number and a string"
msgstr "Составление кортежа из числа и строки"

#: ../doc/1.7/tutorials/lua_tutorials.rst:263
msgid "Now that it's clear how to make a 10-letter random string, it's possible to make a tuple that contains a number and a 10-letter random string, by invoking a function in Tarantool's library of Lua functions."
msgstr "Сейчас стало понятно, как создать строку из 10 случайных букв, поэтому можно создать кортеж, который будет содержать число и строку из 10 случайных букв, с помощью функции в Tarantool-библиотеке Lua-функций."

#: ../doc/1.7/tutorials/lua_tutorials.rst:267
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""
"function main_function()\n"
"       local string_value, t\n"
"       string_value = string_function()\n"
"       t = box.tuple.new({1, string_value})\n"
"       return t\n"
"     end"

#: ../doc/1.7/tutorials/lua_tutorials.rst:276
msgid "Once this is done, t will be the value of a new tuple which has two fields. The first field is numeric: 1. The second field is a random string. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with  ``main_function()``."
msgstr "После этого, \"t\" будет представлять собой значение нового кортежа с двумя полями. Первое поле является числовым: \"1\". Второе поле представляет собой случайную строку. И снова функцию ``string_function()`` можно вызвать из ``main_function()``, которую можно вызвать с помощью ``main_function()``."

#: ../doc/1.7/tutorials/lua_tutorials.rst:281
msgid "For more about Tarantool tuples see Tarantool manual section :ref:`Submodule box.tuple <box_tuple>`."
msgstr "Для получения подробной информации о кортежах в Tarantool'е, см. раздел :ref:`Вложенный модуль box.tuple <box_tuple>` руководства по Tarantool'у."

#: ../doc/1.7/tutorials/lua_tutorials.rst:285
msgid ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"              > local string_value, t\n"
"              > string_value = string_function()\n"
"              > t = box.tuple.new({1, string_value})\n"
"              > return t\n"
"              > end\n"
"     ---\n"
"     ...\n"
"     tarantool> main_function()\n"
"     ---\n"
"     - [1, 'PNPZPCOOKA']\n"
"     ...\n"
"     tarantool>"

#: ../doc/1.7/tutorials/lua_tutorials.rst:303
msgid "Modify main_function to insert a tuple into the database"
msgstr "Изменение основной функции main_function для вставки кортежа в базу данных"

#: ../doc/1.7/tutorials/lua_tutorials.rst:305
msgid "Now that it's clear how to make a tuple that contains a number and a 10-letter random string, the only trick remaining is putting that tuple into tester. Remember that tester is the first space that was defined in the sandbox, so it's like a database table."
msgstr "Сейчас стало понятно, как создавать кортеж, который содержит число и строку из десяти случайных букв, поэтому осталось только поместить этот кортеж в спейс tester. Следует отметить, что tester — это первый спейс, определенный в песочнице, поэтому он представляет собой таблицу в базе данных."

#: ../doc/1.7/tutorials/lua_tutorials.rst:310
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""
"function main_function()\n"
"       local string_value, t\n"
"       string_value = string_function()\n"
"       t = box.tuple.new({1,string_value})\n"
"       box.space.tester:replace(t)\n"
"     end"

#: ../doc/1.7/tutorials/lua_tutorials.rst:319
msgid "The new line here is ``box.space.tester:replace(t)``. The name contains 'tester' because the insertion is going to be to tester. The second parameter is the tuple value. To be perfectly correct we could have said ``box.space.tester:insert(t)`` here, rather than ``box.space.tester:replace(t)``, but \"replace\" means “insert even if there is already a tuple whose primary-key value is a duplicate”, and that makes it easier to re-run the exercise even if the sandbox database isn't empty. Once this is done, tester will contain a tuple with two fields. The first field will be 1. The second field will be a random 10-letter string. Once again the ``string_function(``) can be invoked from ``main_function()`` which can be invoked with ``main_function()``. But ``main_function()`` won't tell the whole story, because it does not return t, it only puts t into the database. To confirm that something got inserted, we'll use a SELECT request."
msgstr "Здесь новая строка — ``box.space.tester:replace(t)``. Имя содержит слово 'tester', потому что вставка будет осуществляться в спейс tester. Второй параметр представляет собой значение в кортеже. Для абсолютной точности мы могли ввести команду ``box.space.tester:insert(t)``, а не ``box.space.tester:replace(t)``, но слово \"replace\" (заменить) означает “вставить, даже если уже существует кортеж, у которого значение первичного ключа совпадает”, и это облегчит повтор упражнения, даже если песочница не пуста. После того, как это будет выполнено, спейс tester будет содержать кортеж с двумя полями. Первое поле будет 1. Второе поле будет представлять собой строку из десяти случайных букв. И снова функцию ``string_function()`` можно вызвать из ``main_function()``, которую можно вызвать с помощью ``main_function()``. Но функция ``main_function()`` не может полностью отразить ситуацию, поскольку она не возвращает t, она только размещает t в базе данных. Чтобы убедиться, что произошла вставка, используем SELECT-запрос."

#: ../doc/1.7/tutorials/lua_tutorials.rst:333
msgid ""
"main_function()\n"
"box.space.tester:select{1}"
msgstr ""
"main_function()\n"
"     box.space.tester:select{1}"

#: ../doc/1.7/tutorials/lua_tutorials.rst:338
msgid "For more about Tarantool insert and replace calls, see Tarantool manual section :ref:`Submodule box.space <box_space>`, :ref:`space_object:insert() <box_space-insert>`, and :ref:`space_object:replace() <box_space-replace>`."
msgstr "Для получения подробной информации о вызовах insert и replace в Tarantool'е, см. разделы :ref:`Вложенный модуль box.space <box_space>`, :ref:`space_object:insert() <box_space-insert>` и :ref:`space_object:replace() <box_space-replace>` руководства по Tarantool'у."

#: ../doc/1.7/tutorials/lua_tutorials.rst:345
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function main_function()\n"
"              >   local string_value, t\n"
"              >   string_value = string_function()\n"
"              >   t = box.tuple.new({1,string_value})\n"
"              >   box.space.tester:replace(t)\n"
"              > end\n"
"     ---\n"
"     ...\n"
"     tarantool> main_function()\n"
"     ---\n"
"     ...\n"
"     tarantool> box.space.tester:select{1}\n"
"     ---\n"
"     - - [1, 'EUJYVEECIL']\n"
"     ...\n"
"     tarantool>"

#: ../doc/1.7/tutorials/lua_tutorials.rst:366
msgid "Modify main_function to insert a million tuples into the database"
msgstr "Изменение основной функции main_function для вставки миллиона кортежей в базу данных"

#: ../doc/1.7/tutorials/lua_tutorials.rst:368
msgid "Now that it's clear how to insert one tuple into the database, it's no big deal to figure out how to scale up: instead of inserting with a literal value = 1 for the primary key, insert with a variable value = between 1 and 1 million, in a loop. Since we already saw how to loop, that's a simple thing. The only extra wrinkle that we add here is a timing function."
msgstr "Сейчас стало понятно, как вставить кортеж в базу данных, поэтому несложно догадаться, как можно увеличить масштаб: вместо того, чтобы вставлять значение 1 для первичного ключа, вставьте значение переменной от 1 до миллиона в цикле. Поскольку уже рассматривалось, как заводить цикл, это будет несложно. Мы лишь добавим небольшой штрих — функцию распределения во времени."

#: ../doc/1.7/tutorials/lua_tutorials.rst:374
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""
"function main_function()\n"
"       local string_value, t\n"
"       for i = 1,1000000,1 do\n"
"         string_value = string_function()\n"
"         t = box.tuple.new({i,string_value})\n"
"         box.space.tester:replace(t)\n"
"       end\n"
"     end\n"
"     start_time = os.clock()\n"
"     main_function()\n"
"     end_time = os.clock()\n"
"     'insert done in ' .. end_time - start_time .. ' seconds'"

#: ../doc/1.7/tutorials/lua_tutorials.rst:389
msgid "The standard Lua function `os.clock() <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ will return the number of CPU seconds since the start. Therefore, by getting start_time = number of seconds just before the inserting, and then getting end_time = number of seconds just after the inserting, we can calculate (end_time - start_time) = elapsed time in seconds. We will display that value by putting it in a request without any assignments, which causes Tarantool to send the value to the client, which prints it. (Lua's answer to the C ``printf()`` function, which is ``print()``, will also work.)"
msgstr "Стандартная Lua-функция `os.clock() <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ вернет время ЦП в секундах с момента начала. Таким образом, выводя start_time = number of seconds (время_начала = секунды) прямо перед вставкой, а затем выводя end_time = number of seconds (время_окончания = секунды) сразу после вставки, можно рассчитать (время_окончания - время_начала) = затраченное время в секундах. Отобразим это значение путем ввода в запрос без операторов, что приведет к тому, что Tarantool отправит значение на клиент, который выведет это значение. (Ответ Lua на C-функцию ``printf()``, а именно ``print()``, также сработает.)"

#: ../doc/1.7/tutorials/lua_tutorials.rst:399
msgid "For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and Time\"`_. For more on Lua print() see Lua manual `chapter 5 \"Functions\"`_."
msgstr "Для получения подробной информации о функции ``os.clock()`` см. Главу 22.1 \"Дата и время\" в руководстве по языку Lua (`chapter 22.1 \"Date and Time\"`_). Для получения подробной информации о функции print() см. Главу 5 \"Функции\" в руководстве по языку Lua (`chapter 5 \"Functions\"`_)."

#: ../doc/1.7/tutorials/lua_tutorials.rst:405
msgid "Since this is the grand finale, we will redo the final versions of all the necessary requests: the request that created ``string_function()``, the request that created ``main_function()``, and the request that invokes ``main_function()``."
msgstr "И поскольку наступает кульминация — повторно введем окончательные варианты всех необходимых запросов: запрос, который создает ``string_function()``, запрос, который создает ``main_function()``, и запрос, который вызывает ``main_function()``."

#: ../doc/1.7/tutorials/lua_tutorials.rst:410
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""
"function string_function()\n"
"       local random_number\n"
"       local random_string\n"
"       random_string = \"\"\n"
"       for x = 1,10,1 do\n"
"         random_number = math.random(65, 90)\n"
"         random_string = random_string .. string.char(random_number)\n"
"       end\n"
"       return random_string\n"
"     end\n"
"     \n"
"     function main_function()\n"
"       local string_value, t\n"
"       for i = 1,1000000,1 do\n"
"         string_value = string_function()\n"
"         t = box.tuple.new({i,string_value})\n"
"         box.space.tester:replace(t)\n"
"       end\n"
"     end\n"
"     start_time = os.clock()\n"
"     main_function()\n"
"     end_time = os.clock()\n"
"     'insert done in ' .. end_time - start_time .. ' seconds'"

#: ../doc/1.7/tutorials/lua_tutorials.rst:438
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> function string_function()\n"
"              >   local random_number\n"
"              >   local random_string\n"
"              >   random_string = \"\"\n"
"              >   for x = 1,10,1 do\n"
"              >     random_number = math.random(65, 90)\n"
"              >     random_string = random_string .. string.char(random_number)\n"
"              >   end\n"
"              >   return random_string\n"
"              > end\n"
"     ---\n"
"     ...\n"
"     tarantool> function main_function()\n"
"              >   local string_value, t\n"
"              >   for i = 1,1000000,1 do\n"
"              >     string_value = string_function()\n"
"              >     t = box.tuple.new({i,string_value})\n"
"              >     box.space.tester:replace(t)\n"
"              >   end\n"
"              > end\n"
"     ---\n"
"     ...\n"
"     tarantool> start_time = os.clock()\n"
"     ---\n"
"     ...\n"
"     tarantool> main_function()\n"
"     ---\n"
"     ...\n"
"     tarantool> end_time = os.clock()\n"
"     ---\n"
"     ...\n"
"     tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"     ---\n"
"     - insert done in 37.62 seconds\n"
"     ...\n"
"     tarantool>"

#: ../doc/1.7/tutorials/lua_tutorials.rst:477
msgid "What has been shown is that Lua functions are quite expressive (in fact one can do more with Tarantool's Lua stored procedures than one can do with stored procedures in some SQL DBMSs), and that it's straightforward to combine Lua-library functions and Tarantool-library functions."
msgstr "Итак, мы доказали, что возможности Lua-функций довольно многообразны (на самом деле, с помощью хранимых процедур на языке Lua в Tarantool'е можно сделать больше, чем с помощью хранимых процедур в некоторых SQL СУБД), и несложно комбинировать функции Lua-библиотек и функции Tarantool-библиотек."

#: ../doc/1.7/tutorials/lua_tutorials.rst:482
msgid "What has also been shown is that inserting a million tuples took 37 seconds. The host computer was a Linux laptop. By changing :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the test, one can reduce the elapsed time to 4 seconds."
msgstr "Также мы показали, что вставка миллиона кортежей заняла 37 секунд. Хостом выступил ноутбук с ОС Linux. А изменив значение  :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` на 'none' перед запуском теста, можно уменьшить затраченное время до 4 секунд."

#: ../doc/1.7/tutorials/lua_tutorials.rst:490
msgid "Sum a JSON field for all tuples"
msgstr "Подсчет суммы по JSON-полям во всех кортежах"

#: ../doc/1.7/tutorials/lua_tutorials.rst:492
msgid "This is an exercise assignment: “Assume that inside every tuple there is a string formatted as JSON. Inside that string there is a JSON numeric field. For each tuple, find the numeric field's value and add it to a 'sum' variable. At end, return the 'sum' variable.” The purpose of the exercise is to get experience in one way to read and process tuples."
msgstr "Задание по данному практикуму: “Предположим, что в каждом кортеже есть строка в формате JSON. В каждой строке есть числовое поле формата JSON. Для каждого кортежа необходимо найти значение числового поля и прибавить его к переменной 'sum' (сумма). В конце функция должна вернуть переменную 'sum'.” Цель данного упражнения — получить опыт в прочтении и обработке кортежей одновременно."

#: ../doc/1.7/tutorials/lua_tutorials.rst:498
msgid ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""
"json = require('json')\n"
"     function sum_json_field(field_name)\n"
"       local v, t, sum, field_value, is_valid_json, lua_table\n"
"       sum = 0\n"
"       for v, t in box.space.tester:pairs() do\n"
"         is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"         if is_valid_json then\n"
"           field_value = lua_table[field_name]\n"
"           if type(field_value) == \"number\" then sum = sum + field_value end\n"
"         end\n"
"       end\n"
"       return sum\n"
"     end"

#: ../doc/1.7/tutorials/lua_tutorials.rst:515
msgid "**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will be used in the function. Actually it's not necessary to declare all variables at the start, and in a long function it would be better to declare variables just before using them. In fact it's not even necessary to declare variables at all, but an undeclared variable is \"global\". That's not desirable for any of the variables that are declared in line 1, because all of them are for use only within the function."
msgstr "**СТРОКА 3: ЗАЧЕМ НУЖЕН \"LOCAL\".** Эта строка объявляет все переменные, которые будут использоваться в функции. На самом деле, нет необходимости в начале объявлять все переменные, а в длинной функции лучше объявить переменные прямо перед их использованием. Фактически объявлять переменные вообще необязательно, но необъявленная переменная будет \"глобальной\". Это представляется нежелательным для всех переменных, объявленных в строке 1, поскольку все они используются только в рамках функции."

#: ../doc/1.7/tutorials/lua_tutorials.rst:522
msgid "**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and there are two ways to do it: with :ref:`box.space.space_object:pairs() <box_space-pairs>` or with ``variable = select(...)`` followed by :samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred ``pairs()`` for this example."
msgstr "**СТРОКА 5: ЗАЧЕМ НУЖЕН \"PAIRS()\".** Наша задача — пройти по всем строкам, что можно сделать двумя способами: с помощью :ref:`box.space.space_object:pairs() <box_space-pairs>` или с помощью ``variable = select(...)`` с указанием :samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. Для данного примера мы предпочли использовать ``pairs()``."

#: ../doc/1.7/tutorials/lua_tutorials.rst:527
msgid "**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop will be repeated as long as there is another index key. A tuple is fetched and can be referenced with variable :code:`t`."
msgstr "**СТРОКА 5: НАЧАЛО ОСНОВНОГО ЦИКЛА.** Всё внутри цикла \"``for``\" будет повторяться до тех пор, пока не кончатся индекс-ключи. На полученный кортеж можно сослаться с помощью переменной :code:`t`."

#: ../doc/1.7/tutorials/lua_tutorials.rst:531
msgid "**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = json.decode(t[2]))``, then the function would abort with an error if it encountered something wrong with the JSON string - a missing colon, for example. By putting the function inside \"``pcall``\" (`protected call`_), we're saying: we want to intercept that sort of error, so if there's a problem just set ``is_valid_json = false`` and we will know what to do about it later."
msgstr "**СТРОКА 6: ЗАЧЕМ НУЖЕН \"PCALL\".** Если бы мы просто ввели ``lua_table = json.decode(t[2]))``, то функция завершила бы работу с ошибкой, обнаружив любое несоответствие в JSON-строке, например отсутствие запятой. Заключив функцию в \"``pcall``\" (`protected call`_ — защищенный вызов), мы заявляем следующее: хотим перехватывать ошибки такого рода, поэтому в случае ошибки следует просто указать ``is_valid_json = false``, и позднее мы решим, что с этим делать."

#: ../doc/1.7/tutorials/lua_tutorials.rst:538
msgid "**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` which means decode a JSON string, and the parameter is t[2] which is a reference to a JSON string. There's a bit of hard coding here, we're assuming that the second field in the tuple is where the JSON string was inserted. For example, we're assuming a tuple looks like"
msgstr "**СТРОКА 6: ЗНАЧЕНИЕ.** Функция :ref:`json.decode <json-decode>` означает декодирование JSON-строки, а параметр t[2] представляет собой ссылку на JSON-строку. Здесь есть заранее заданные значения, а мы предполагаем, что JSON-строка была вставлена во второе поле кортежа. Например, предположим, что кортеж выглядит следующим образом:"

#: ../doc/1.7/tutorials/lua_tutorials.rst:582
msgid ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""
"field[1]: 444\n"
"     field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"

#: ../doc/1.7/tutorials/lua_tutorials.rst:551
msgid "meaning that the tuple's first field, the primary key field, is a number while the tuple's second field, the JSON string, is a string. Thus the entire statement means \"decode ``t[2]`` (the tuple's second field) as a JSON string; if there's an error set ``is_valid_json = false``; if there's no error set ``is_valid_json = true`` and set ``lua_table =`` a Lua table which has the decoded string\"."
msgstr "что означает, что первое поле кортежа, первичное поле, представляет собой число, а второе поле кортежа, JSON-строка, является строкой. Таким образом, значение оператора будет следующим: \"декодировать ``t[2]`` (второе поле кортежа) как JSON-строку; если обнаружится ошибка, то указать ``is_valid_json = false``; если ошибок нет, указать ``is_valid_json = true`` и ``lua_table =`` Lua-таблица, в которой находится декодированная строка\"."

#: ../doc/1.7/tutorials/lua_tutorials.rst:557
msgid "**LINE 8.** At last we are ready to get the JSON field value from the Lua table that came from the JSON string. The value in field_name, which is the parameter for the whole function, must be a name of a JSON field. For example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": 15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the whole function is invoked with ``sum_json_field(\"Quantity\")``, then ``field_value = lua_table[field_name]`` is effectively the same as ``field_value = lua_table[\"Quantity\"]`` or even ``field_value = lua_table.Quantity``. Those are just three different ways of saying: for the Quantity field in the Lua table, get the value and put it in variable :code:`field_value`."
msgstr "**СТРОКА 8.** Наконец, мы готовы получить значение JSON-поля из Lua-таблицы, взятое из JSON-строки. Значение в field_name (имя_поля), которое является параметром всей функции, должно представлять собой JSON-поле. Например, в JSON-строке ``'{\"Hello\": \"world\", \"Quantity\": 15}'`` есть два JSON-поля: \"Hello\" и \"Quantity\". Если вся функция вызывается с помощью ``sum_json_field(\"Quantity\")``, тогда ``field_value = lua_table[field_name]`` (значение_поля = Lua_таблица[имя_поля]) по сути аналогично ``field_value = lua_table[\"Quantity\"]`` или даже ``field_value = lua_table.Quantity``. Итак, этими тремя способами можно ввести следующую команду: получить значение поля Quantity в Lua-таблице и поместить его в переменную :code:`field_value`."

#: ../doc/1.7/tutorials/lua_tutorials.rst:567
msgid "**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but the JSON field is not a number, or is missing. In that case, the function would be aborted when there was an attempt to add it to the sum. By first checking ``type(field_value) == \"number\"``, we avoid that abortion. Anyone who knows that the database is in perfect shape can skip this kind of thing."
msgstr "**СТРОКА 9: ЗАЧЕМ НУЖЕН \"IF\".** Предположим, что JSON-строка не содержит синтаксических ошибок, но JSON-поле не является числовым или вовсе отсутствует. В таком случае выполнение функции прервется при попытке прибавить значение к сумме. Если сначала проверить, ``type(field_value) == \"number\"`` (тип(значение_поля) == \"число\"), можно избежать прерывания функции. Если вы уверены, что база данных в идеальном состоянии, этот шаг можно пропустить."

#: ../doc/1.7/tutorials/lua_tutorials.rst:573
msgid "And the function is complete. Time to test it. Starting with an empty database, defined the same way as the sandbox database in our :ref:`\"Getting started\" exercises <getting_started>`,"
msgstr "И функция готова. Пора протестировать ее. Начинаем с пустой базы данных так же, как с песочницы в :ref:`упражнения в \"Руководстве для начинающих\" <getting_started>`,"

#: ../doc/1.7/tutorials/lua_tutorials.rst:577
msgid ""
"-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""
"-- если спейс tester остался от предыдущего задания, удалите его\n"
"     box.space.tester:drop()\n"
"     box.schema.space.create('tester')\n"
"     box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"

#: ../doc/1.7/tutorials/lua_tutorials.rst:584
msgid "then add some tuples where the first field is a number and the second field is a string."
msgstr "затем добавим несколько кортежей, где первое поле является числовым, а второе поле представляет собой строку."

#: ../doc/1.7/tutorials/lua_tutorials.rst:587
msgid ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": \"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"
msgstr ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"     box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"     box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": \"sunshine\"}'}\n"
"     box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"

#: ../doc/1.7/tutorials/lua_tutorials.rst:594
msgid "Since this is a test, there are deliberate errors. The \"golf club\" and the \"waffle iron\" do not have numeric Quantity fields, so must be ignored. Therefore the real sum of the Quantity field in the JSON strings should be: 15 + 7 = 22."
msgstr "Для целей практики здесь допущены ошибки. В \"golf club\" и \"waffle iron\" поля Quantity не являются числовыми, поэтому будут игнорироваться. Таким образом, итоговая сумма для полей Quantity в JSON-строках должна быть следующей: 15 + 7 = 22."

#: ../doc/1.7/tutorials/lua_tutorials.rst:599
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr "Вызовите функцию с помощью ``sum_json_field(\"Quantity\")``."

#: ../doc/1.7/tutorials/lua_tutorials.rst:601
msgid ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""
"tarantool> sum_json_field(\"Quantity\")\n"
"     ---\n"
"     - 22\n"
"     ..."

#: ../doc/1.7/tutorials/lua_tutorials.rst:608
msgid "It works. We'll just leave, as exercises for future improvement, the possibility that the \"hard coding\" assumptions could be removed, that there might have to be an overflow check if some field values are huge, and that the function should contain a :ref:`yield <atomic-threads_fibers_yields>` instruction if the count of tuples is huge."
msgstr "Сработало. Для дополнительной отработки материала можно убрать заранее заданные значения, добавить проверку потенциально возможного арифметического переполнения при наличии больших значений некоторых полей, а также команду :ref:`передачи управления <atomic-threads_fibers_yields>` при огромном количестве кортежей."

#: ../doc/1.7/tutorials/lua_tutorials.rst:617
msgid "Indexed pattern search"
msgstr "Индексированный поиск по шаблонам"

#: ../doc/1.7/tutorials/lua_tutorials.rst:619
msgid "Here is a generic function which takes a field identifier and a search pattern, and returns all tuples that match. |br| * The field must be the first field of a TREE index. |br| * The function will use `Lua pattern matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which allows \"magic characters\" in regular expressions. |br| * The initial characters in the pattern, as far as the first magic character, will be used as an index search key. For each tuple that is found via the index, there will be a match of the whole pattern. |br| * To be :ref:`cooperative <atomic-cooperative_multitasking>`, the function should yield after every 10 tuples, unless there is a reason to delay yielding. |br| With this function, we can take advantage of Tarantool's indexes for speed, and take advantage of Lua's pattern matching for flexibility. It does everything that an SQL \"LIKE\" search can do, and far more."
msgstr "Здесь приведена обобщенная функция, которая берет идентификатор поля и шаблон поиска, а затем возвращает все кортежи, которые подходят под критерии. |br| * Поле должно быть первым полем в TREE-индексе. |br| * Функция применяет `шаблоны в языке Lua <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, что позволяет использовать \"магические символы\" вы регулярных выражениях. |br| * Начальные символы в шаблоне до самого первого магического символа будут использоваться в качестве ключа поиска по индексу. Каждый кортеж, обнаруженный по индексу, будет соответствовать всему шаблону. |br| * В целях :ref:`кооперативной многозадачности <atomic-cooperative_multitasking>` функция должна передавать управление через каждые 10 кортежей, если только нет причин отложить передачу управления. |br| С помощью данной функции можно воспользоваться индексами Tarantool'а для ускорения и шаблонами на языке Lua для гибкости. Поддерживаются все возможности поиска LIKE в SQL — и многие другие."

#: ../doc/1.7/tutorials/lua_tutorials.rst:636
msgid "Read the following Lua code to see how it works. The comments that begin with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr "Прочитайте следующий Lua-код, чтобы понять, как он работает. Комментарии, которые начинаются с \"СМ. ПРИМЕЧАНИЕ ...\" ссылаются на подробные объяснения, приведенные ниже."

#: ../doc/1.7/tutorials/lua_tutorials.rst:640
msgid ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == \".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == \"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too short\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\"\n"
"      number_of_tuples_since_last_yield = number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set + 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"      -- СМ. ПРИМЕЧАНИЕ №1 \"ПОИСК НУЖНОГО ИНДЕКСА\"\n"
"      if (box.space[space_name] == nil) then\n"
"        print(\"Error: Failed to find the specified space\")\n"
"        return nil\n"
"      end\n"
"      local index_no = -1\n"
"      for i=0,box.schema.INDEX_MAX,1 do\n"
"        if (box.space[space_name].index[i] == nil) then break end\n"
"        if (box.space[space_name].index[i].type == \"TREE\"\n"
"            and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"            and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"            or box.space[space_name].index[i].parts[1].type == \"string\")) then\n"
"          index_no = i\n"
"          break\n"
"        end\n"
"      end\n"
"      if (index_no == -1) then\n"
"        print(\"Error: Failed to find an appropriate index\")\n"
"        return nil\n"
"      end\n"
"      -- СМ. ПРИМЕЧАНИЕ №2 \"ПОЛУЧЕНИЕ КЛЮЧА ИНДЕКСНОГО ПОИСКА ИЗ ШАБЛОНА\"\n"
"      local index_search_key = \"\"\n"
"      local index_search_key_length = 0\n"
"      local last_character = \"\"\n"
"      local c = \"\"\n"
"      local c2 = \"\"\n"
"      for i=1,string.len(pattern),1 do\n"
"        c = string.sub(pattern, i, i)\n"
"        if (last_character ~= \"%\") then\n"
"          if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == \".\"\n"
"                       or c == \"[\" or c == \"]\" or c == \"*\" or c == \"+\"\n"
"                       or c == \"-\" or c == \"?\") then\n"
"            break\n"
"          end\n"
"          if (c == \"%\") then\n"
"            c2 = string.sub(pattern, i + 1, i + 1)\n"
"            if (string.match(c2, \"%p\") == nil) then break end\n"
"            index_search_key = index_search_key .. c2\n"
"          else\n"
"            index_search_key = index_search_key .. c\n"
"          end\n"
"        end\n"
"        last_character = c\n"
"      end\n"
"      index_search_key_length = string.len(index_search_key)\n"
"      if (index_search_key_length < 3) then\n"
"        print(\"Error: index search key \" .. index_search_key .. \" is too short\")\n"
"        return nil\n"
"      end\n"
"      -- СМ. ПРИМЕЧАНИЕ №3 \"ВНЕШНИЙ ЦИКЛ: НАЧАЛО\"\n"
"      local result_set = {}\n"
"      local number_of_tuples_in_result_set = 0\n"
"      local previous_tuple_field = \"\"\n"
"      while true do\n"
"        local number_of_tuples_since_last_yield = 0\n"
"        local is_time_for_a_yield = false\n"
"        -- СМ. ПРИМЕЧАНИЕ №4 \"ВНУТРЕННИЙ ЦИКЛ: ИТЕРАТОР\"\n"
"        for _,tuple in box.space[space_name].index[index_no]:\n"
"        pairs(index_search_key,{iterator = box.index.GE}) do\n"
"          -- СМ. ПРИМЕЧАНИЕ №5 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ, ЕСЛИ КЛЮЧ ИНДЕКСА СЛИШКОМ БОЛЬШОЙ\"\n"
"          if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"          > index_search_key) then\n"
"            break\n"
"          end\n"
"          -- СМ. ПРИМЕЧАНИЕ №6 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ ПОСЛЕ КАЖДЫХ ДЕСЯТИ КОРТЕЖЕЙ -- ВОЗМОЖНО\"\n"
"          number_of_tuples_since_last_yield = number_of_tuples_since_last_yield + 1\n"
"          if (number_of_tuples_since_last_yield >= 10\n"
"              and tuple[field_no] ~= previous_tuple_field) then\n"
"            index_search_key = tuple[field_no]\n"
"            is_time_for_a_yield = true\n"
"            break\n"
"            end\n"
"          previous_tuple_field = tuple[field_no]\n"
"          -- СМ. ПРИМЕЧАНИЕ №7 \"ВНУТРЕННИЙ ЦИКЛ: ДОБАВЛЕНИЕ В РЕЗУЛЬТАТ, ЕСЛИ ШАБЛОН СОВПАДЕТ\"\n"
"          if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"            number_of_tuples_in_result_set = number_of_tuples_in_result_set + 1\n"
"            result_set[number_of_tuples_in_result_set] = tuple\n"
"          end\n"
"        end\n"
"        -- СМ. ПРИМЕЧАНИЕ №8 \"ВНЕШНИЙ ЦИКЛ: ПРЕРЫВАНИЕ ИЛИ ПЕРЕДАЧА УПРАВЛЕНИЯ И ПРОДОЛЖЕНИЕ\"\n"
"        if (is_time_for_a_yield ~= true) then\n"
"          break\n"
"        end\n"
"        require('fiber').yield()\n"
"      end\n"
"      return result_set\n"
"    end"

#: ../doc/1.7/tutorials/lua_tutorials.rst:731
msgid "NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed space_name (a string) and field_no (a number). The requirements are: |br| (a) index type must be \"TREE\" because for other index types (HASH, BITSET, RTREE) a search with :ref:`iterator=GE <box_index-iterator-types>` will not return strings in order by string value; |br| (b) field_no must be the first index part; |br| (c) the field must contain strings, because for other data types (such as \"unsigned\") pattern searches are not possible; |br| If these requirements are not met by any index, then print an error message and return nil."
msgstr "ПРИМЕЧАНИЕ №1 \"ПОИСК НУЖНОГО ИНДЕКСА\" |br| Вызывающий клиент передал space_name (имя_спейса — строка) и field_no (номер_поля — число). Требования следующие: |br| (a) тип индекса должен быть \"TREE\", поскольку для других типов индекса (HASH, BITSET, RTREE) поиск с :ref:`итератором=GE <box_index-iterator-types>` не вернет строки, упорядоченные по строковому значению; |br| (b) field_no должен представлять собой первую часть индекса; |br| (c) поле должно содержать строки, потому что для других типов данных (как \"unsigned\") шаблоны поиска не применяются; |br| Если индекс не удовлетворяет этим требованиям, выдать сообщение об ошибке и вернуть нулевое значение nil."

#: ../doc/1.7/tutorials/lua_tutorials.rst:743
msgid "NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has passed pattern (a string). The index search key will be the characters in the pattern as far as the first magic character. Lua's magic characters are % ^ $ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", the period is a magic character and therefore the index search key will be \"ABC\". But there is a complication ... If we see \"%\" followed by a punctuation character, that punctuation character is \"escaped\" so remove the \"%\" when making the index search key. For example, if the pattern is \"AB%$E\", the dollar sign is escaped and therefore the index search key will be \"AB$E\". Finally there is a check that the index search key length must be at least three -- this is an arbitrary number, and in fact zero would be okay, but short index search keys will cause long search times."
msgstr "ПРИМЕЧАНИЕ №2 \"ПОЛУЧЕНИЕ КЛЮЧА ИНДЕКСНОГО ПОИСКА ИЗ ШАБЛОНА\" |br| Вызывающий клиент передал шаблон (строку). Ключом поиска по индексу являются символы в шаблоне до первого магического символа. Магические символы в Lua: % ^ $ ( ) . [ ] * + - ?. Например, если задан шаблон \"ABC.E\", точка будет магическим символом, и ключом поиска по индексу будет \"ABC\". Однако есть затруднение ... Если символ \"%\" будет идти следом за знаком препинания, этот знак препинания экранируется, поэтому следует убрать \"%\" из ключа поиска по индексу. Например, если задан шаблон \"AB%$E\", знак доллара экранируется, поэтому ключом поиска по индексу будет \"AB$E\". Наконец, есть проверка длины ключа поиска по индексу — не менее трех символов, причем это число выбрано произвольно, и даже ноль здесь подойдет, но по короткому ключу поиск займет длительное время."

#: ../doc/1.7/tutorials/lua_tutorials.rst:760
msgid "NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return a result set, just as `box.space...select <box_space-select>` would. We will fill it within an outer loop that contains an inner loop. The outer loop's job is to execute the inner loop, and possibly :ref:`yield <atomic-threads_fibers_yields>`, until the search ends. The inner loop's job is to find tuples via the index, and put them in the result set if they match the pattern."
msgstr "ПРИМЕЧАНИЕ №3 \"ВНЕШНИЙ ЦИКЛ: НАЧАЛО\" |br| Назначение функции — вернуть результирующий набор данных, как вернул бы запрос `box.space...select <box_space-select>`. Мы внесем ее во внешний цикл, который включает в себя внутренний цикл. Назначение внешнего цикла — выполнять внутренний цикл и, при необходимости, :ref:`передачу управления <atomic-threads_fibers_yields>`, пока поиск не будет завершен. Назначение внутреннего цикла — находить кортежи по индексу и включать их в результирующий набор данных, если они подходят под шаблон."

#: ../doc/1.7/tutorials/lua_tutorials.rst:769
msgid "NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(), see the :ref:`explanation of what index iterators are <box_index-index_pairs>`. Within the inner loop, there will be a local variable named \"tuple\" which contains the latest tuple found via the index search key."
msgstr "ПРИМЕЧАНИЕ №4 \"ВНУТРЕННИЙ ЦИКЛ: ИТЕРАТОР\" |br| Цикл for здесь использует pairs(), см. :ref:`объяснение, что такое итераторы <box_index-index_pairs>`. Во внутреннем цикле будет локальная переменная под названием \"tuple\" (кортеж), которая содержит последний кортеж, обнаруженный в ходе поиска по индексу."

#: ../doc/1.7/tutorials/lua_tutorials.rst:776
msgid "NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator is GE (Greater or Equal), and we must be more specific: if the search index key has N characters, then the leftmost N characters of the result's index field must not be greater than the search index key. For example, if the search index key is 'ABC', then 'ABCDE' is a potential match, but 'ABD' is a signal that no more matches are possible."
msgstr "ПРИМЕЧАНИЕ №5 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ, ЕСЛИ КЛЮЧ ИНДЕКСА СЛИШКОМ БОЛЬШОЙ\" |br| Используется итератор GE (Greater or Equal - больше или равно), поэтому необходимо уточнить: если ключ поиска по индексу включает в себя N символов, то крайние N символов слева от найденного поля индекса не должны быть больше ключа поиска. Например, если ключом поиска является  'ABC', то 'ABCDE' потенциально подходит, а 'ABD' означает, что в дальнейшем совпадений не будет."

#: ../doc/1.7/tutorials/lua_tutorials.rst:785
msgid "NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This chunk of code is for cooperative multitasking. The number 10 is arbitrary, and usually a larger number would be okay. The simple rule would be \"after checking 10 tuples, yield, and then resume the search (that is, do the inner loop again) starting after the last value that was found\". However, if the index is non-unique or if there is more than one field in the index, then we might have duplicates -- for example {\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it would be difficult to decide which \"ABC\" tuple to resume with. Therefore, if the result's index field is the same as the previous result's index field, there is no break."
msgstr "ПРИМЕЧАНИЕ №6 \"ВНУТРЕННИЙ ЦИКЛ: ПРЕРЫВАНИЕ ПОСЛЕ КАЖДЫХ ДЕСЯТИ КОРТЕЖЕЙ -- ВОЗМОЖНО\" |br| Эта часть кода предназначена для кооперативной многозадачности. Число 10 выбрано произвольно, и как правило, большее число также подойдет. Простое правило гласит: \"после проверки 10 кортежей передать управление, а затем возобновить поиск (то есть снова выполнять внутренний цикл), начиная с последнего обнаруженного значения\". Однако, если индекс не уникален, или в индексе более одного поля, можно получить дублирующиеся результаты, например, {\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" — и будет трудно решить, с какого кортежа \"ABC\" возобновлять поиск. Таким образом, если найденное поле индекса совпадает с предыдущим найденным полем индекса, цикл не прерывается."

#: ../doc/1.7/tutorials/lua_tutorials.rst:798
msgid "NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare the result's index field to the entire pattern. For example, suppose that the caller passed pattern \"ABC.E\" and there is an indexed field containing \"ABCDE\". Therefore the initial index search key is \"ABC\". Therefore a tuple containing an indexed field with \"ABCDE\" will be found by the iterator, because \"ABCDE\" > \"ABC\". In that case string.match will return a value which is not nil. Therefore this tuple can be added to the result set."
msgstr "ПРИМЕЧАНИЕ №7 \"ВНУТРЕННИЙ ЦИКЛ: ДОБАВЛЕНИЕ В РЕЗУЛЬТАТ, ЕСЛИ ШАБЛОН СОВПАДЕТ\" |br| Сравнение найденного поля индекса с шаблоном. Например, предположим, что вызывающий клиент передает шаблон \"ABC.E\", и существует поле индекса, содержащее \"ABCDE\". В таком случае, начальный ключ поиска будет \"ABC\". Таким образом, кортеж, содержащий поле индекса с \"ABCDE\" будет обнаружен итератором, поскольку \"ABCDE\" > \"ABC\". В этом случае, string.match вернет значение, отличное от нулевого nil. В итоге, этот кортеж можно добавить в результирующий набор данных."

#: ../doc/1.7/tutorials/lua_tutorials.rst:808
msgid "NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three conditions which will cause a break from the inner loop: (1) the for loop ends naturally because there are no more index keys which are greater than or equal to the index search key, (2) the index key is too great as described in NOTE #5, (3) it is time for a yield as described in NOTE #6. If condition (1) or condition (2) is true, then there is nothing more to do, the outer loop ends too. If and only if condition (3) is true, the outer loop must yield and then continue. If it does continue, then the inner loop -- the iterator search -- will happen again with a new value for the index search key."
msgstr "ПРИМЕЧАНИЕ №8 \"ВНЕШНИЙ ЦИКЛ: ПРЕРЫВАНИЕ ИЛИ ПЕРЕДАЧА УПРАВЛЕНИЯ И ПРОДОЛЖЕНИЕ\" |br| Существуют три условия, которые вызовут прерывание из внутреннего цикла: (1) цикл for заканчивается закономерно, потому что отсутствуют ключи индекса, которые больше или равны ключу поиска по индексу, (2) ключ индекса слишком большой, как описано в ПРИМЕЧАНИИ №5, (3) пора передавать управление, как описано в ПРИМЕЧАНИИ №6. Если условие (1) или условие (2) соблюдается, другие действия не требуются, и внешний цикл также заканчивается. Только в том случае, если справедливо условие (3), внешний цикл должен передать управление, а затем продолжить выполнение. Если он продолжит выполнение, то внутренний цикл — поиск с итератором — будет выполняться снова с новым значением для ключа поиска по индексу."

#: ../doc/1.7/tutorials/lua_tutorials.rst:821
msgid "EXAMPLE:"
msgstr "ПРИМЕР:"

#: ../doc/1.7/tutorials/lua_tutorials.rst:823
msgid "Start Tarantool, cut and paste the code for function ``indexed_pattern_search()``, and try the following:"
msgstr "Запустите Tarantool, скопируйте и вставьте код для функции ``indexed_pattern_search()`` и попробуйте выполнить следующее:"

#: ../doc/1.7/tutorials/lua_tutorials.rst:863
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""
"box.space.t:drop()\n"
"    box.schema.space.create('t')\n"
"    box.space.t:create_index('primary',{})\n"
"    box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})\n"
"    box.space.t:insert{1,'A','a'}\n"
"    box.space.t:insert{2,'AB',''}\n"
"    box.space.t:insert{3,'ABC','a'}\n"
"    box.space.t:insert{4,'ABCD',''}\n"
"    box.space.t:insert{5,'ABCDE','a'}\n"
"    box.space.t:insert{6,'ABCDE',''}\n"
"    box.space.t:insert{7,'ABCDEF','a'}\n"
"    box.space.t:insert{8,'ABCDF',''}\n"
"    indexed_pattern_search(\"t\", 2, \"ABC.E.\")"

#: ../doc/1.7/tutorials/lua_tutorials.rst:845
msgid ""
"tarantool> indexed_pattern_search(\"t\", 2, \"ABC.E.\")\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""
"tarantool> indexed_pattern_search(\"t\", 2, \"ABC.E.\")\n"
"    ---\n"
"    - - [7, 'ABCDEF', 'a']\n"
"    ..."

#: ../doc/1.7/whats_new.rst:5
msgid "Release Notes"
msgstr "Release Notes"

#: ../doc/1.7/whats_new.rst:7
msgid "The Release Notes are summaries of significant changes introduced in Tarantool :ref:`1.7.6 <whats_new_176>`, :ref:`1.7.5 <whats_new_175>`, :ref:`1.7.4 <whats_new_174>`, :ref:`1.7.3 <whats_new_173>`, :ref:`1.7.2 <whats_new_172>`, :ref:`1.7.1 <whats_new_171>`, :ref:`1.6.9 <whats_new_169>`, :ref:`1.6.8 <whats_new_168>`, and :ref:`1.6.6 <whats_new_166>`."
msgstr "Release Notes представляют собой краткое описание значимых изменений в Tarantool'е :ref:`1.7.6 <whats_new_176>`, :ref:`1.7.5 <whats_new_175>`, :ref:`1.7.4 <whats_new_174>`, :ref:`1.7.3 <whats_new_173>`, :ref:`1.7.2 <whats_new_172>`, :ref:`1.7.1 <whats_new_171>`, :ref:`1.6.9 <whats_new_169>`, :ref:`1.6.8 <whats_new_168>` и :ref:`1.6.6 <whats_new_166>`."

#: ../doc/1.7/whats_new.rst:18
msgid "For smaller feature changes and bug fixes, see closed `milestones <https://github.com/tarantool/tarantool/milestones?state=closed>`_ at GitHub."
msgstr "Более мелкие изменения и исправления дефектов указаны в отчетах о `выпущенных стабильных релизах (milestone = closed) <https://github.com/tarantool/tarantool/milestones?state=closed>`_ на GitHub."

#: ../doc/1.7/whats_new.rst:26
msgid "Version 1.7"
msgstr "Версия 1.7"

#: ../doc/1.7/whats_new.rst:30
msgid "**Release 1.7.6**"
msgstr "**Версия 1.7.6**"

msgid "Version 1.9"
msgstr "Версия 1.9"

#: ../doc/1.7/whats_new.rst:26
msgid "Version 1.10"
msgstr "Версия 1.10"

#: ../doc/1.7/whats_new.rst:32
msgid "Release type: stable. Release date: 2017-11-07.  Tag: 1.7.6-0-g7b2945d6c."
msgstr "Тип версии: стабильная. Дата выхода: 2017-11-07.  Тег: 1.7.6-0-g7b2945d6c."

#: ../doc/1.7/whats_new.rst:34
msgid "Announcement: https://groups.google.com/forum/#!topic/tarantool/hzc7O2YDZUc."
msgstr "Объявление о выходе: https://groups.google.com/forum/#!topic/tarantool/hzc7O2YDZUc."

#: ../doc/1.7/whats_new.rst:36
msgid "This is the next stable release in the 1.7 series. It resolves more than 75 issues since 1.7.5."
msgstr "Данная сборка представляет собой очередную стабильную версию в серии 1.7. Это обновление содержит более 75 исправлений по сравнению с версией 1.7.5."

#: ../doc/1.7/whats_new.rst:39
msgid "What's new in Tarantool 1.7.6?"
msgstr "Что нового в Tarantool 1.7.6?"

#: ../doc/1.7/whats_new.rst:41
msgid "In addition to :ref:`rollback <box-rollback>` of a transaction, there is now rollback to a defined point within a transaction -- :ref:`savepoint <box-savepoint>` support."
msgstr "В дополнение к :ref:`откату <box-rollback>` транзакции, появился откат на определенную точку в пределах транзакции — поддержка :ref:`точки сохранения <box-savepoint>`."

#: ../doc/1.7/whats_new.rst:43
msgid "There is a new object type: :ref:`sequences <index-box_sequence>`. The older option, :ref:`auto-increment <box_space-auto_increment>`, will be deprecated."
msgstr "Появился новый объектный тип: :ref:`последовательности <index-box_sequence>`. Устаревший вариант, :ref:`автоматическое увеличение <box_space-auto_increment>`, больше не поддерживается."

#: ../doc/1.7/whats_new.rst:45
msgid "String indexes can have :ref:`collations <index-collation>`."
msgstr "В строковых индексах появилась :ref:`сортировка <index-collation>`."

#: ../doc/1.7/whats_new.rst:47
msgid "New options are available for:"
msgstr "Добавлены новые опции:"

#: ../doc/1.7/whats_new.rst:49
msgid ":ref:`net_box <net_box-module>` (timeouts),"
msgstr ":ref:`net_box <net_box-module>` (время ожидания),"

#: ../doc/1.7/whats_new.rst:50
msgid ":ref:`string <string-module>` functions,"
msgstr "функции :ref:`string <string-module>`,"

#: ../doc/1.7/whats_new.rst:51
msgid "space :ref:`formats <box_space-format>` (user-defined field names and types),"
msgstr ":ref:`форматы <box_space-format>` для спейса (имена и типы полей, задаваемые пользователем),"

#: ../doc/1.7/whats_new.rst:52
msgid ":ref:`base64 <digest-base64_encode>` (``urlsafe`` option), and"
msgstr ":ref:`base64 <digest-base64_encode>` (опция ``urlsafe``),  а также"

#: ../doc/1.7/whats_new.rst:53
msgid "index :ref:`creation <box_space-create_index>` (collation, :ref:`is-nullable <box_space-is_nullable>`, field names)."
msgstr ":ref:`создание <box_space-create_index>` индекса (сортировка, :ref:`is-nullable <box_space-is_nullable>` (возможность допустить неопределенное значение), имена полей)."

#: ../doc/1.7/whats_new.rst:56 ../doc/1.7/whats_new.rst:497
#: ../doc/1.7/whats_new.rst:557 ../doc/1.7/whats_new.rst:739
#: ../doc/1.7/whats_new.rst:782 ../doc/1.7/whats_new.rst:894
#: ../doc/1.7/whats_new.rst:936
msgid "Incompatible changes:"
msgstr "Несовместимые изменения:"

#: ../doc/1.7/whats_new.rst:58
msgid "Layout of ``box.space._index`` has been extended to support  ``is_nullable`` and ``collation`` features. All new indexes created on columns with ``is_nullable`` or ``collation`` properties will have the new definition format. Please update your client libraries if you plan to use these new features. Issue `2802 <https://github.com/tarantool/tarantool/issues/2802>`_"
msgstr "Расширенная структура ``box.space._index`` поддерживает функции ``is_nullable`` и ``collation`` (сортировку). Все новые индексы, созданные по столбцам со свойствами  ``is_nullable`` или ``collation`` получат новый формат определения. Обновите клиентские библиотеки, если планируете использовать новые возможности. Проблема `2802 <https://github.com/tarantool/tarantool/issues/2802>`_"

#: ../doc/1.7/whats_new.rst:64
msgid "``fiber.name()`` now raises an exception instead of truncating long fiber names. We found that some Lua modules such as ``expirationd`` use ``fiber.name()`` as a key to identify background tasks. If a name is truncated, this fact was silently missed. The new behavior allows to detect bugs caused by ``fiber.name()`` truncation. Please use ``fiber.name(name, { truncate = true })`` to emulate the old behavior. Issue `2622 <https://github.com/tarantool/tarantool/issues/2622>`_"
msgstr "``fiber.name()`` теперь выдает ошибку вместо усечения длинных имен файберов. Мы обнаружили, что некоторые Lua-модули, такие как ``expirationd``, используют ``fiber.name()`` для определения фоновых задач. Если же имя усечено, они упускают файбер из вида. Обновление позволит обнаружить ошибки, вызванные усечением имени файбера ``fiber.name()``. Используйте ``fiber.name(name, { truncate = true })`` для моделирования старого поведения системы. Проблема `2622 <https://github.com/tarantool/tarantool/issues/2622>`_"

#: ../doc/1.7/whats_new.rst:71
msgid "``space:format()`` is now validated on DML operations. Previously ``space:format()`` was only used by client libraries, but starting from Tarantoool 1.7.6, field types in ``space:format()`` are validated on the server side on every DML operation, and field names can be used in indexes and Lua code. If you used ``space:format()`` in a non-standard way, please update layout and type names according to the official documentation for :ref:`space formats <box_space-format>`."
msgstr "``space:format()`` проверяется в DML-операциях. Раньше ``space:format()`` использовался только в клиентских библиотеках, но с версии Tarantoool 1.7.6 типы полей в ``space:format()`` проверяются на стороне сервера при каждой DML-операции, и имена полей могут использоваться в индексах и Lua-коде. Если ``space:format()`` использовался нестандартно, обновите структуру и имена типов в соответствии с официальной документацией по :ref:`форматам спейса <box_space-format>`."

#: ../doc/1.7/whats_new.rst:79 ../doc/1.7/whats_new.rst:157
#: ../doc/1.7/whats_new.rst:350 ../doc/1.7/whats_new.rst:507
#: ../doc/1.7/whats_new.rst:567 ../doc/1.7/whats_new.rst:686
#: ../doc/1.7/whats_new.rst:746 ../doc/1.7/whats_new.rst:808
#: ../doc/1.7/whats_new.rst:906 ../doc/1.7/whats_new.rst:946
msgid "Functionality added or changed:"
msgstr "Изменения или добавления функциональности:"

#: ../doc/1.7/whats_new.rst:81
msgid "Hybrid schema-less + schemaful data model. Earlier Tarantool versions allowed to store arbitrary MessagePack documents in spaces. Starting from Tarantool 1.7.6, you can use :ref:`space:format() <box_space-format>` to define schema restrictions and constraints for tuples in spaces. Defined field types are automatically validated on every DML operation, and defined field names can be used instead of field numbers in Lua code. A new function ``tuple:tomap()`` was added to convert a tuple into a key-value Lua dictionary."
msgstr "Гибридная модель данных без схемы + со схемой. Раньше версии Tarantool позволяли хранить произвольный набор документов в формате MessagePack в спейсах. Начиная с версии Tarantool 1.7.6, можно использовать :ref:`space:format() <box_space-format>` для определения условий и ограничений схемы для кортежей в спейсах. Определенные типы полей автоматически проверяются при каждой DML-операции, а определенные имена полей могут использоваться вместо номеров полей в Lua-коде. Добавлена новая функция ``tuple:tomap()`` для конвертации кортежа в Lua-словарь пар ключ-значение."

#: ../doc/1.7/whats_new.rst:88
msgid "Collation and Unicode support. By default, when Tarantool compares strings, it takes into consideration only the numeric value of each byte in the string. To allow the ordering that you see in phone books and dictionaries, Tarantool 1.7.6 introduces support for collations based on the Default Unicode Collation Element Table (DUCET) and the rules described in Unicode® Technical Standard #10 Unicode Collation Algorithm (UTS #10 UCA). See :ref:`collations <index-collation>`."
msgstr "Поддержка сортировки и Юникода. По умолчанию, когда Tarantool сопоставляет строки, он берет во внимание только числовое значение каждого байта в строке. Чтобы задействовать такое распределение, как в телефонных справочниках и словарях, в Tarantool'е версии 1.7.6 впервые поддерживается сортировка по Таблице сортировки символов Юникода по умолчанию (Default Unicode Collation Element Table — DUCET) и в соответствии с правилами, описанными в Техническом стандарте Юникода №10 — Алгоритм сортировки по Юникоду (Unicode® Technical Standard #10 Unicode Collation Algorithm — UTS #10 UCA). См. :ref:`сортировку <index-collation>`."

#: ../doc/1.7/whats_new.rst:94
msgid "NULL values in unique and non-unique indexes. By default, all fields in Tarantool are  \"NOT NULL\". Starting from Tarantool 1.7.6, you can use ``is_nullable`` option in ``space:format()`` or inside an index part definition to allow storing NULL in indexes. Tarantool partially implements `three-valued logic <https://en.wikipedia.org/wiki/Three-valued_logic>`_ from the SQL standard and allows storing multiple NULL values in unique indexes. Issue `1557 <https://github.com/tarantool/tarantool/issues/1557>`_."
msgstr "Значения NULL в уникальных и неуникальных индексах. ПО умолчанию, все поля в Tarantool'е \"НЕ NULL\". Начиная с версии Tarantool 1.7.6, можно использовать опцию ``is_nullable`` (возможность допустить неопределенное значение) в ``space:format()`` или в определении части индекса, чтобы разрешить хранение значения NULL в индексах. Tarantool частично имплементирует `троичную логику <https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0>`_ из стандарта SQL и позволяет хранить несколько значений NULL в уникальных индексах. Проблема `1557 <https://github.com/tarantool/tarantool/issues/1557>`_."

#: ../doc/1.7/whats_new.rst:103
msgid "Sequences and a new implementation of ``auto_increment()``. Tarantool 1.7.6 introduces new :ref:`sequence number generators <index-box_sequence>` (like CREATE SEQUENCE in SQL). This feature is used to implement new persistent auto increment in spaces. Issue `389 <https://github.com/tarantool/tarantool/issues/389>`_."
msgstr "Последовательности и внедрение автоматического увеличения ``auto_increment()``. В версии Tarantool 1.7.6 впервые реализованы :ref:`генераторы порядковых номеров <index-box_sequence>` (как CREATE SEQUENCE — создание последовательности — в SQL). Эта функция используется для внедрения нового персистентного автоматического увеличения в спейсах. Проблема `389 <https://github.com/tarantool/tarantool/issues/389>`_."

#: ../doc/1.7/whats_new.rst:108
msgid "Vinyl: introduced gap locks in Vinyl transaction manager. The new locking mechanism in Vinyl TX manager reduces the number of conflicts in transactions. Issue `2671 <https://github.com/tarantool/tarantool/issues/2671>`_."
msgstr "Vinyl: появляется блокировка разрывов в менеджере транзакций Vinyl'а. Новый блокирующий механизм в менеджере Vinyl TX снижает количестве конфликтов в транзакциях. Проблема `2671 <https://github.com/tarantool/tarantool/issues/2671>`_."

#: ../doc/1.7/whats_new.rst:111
msgid "net.box: ``on_connect``/``on_disconnect`` triggers. Issue `2858 <https://github.com/tarantool/tarantool/issues/2858>`_."
msgstr "net.box: триггеры ``on_connect``/``on_disconnect`` (по подключению/отключению). Проблема `2858 <https://github.com/tarantool/tarantool/issues/2858>`_."

#: ../doc/1.7/whats_new.rst:113
msgid "Structured logging in JSON format. Issue `2795 <https://github.com/tarantool/tarantool/issues/2795>`_."
msgstr "Структурированная запись в журнал в формате JSON. Проблема `2795 <https://github.com/tarantool/tarantool/issues/2795>`_."

#: ../doc/1.7/whats_new.rst:115
msgid "(Lua) Lua: ``string.strip()`` Issue `2785 <https://github.com/tarantool/tarantool/issues/2785>`_."
msgstr "(Lua) Lua: ``string.strip()`` Проблема `2785 <https://github.com/tarantool/tarantool/issues/2785>`_."

#: ../doc/1.7/whats_new.rst:117
msgid "(Lua) added ``base64_urlsafe_encode()`` API to ``digest`` module. Issue `2777 <https://github.com/tarantool/tarantool/issues/2777>`_."
msgstr "(Lua) добавлен API ``base64_urlsafe_encode()`` для модуля ``digest``. Проблема `2777 <https://github.com/tarantool/tarantool/issues/2777>`_."

#: ../doc/1.7/whats_new.rst:119
msgid "Log conflicted keys in master-master replication. Issue `2779 <https://github.com/tarantool/tarantool/issues/2779>`_."
msgstr "Запись конфликтов в ключах в журнал в рамках репликации мастер-мастер. Проблема `2779 <https://github.com/tarantool/tarantool/issues/2779>`_."

#: ../doc/1.7/whats_new.rst:121
msgid "Allow to disable backtrace in ``fiber.info()``. Issue `2878 <https://github.com/tarantool/tarantool/issues/2878>`_."
msgstr "Возможность отключить обратную трассировку в ``fiber.info()``. Проблема `2878 <https://github.com/tarantool/tarantool/issues/2878>`_."

#: ../doc/1.7/whats_new.rst:123
msgid "Implemented ``tarantoolctl rocks make *.spec``. Issue `2846 <https://github.com/tarantool/tarantool/issues/2846>`_."
msgstr "Имплементирована возможность создания сторонних библиотек ``tarantoolctl rocks make *.spec``. Проблема 2846 <https://github.com/tarantool/tarantool/issues/2846>`_."

#: ../doc/1.7/whats_new.rst:125
msgid "Extended the default loader to look for ``.rocks`` in the parent dir hierarchy. Issue `2676 <https://github.com/tarantool/tarantool/issues/2676>`_."
msgstr "Новая функция загрузчика, используемого по умолчанию,  позволяет искать модули ``.rocks`` в родительской иерархии. Проблема `2676 <https://github.com/tarantool/tarantool/issues/2676>`_."

#: ../doc/1.7/whats_new.rst:127
msgid "``SOL_TCP`` options support in ``socket:setsockopt()``. Issue `598 <https://github.com/tarantool/tarantool/issues/598>`_."
msgstr "Поддержка опций ``SOL_TCP`` в ``socket:setsockopt()``. Проблема `598 <https://github.com/tarantool/tarantool/issues/598>`_."

#: ../doc/1.7/whats_new.rst:129
msgid "Partial emulation of LuaSocket on top of Tarantool Socket. Issue `2727 <https://github.com/tarantool/tarantool/issues/2727>`_."
msgstr "Частичное моделирование LuaSocket поверх Tarantool Socket. Проблема `2727 <https://github.com/tarantool/tarantool/issues/2727>`_."

#: ../doc/1.7/whats_new.rst:132
msgid "Developer tools:"
msgstr "Инструменты разработчика:"

#: ../doc/1.7/whats_new.rst:134
msgid "Integration with IntelliJ IDEA with debugging support. Now you can use IntelliJ IDEA as an IDE to develop and debug Lua applications for Tarantool. See :ref:`Using IDE <app_server-using_ide>`."
msgstr "Интеграция с IntelliJ IDEA с поддержкой отладки. Появилась возможность использовать IntelliJ IDEA в качестве IDE для разработки и отладки Lua-приложений для Tarantool'а. См. :ref:`Использование IDE <app_server-using_ide>`."

#: ../doc/1.7/whats_new.rst:137
msgid "Integration with `MobDebug <https://github.com/pkulchenko/MobDebug>`_ remote Lua debugger. Issue `2728 <https://github.com/tarantool/tarantool/issues/2728>`_."
msgstr "Интеграция с удаленным Lua-отладчиком `MobDebug <https://github.com/pkulchenko/MobDebug>`_. Проблема `2728 <https://github.com/tarantool/tarantool/issues/2728>`_."

#: ../doc/1.7/whats_new.rst:139
msgid "Configured ``/usr/bin/tarantool`` as an alternative Lua interpreter on Debian/Ubuntu. Issue `2730 <https://github.com/tarantool/tarantool/issues/2730>`_."
msgstr "Настройка ``/usr/bin/tarantool`` в качестве альтернативного Lua-интерпретатора для Debian/Ubuntu. Проблема `2730 <https://github.com/tarantool/tarantool/issues/2730>`_."

#: ../doc/1.7/whats_new.rst:142 ../doc/1.7/whats_new.rst:239
#: ../doc/1.7/whats_new.rst:919 ../doc/1.7/whats_new.rst:999
msgid "New rocks:"
msgstr "Новые сторонние библиотеки:"

#: ../doc/1.7/whats_new.rst:144
msgid "`smtp.client <https://github.com/tarantool/smtp>`_ - support SMTP via ``libcurl``."
msgstr "`smtp.client <https://github.com/tarantool/smtp>`_ — поддержка SMTP по ``libcurl``."

#: ../doc/1.7/whats_new.rst:148
msgid "**Release 1.7.5**"
msgstr "**Версия 1.7.5**"

#: ../doc/1.7/whats_new.rst:150
msgid "Release type: stable. Release date: 2017-08-22.  Tag: 1.7.5."
msgstr "Тип версии: стабильная. Дата выхода: 2017-08-22.  Тег: 1.7.5."

#: ../doc/1.7/whats_new.rst:152
msgid "Announcement: https://github.com/tarantool/doc/issues/289."
msgstr "Объявление о выходе: https://github.com/tarantool/doc/issues/289."

#: ../doc/1.7/whats_new.rst:154
msgid "This is a stable release in the 1.7 series. This release resolves more than 160 issues since 1.7.4."
msgstr "Данная сборка представляет собой стабильную версию в серии 1.7. Это обновление содержит более 160 исправлений по сравнению с версией 1.7.4."

#: ../doc/1.7/whats_new.rst:159
msgid "(Vinyl) a new ``force_recovery`` mode to recover broken disk files. Use ``box.cfg { force_recovery = true }`` to recover corrupted data files after hardware issues or power outages. Issue `2253 <https://github.com/tarantool/tarantool/issues/2253>`_."
msgstr "(Vinyl) новый режим ``force_recovery`` (принудительное восстановление) для восстановления поврежденных файлов на диске. Используйте ``box.cfg { force_recovery = true }`` для восстановления файлов с данными, поврежденными в результате проблем с оборудованием или отключения электроэнергии. Проблема `2253 <https://github.com/tarantool/tarantool/issues/2253>`_."

#: ../doc/1.7/whats_new.rst:163
msgid "(Vinyl) index options can be changed on the fly without rebuild. Now ``page_size``, ``run_size_ratio``, ``run_count_per_level`` and ``bloom_fpr`` index options can be dynamically changed via ``index:alter()``. The changes take effect in newly created data files only. Issue `2109 <https://github.com/tarantool/tarantool/issues/2109>`_."
msgstr "(Vinyl) параметры индекса можно менять на лету без необходимости пересборки. Появилась возможность динамически изменять параметры ``page_size``, ``run_size_ratio``, ``run_count_per_level`` и ``bloom_fpr`` с помощью ``index:alter()``. Изменения вступают в силу только для вновь созданных файлов. Проблема `2109 <https://github.com/tarantool/tarantool/issues/2109>`_."

#: ../doc/1.7/whats_new.rst:168
msgid "(Vinyl) improve ``box.info.vinyl()`` and ``index:info()`` output. Issue `1662 <https://github.com/tarantool/tarantool/issues/1662>`_."
msgstr "(Vinyl) улучшен вывод ``box.info.vinyl()`` и``index:info()``. Проблема `1662 <https://github.com/tarantool/tarantool/issues/1662>`_."

#: ../doc/1.7/whats_new.rst:170
msgid "(Vinyl) introduce ``box.cfg.vinyl_timeout`` option to control quota throttling. Issue `2014 <https://github.com/tarantool/tarantool/issues/2014>`_."
msgstr "(Vinyl) появляется опция ``box.cfg.vinyl_timeout`` для управления загрузкой на основе квот. Проблема `2014 <https://github.com/tarantool/tarantool/issues/2014>`_."

#: ../doc/1.7/whats_new.rst:172
msgid "Memtx: stable ``index:pairs()`` iterators for the TREE index. TREE iterators are automatically restored to a proper position after index's modifications. Issue `1796 <https://github.com/tarantool/tarantool/issues/1796>`_."
msgstr "Memtx: стабильные итераторы ``index:pairs()`` для TREE-индекса. TREE-итераторы автоматически восстанавливаются в правильном положении после изменений индекса. Проблема `1796 <https://github.com/tarantool/tarantool/issues/1796>`_."

#: ../doc/1.7/whats_new.rst:175
msgid "(Memtx) predictable order for non-unique TREE indexes. Non-unique TREE indexes preserve the sort order for duplicate entries. Issue `2476 <https://github.com/tarantool/tarantool/issues/2476>`_."
msgstr "(Memtx) предсказуемый порядок для неуникальных TREE-индексов. Неуникальные TREE-индексы сохраняют порядок сортировки для дублирующихся записей. Проблема `2476 <https://github.com/tarantool/tarantool/issues/2476>`_."

#: ../doc/1.7/whats_new.rst:178
msgid "(Memtx+Vinyl) dynamic configuration of max tuple size. Now ``box.cfg.memtx_max_tuple_size`` and ``box.cfg.vinyl_max_tuple_size`` configuration options can be changed on the fly without need to restart the server. Issue `2667 <https://github.com/tarantool/tarantool/issues/2667>`_."
msgstr "(Memtx+Vinyl) динамическая настройка максимального размера кортежа. Впервые конфигурационные параметры ``box.cfg.memtx_max_tuple_size`` и ``box.cfg.vinyl_max_tuple_size`` можно изменять на лету без необходимости перезагрузки сервера. Проблема `2667 <https://github.com/tarantool/tarantool/issues/2667>`_."

#: ../doc/1.7/whats_new.rst:182
msgid "(Memtx+Vinyl) new implementation. Space truncation doesn't cause re-creation of all indexes any more. Issue `618 <https://github.com/tarantool/tarantool/issues/618>`_."
msgstr "(Memtx+Vinyl) новая реализация. Усечение спейса больше не вызывает повторное создание всех индексов. Проблема `618 <https://github.com/tarantool/tarantool/issues/618>`_."

#: ../doc/1.7/whats_new.rst:185
msgid "Extended the maximal length of all identifiers from 32 to 65k characters. Space, user and function names are not limited by 32 characters anymore. Issue `944 <https://github.com/tarantool/tarantool/issues/944>`_."
msgstr "Максимальная длина всех идентификаторов расширена с 32 до 65 тысяч символов. Имена спейса, пользователя и функции больше не ограничены 32 символами. Проблема `944 <https://github.com/tarantool/tarantool/issues/944>`_."

#: ../doc/1.7/whats_new.rst:188
msgid "Heartbeat messages for replication. Replication client now sends the selective acknowledgments for processed records and automatically re-establish stalled connections. This feature also changes ``box.info.replication[replica_id].vclock`` to display committed vclock of remote replica. Issue `2484 <https://github.com/tarantool/tarantool/issues/2484>`_."
msgstr "Сообщения контрольного сигнала для репликации. Репликационный клиент теперь выборочно отправляет подтверждение обработки записей и автоматически переподключается в случае замедления. Также в рамках этого изменения ``box.info.replication[replica_id].vclock`` будет отображать определенный vclock удаленной реплики. Проблема `2484 <https://github.com/tarantool/tarantool/issues/2484>`_."

#: ../doc/1.7/whats_new.rst:194
msgid "Keep track of remote replicas during WAL maintenance. Replication master now automatically preserves xlogs needed for remote replicas. Issue `748 <https://github.com/tarantool/tarantool/issues/748>`_."
msgstr "Отслеживание удаленных реплик во время обслуживания WAL. Мастер репликации будет автоматически сохранять xlog-файлы, необходимые для удаленных реплик. Проблема `748 <https://github.com/tarantool/tarantool/issues/748>`_."

#: ../doc/1.7/whats_new.rst:197
msgid "Enabled ``box.tuple.new()`` to work without ``box.cfg()``. Issue `2047 <https://github.com/tarantool/tarantool/issues/2047>`_."
msgstr "``box.tuple.new()`` впервые работает с ``box.cfg()``. Проблема `2047 <https://github.com/tarantool/tarantool/issues/2047>`_."

#: ../doc/1.7/whats_new.rst:199
msgid "``box.atomic(fun, ...)`` wrapper to execute function in a transaction. Issue `818 <https://github.com/tarantool/tarantool/issues/818>`_."
msgstr "Надстройка ``box.atomic(fun, ...)`` будет выполнять функции в транзакции. Проблема `818 <https://github.com/tarantool/tarantool/issues/818>`_."

#: ../doc/1.7/whats_new.rst:201
msgid "box.session.type() helper to determine session type. Issue `2642 <https://github.com/tarantool/tarantool/issues/2642>`_."
msgstr "Вспомогательная функция ``box.session.type()`` будет определять тип сессии. Проблема `2642 <https://github.com/tarantool/tarantool/issues/2642>`_."

#: ../doc/1.7/whats_new.rst:203
msgid "Hot code reload for stored C stored procedures. Use ``box.schema.func.reload('modulename.function')`` to reload dynamic shared libraries on the fly. Issue `910 <https://github.com/tarantool/tarantool/issues/910>`_."
msgstr "Горячая перезагрузка кода для хранимых процедур на языке C. Используйте ``box.schema.func.reload('modulename.function')`` для перезагрузки библиотек общего пользования на лету. Проблема `910 <https://github.com/tarantool/tarantool/issues/910>`_."

#: ../doc/1.7/whats_new.rst:207
msgid "``string.hex()`` and ``str:hex()`` Lua API. Issue `2522 <https://github.com/tarantool/tarantool/issues/2522>`_."
msgstr "API для языка Lua: ``string.hex()`` и ``str:hex()``. Проблема `2522 <https://github.com/tarantool/tarantool/issues/2522>`_."

#: ../doc/1.7/whats_new.rst:209
msgid "Package manager based on LuaRocks. Use ``tarantoolctl rocks install MODULENAME`` to install MODULENAME Lua module from https://rocks.tarantool.org/. Issue `2067 <https://github.com/tarantool/tarantool/issues/2067>`_."
msgstr "Менеджер пакетов на основе LuaRocks. Используйте ``tarantoolctl rocks install MODULENAME`` для установки Lua-модуля MODULENAME (имя модуля) из https://rocks.tarantool.org/. Проблема `2067 <https://github.com/tarantool/tarantool/issues/2067>`_."

#: ../doc/1.7/whats_new.rst:213
msgid "Lua 5.1 command line options. Tarantool binary now supports '-i', '-e', '-m' and '-l' command line options. Issue `1265 <https://github.com/tarantool/tarantool/issues/1265>`_."
msgstr "Опции командной строки в Lua 5.1. Бинарный протокол Tarantool'а поддерживает опции командной строки: '-i', '-e', '-m' и '-l'. Проблема `1265 <https://github.com/tarantool/tarantool/issues/1265>`_."

#: ../doc/1.7/whats_new.rst:216
msgid "Experimental GC64 mode for LuaJIT. GC64 mode allow to operate the full address space on 64-bit hosts. Enable via ``-DLUAJIT_ENABLE_GC64=ON compile-time`` configuration option. Issue `2643 <https://github.com/tarantool/tarantool/issues/2643>`_."
msgstr "Экспериментальный режим GC64 для LuaJIT. Режим GC64 позволяет работать со спейсами с полным адресом на 64-битных хостах. Включить настройку можно с помощью ``-DLUAJIT_ENABLE_GC64=ON compile-time``. Проблема `2643 <https://github.com/tarantool/tarantool/issues/2643>`_."

#: ../doc/1.7/whats_new.rst:220
msgid "Syslog logger now support non-blocking mode. ``box.cfg { log_nonblock = true }`` now also works for syslog logger. Issue `2466 <https://github.com/tarantool/tarantool/issues/2466>`_."
msgstr "Регистратор журнала syslog поддерживает неблокирующий режим. ``box.cfg { log_nonblock = true }`` также работает для регистратора syslog. Проблема `2466 <https://github.com/tarantool/tarantool/issues/2466>`_."

#: ../doc/1.7/whats_new.rst:223
msgid "Added a VERBOSE log level beyond INFO. Issue `2467 <https://github.com/tarantool/tarantool/issues/2467>`_."
msgstr "Добавлен уровень записи в журнал VERBOSE выше INFO. Проблема `2467 <https://github.com/tarantool/tarantool/issues/2467>`_."

#: ../doc/1.7/whats_new.rst:225
msgid "Tarantool now automatically makes snapshots every hour. Please set ``box.cfg { checkpoint_interval = 0 }`` to restore pre-1.7.5 behaviour. Issue `2496 <https://github.com/tarantool/tarantool/issues/2496>`_."
msgstr "Tarantool автоматически делает снимки каждый час. Установите ``box.cfg { checkpoint_interval = 0 }``, чтобы восстановить поведение предыдущих версий. Проблема `2496 <https://github.com/tarantool/tarantool/issues/2496>`_."

#: ../doc/1.7/whats_new.rst:228
msgid "Increase precision for percentage ratios provoded by ``box.slab.info()``. Issue `2082 <https://github.com/tarantool/tarantool/issues/2082>`_."
msgstr "Увеличена точность для процентного соотношения, приведенного с помощью ``box.slab.info()``. Проблема `2082 <https://github.com/tarantool/tarantool/issues/2082>`_."

#: ../doc/1.7/whats_new.rst:230
msgid "Stack traces now contains symbols names on all supported platforms. Previous versions of Tarantool didn't display meaningful function names in ``fiber.info()`` on non-x86 platforms. Issue `2103 <https://github.com/tarantool/tarantool/issues/2103>`_."
msgstr "Трассировка стека будет содержать имена символов на всех поддерживаемых платформах. В предыдущих версиях Tarantool не отображал значимые имена функций в ``fiber.info()`` на платформах не-x86. Проблема `2103 <https://github.com/tarantool/tarantool/issues/2103>`_."

#: ../doc/1.7/whats_new.rst:234
msgid "Allowed to create fiber with custom stack size from C API. Issue `2438 <https://github.com/tarantool/tarantool/issues/2438>`_."
msgstr "Появилась возможность создания файбера с заданным размером стека из API для языка C. Проблема `2438 <https://github.com/tarantool/tarantool/issues/2438>`_."

#: ../doc/1.7/whats_new.rst:236
msgid "Added ``ipc_cond`` to public C API. Issue `1451 <https://github.com/tarantool/tarantool/issues/1451>`_."
msgstr "В API для языка C добавлена функция ``ipc_cond``. Проблема `1451 <https://github.com/tarantool/tarantool/issues/1451>`_."

#: ../doc/1.7/whats_new.rst:241
msgid "``http.client`` (built-in) - libcurl-based HTTP client with SSL/TLS support. Issue `2083 <https://github.com/tarantool/tarantool/issues/x2083>`_."
msgstr "``http.client`` (встроенная) - HTTP-клиент на основе libcurl с поддержкой SSL/TLS. Проблема `2083 <https://github.com/tarantool/tarantool/issues/x2083>`_."

#: ../doc/1.7/whats_new.rst:243
msgid "``iconv`` (built-in) - bindings for iconv. Issue `2587 <https://github.com/tarantool/tarantool/issues/2587>`_."
msgstr "``iconv`` (встроенная) - bindings for iconv. Issue `2587 <https://github.com/tarantool/tarantool/issues/2587>`_."

#: ../doc/1.7/whats_new.rst:245
msgid "`authman <https://github.com/mailru/tarantool-authman>`_ - API for user registration and login in your site using email and social networks."
msgstr "`authman <https://github.com/mailru/tarantool-authman>`_ - API для регистрации пользователя и входа в систему с использованием email и социальных сетей."

#: ../doc/1.7/whats_new.rst:247
msgid "`document <ttps://github.com/tarantool/document>`_ - store nested documents in Tarantool."
msgstr "`document <ttps://github.com/tarantool/document>`_ - хранит вложенные документы в Tarantool'е."

#: ../doc/1.7/whats_new.rst:248
msgid "`synchronized <https://github.com/tarantool/synchronized>`_ - critical sections for Lua."
msgstr "`synchronized <https://github.com/tarantool/synchronized>`_ - критические секции для Lua."

#: ../doc/1.7/whats_new.rst:252
msgid "**Release 1.7.4**"
msgstr "**Версия 1.7.4**"

#: ../doc/1.7/whats_new.rst:254
msgid "Release type: release candidate. Release date: 2017-05-12. Release tag: Tag: 1.7.4."
msgstr "Тип версии: предварительная версия. Дата выхода: 2017-05-12.  Тег версии: 1.7.4."

#: ../doc/1.7/whats_new.rst:256
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.7.4 or https://groups.google.com/forum/#!topic/tarantool/3x88ATX9YbY"
msgstr "Объявление о выходе: https://github.com/tarantool/tarantool/releases/tag/1.7.4 or https://groups.google.com/forum/#!topic/tarantool/3x88ATX9YbY"

#: ../doc/1.7/whats_new.rst:259
msgid "This is a release candidate in the 1.7 series. Vinyl Engine, the flagship feature of 1.7.x, is now feature complete."
msgstr "Данная сборка представляет собой предварительную версию перед выпуском нового релиза в серии 1.7. Движок vinyl, ключевой компонент 1.7.x, обладает полностью реализованной заявленной функциональностью."

#: ../doc/1.7/whats_new.rst:262
msgid "Incompatible changes"
msgstr "Несовместимые изменения"

#: ../doc/1.7/whats_new.rst:264
msgid "``box.cfg()`` options were changed to add Vinyl support:"
msgstr "Для поддержки vinyl были внесены следующие изменения в параметры ``box.cfg()``:"

#: ../doc/1.7/whats_new.rst:266
msgid "``snap_dir`` renamed to ``memtx_dir``"
msgstr "переименование ``snap_dir`` в ``memtx_dir``"

#: ../doc/1.7/whats_new.rst:267
msgid "``slab_alloc_arena`` (gigabytes) renamed to ``memtx_memory`` (bytes), default value changed from 1Gb to 256MB"
msgstr "переименование ``slab_alloc_arena`` (гигабайты) в ``memtx_memory`` (байты), значение, используемое по умолчанию, изменилось с 1 Гб на 256 Мб"

#: ../doc/1.7/whats_new.rst:269
msgid "``slab_alloc_minimal`` renamed to ``memtx_min_tuple_size``"
msgstr "переименование ``slab_alloc_minimal`` в ``memtx_min_tuple_size``"

#: ../doc/1.7/whats_new.rst:270
msgid "``slab_alloc_maximal`` renamed to ``memtx_max_tuple_size``"
msgstr "переименование ``slab_alloc_maximal`` в ``memtx_max_tuple_size``"

#: ../doc/1.7/whats_new.rst:271
msgid "``slab_alloc_factor`` is deprecated, not relevant in 1.7.x"
msgstr "``slab_alloc_factor`` больше не используется, не применимо в 1.7.x"

#: ../doc/1.7/whats_new.rst:272
msgid "``snapshot_count`` renamed to ``checkpoint_count``"
msgstr "переименование ``snapshot_count`` в ``checkpoint_count``"

#: ../doc/1.7/whats_new.rst:273
msgid "``snapshot_period`` renamed to ``checkpoint_interval``"
msgstr "переименование ``snapshot_period`` в ``checkpoint_interval``"

#: ../doc/1.7/whats_new.rst:274
msgid "``rows_per_wal`` renamed to ``wal_max_size``"
msgstr "переименование ``rows_per_wal`` в ``wal_max_size``"

#: ../doc/1.7/whats_new.rst:275
msgid "``logger`` renamed to ``log``"
msgstr "переименование ``logger`` в ``log``"

#: ../doc/1.7/whats_new.rst:276
msgid "``logger_nonblock`` renamed to ``log_nonblock``"
msgstr "переименование ``logger_nonblock`` в ``log_nonblock``"

#: ../doc/1.7/whats_new.rst:277
msgid "``logger_level`` renamed to ``log_level``"
msgstr "переименование ``logger_level`` в ``log_level``"

#: ../doc/1.7/whats_new.rst:278
msgid "``replication_source`` renamed to ``replication``"
msgstr "переименование ``replication_source`` в ``replication``"

#: ../doc/1.7/whats_new.rst:279
msgid "``panic_on_snap_error = true`` and ``panic_on_wal_error = true`` superseded by ``force_recovery = false``"
msgstr "``panic_on_snap_error = true`` и ``panic_on_wal_error = true`` заменены ``force_recovery = false``"

#: ../doc/1.7/whats_new.rst:282
msgid "Until Tarantool 1.8, you can use deprecated parameters for both initial and runtime configuration, but such usage will print a warning in the server log. Issues `1927 <https://github.com/tarantool/tarantool/issues/1927>`_ and `2042 <https://github.com/tarantool/tarantool/issues/2042>`_."
msgstr "В версиях Tarantool'а до 1.8 можно использовать устаревшие параметры как для начальной, так и для рабочей конфигурации, но в таком случае система запишет сообщение предупреждения в журнал сервера. Проблемы `1927 <https://github.com/tarantool/tarantool/issues/1927>`_ и `2042 <https://github.com/tarantool/tarantool/issues/2042>`_."

#: ../doc/1.7/whats_new.rst:288
msgid "Hot standy mode is now off by default. Tarantool automatically detects another running instance in the same ``wal_dir`` and refuses to start. Use ``box.cfg {hot_standby = true}`` to enable the hot standby mode. Issue `775 <https://github.com/tarantool/tarantool/issues/775>`_."
msgstr "Режим hot standby (горячий резерв) по умолчанию будет отключен. Tarantool автоматически находит еще один запущенный экземпляр в той же директории ``wal_dir`` и откажется запускаться. Используйте ``box.cfg {hot_standby = true}`` для включения режима hot standby. Проблема `775 <https://github.com/tarantool/tarantool/issues/775>`_."

#: ../doc/1.7/whats_new.rst:292
msgid "UPSERT via a secondary key was banned to avoid unclear semantics. Issue `2226 <https://github.com/tarantool/tarantool/issues/2226>`_."
msgstr "Операция UPSERT по вторичному ключу запрещена во избежание неопределенности семантики. Проблема `2226 <https://github.com/tarantool/tarantool/issues/2226>`_."

#: ../doc/1.7/whats_new.rst:294
msgid "``box.info`` and ``box.info.replication`` format was changed to display information about upstream and downstream connections:"
msgstr "В формат ``box.info`` и ``box.info.replication`` для отображения информации о подключениях к upstream и downstream внесены следующие изменения:"

#: ../doc/1.7/whats_new.rst:297
msgid "Added ``box.info.replication[instance_id].downstream.vclock`` to display the last sent row to remote replica."
msgstr "Добавление ``box.info.replication[instance_id].downstream.vclock`` для отображения последней строки, отправленной на удаленную реплику."

#: ../doc/1.7/whats_new.rst:299
msgid "Added ``box.info.replication[instance_id].id``."
msgstr "Добавление ``box.info.replication[instance_id].id``."

#: ../doc/1.7/whats_new.rst:300
msgid "Added ``box.info.replication[instance_id].lsn``."
msgstr "Добавление ``box.info.replication[instance_id].lsn``."

#: ../doc/1.7/whats_new.rst:301
msgid "Moved ``box.info.replication[instance_id].{vclock,status,error}`` to ``box.info.replication[instance_id].upstream.{vclock,status,error}``."
msgstr "Перемещение ``box.info.replication[instance_id].{vclock,status,error}`` в ``box.info.replication[instance_id].upstream.{vclock,status,error}``."

#: ../doc/1.7/whats_new.rst:303
msgid "All registered replicas from ``box.space._cluster`` are included to ``box.info.replication`` output."
msgstr "Включение всех зарегистрированных реплик из ``box.space._cluster`` в вывод ``box.info.replication``."

#: ../doc/1.7/whats_new.rst:305
msgid "``box.info.server.id`` renamed ``box.info.id``"
msgstr "Переименование ``box.info.server.id`` в ``box.info.id``"

#: ../doc/1.7/whats_new.rst:306
msgid "``box.info.server.lsn`` renamed ``box.info.lsn``"
msgstr "Переименование ``box.info.server.lsn`` в ``box.info.lsn``"

#: ../doc/1.7/whats_new.rst:307
msgid "``box.info.server.uuid`` renamed ``box.info.uuid``"
msgstr "Переименование ``box.info.server.uuid`` в ``box.info.uuid``"

#: ../doc/1.7/whats_new.rst:308
msgid "``box.info.cluster.signature`` renamed to ``box.info.signature``"
msgstr "Переименование ``box.info.cluster.signature`` в ``box.info.signature``"

#: ../doc/1.7/whats_new.rst:309
msgid "``box.info.id`` and ``box.info.lsn`` now return `nil` instead of `-1` during initial cluster bootstrap."
msgstr "Возврат значения `nil` вместо `-1` функциями ``box.info.id`` и ``box.info.lsn`` во время начальной настройки кластера."

#: ../doc/1.7/whats_new.rst:312
msgid "Issue `723 <https://github.com/tarantool/tarantool/issues/723>`_."
msgstr "Проблема `723 <https://github.com/tarantool/tarantool/issues/723>`_."

#: ../doc/1.7/whats_new.rst:314
msgid "``net.box``: added per-request options to all requests:"
msgstr "``net.box``: добавление запрошенные параметров во все запросы:"

#: ../doc/1.7/whats_new.rst:316
msgid "``conn.call(func_name, arg1, arg2,...)`` changed to ``conn.call(func_name, {arg1, arg2, ...}, opts)``"
msgstr "изменение ``conn.call(func_name, arg1, arg2,...)`` на ``conn.call(func_name, {arg1, arg2, ...}, opts)``"

#: ../doc/1.7/whats_new.rst:318
msgid "``conn.eval(func_name, arg1, arg2,...)`` changed to ``conn.eval(func_name, {arg1, arg2, ...}, opts)``"
msgstr "изменение ``conn.eval(func_name, arg1, arg2,...)`` на ``conn.eval(func_name, {arg1, arg2, ...}, opts)``"

#: ../doc/1.7/whats_new.rst:321
msgid "All requests now support ``timeout = <seconds>``, ``buffer = <ibuf>`` options."
msgstr "Все запросы поддерживают параметры ``timeout = <seconds>``(время задержки в секундах), ``buffer = <ibuf>`` (буфер)."

#: ../doc/1.7/whats_new.rst:322
msgid "Added ``connect_timeout`` option to ``netbox.connect()``."
msgstr "Добавление опции ``connect_timeout`` в ``netbox.connect()``."

#: ../doc/1.7/whats_new.rst:323
msgid "``netbox:timeout()`` and ``conn:timeout()`` are now deprecated. Use ``netbox.connect(host, port, { call_16 = true })`` for 1.6.x-compatible behavior. Issue `2195 <https://github.com/tarantool/tarantool/issues/2195>`_."
msgstr "``netbox:timeout()`` и ``conn:timeout()`` объявлены устаревшими. Используйте ``netbox.connect(host, port, { call_16 = true })``, чтобы получить поведение как в 1.6.x. Проблема `2195 <https://github.com/tarantool/tarantool/issues/2195>`_."

#: ../doc/1.7/whats_new.rst:327
msgid "systemd configuration changed to support ``Type=Notify`` / ``sd_notify()``. Now ``systemctl start tarantool@INSTANCE`` will wait until Tarantool has started and recovered from xlogs. The recovery status is reported to ``systemctl status tarantool@INSTANCE``. Issue `1923 <https://github.com/tarantool/tarantool/issues/1923>`_."
msgstr "Конфигурация systemd будет поддерживать ``Type=Notify`` / ``sd_notify()``. ``systemctl start tarantool@ЭКЗЕМПЛЯР`` будет ожидать, пока Tarantool не запустится и не восстановится из xlog-файлов. Статус восстановления передается в ``systemctl status tarantool@ЭКЗЕМПЛЯР``. Проблема `1923 <https://github.com/tarantool/tarantool/issues/1923>`_."

#: ../doc/1.7/whats_new.rst:332
msgid "``log`` module now doesn't prefix all messages with the full path to tarantool binary when used without ``box.cfg()``. Issue `1876 <https://github.com/tarantool/tarantool/issues/1876>`_."
msgstr "Модуль ``log`` не будет присоединять ко всем сообщениям полный путь к бинарному файлу при использовании без ``box.cfg()``. Проблема `1876 <https://github.com/tarantool/tarantool/issues/1876>`_."

#: ../doc/1.7/whats_new.rst:335
msgid "``require('log').logger_pid()`` was renamed to ``require('log').pid()``. Issue `2917 <https://github.com/tarantool/tarantool/issues/2917>`_."
msgstr "Переименование ``require('log').logger_pid()`` в ``require('log').pid()``. Проблема `2917 <https://github.com/tarantool/tarantool/issues/2917>`_."

#: ../doc/1.7/whats_new.rst:337
msgid "Removed Lua 5.0 compatible defines and functions:"
msgstr "Удаленные определения и функции, совместимые с Lua 5.0:"

#: ../doc/1.7/whats_new.rst:339
msgid "``luaL_reg`` removed in favor of ``luaL_Reg``"
msgstr "Удаление ``luaL_reg`` в пользу ``luaL_Reg``"

#: ../doc/1.7/whats_new.rst:340
msgid "``luaL_getn(L, i)`` removed in favor of ``lua_objlen(L, i)``"
msgstr "Удаление ``luaL_getn(L, i)`` в пользу ``lua_objlen(L, i)``"

#: ../doc/1.7/whats_new.rst:341
msgid "``luaL_setn(L, i, j)`` removed (was no-op)"
msgstr "Удаление ``luaL_setn(L, i, j)`` (пустая операция)"

#: ../doc/1.7/whats_new.rst:342
msgid "``lua_ref(L, lock)`` removed in favor of ``luaL_ref(L, lock)``"
msgstr "Удаление ``lua_ref(L, lock)`` в пользу ``luaL_ref(L, lock)``"

#: ../doc/1.7/whats_new.rst:343
msgid "``lua_getref(L,ref)`` removed in favor of ``lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))``"
msgstr "Удаление ``lua_getref(L,ref)`` в пользу ``lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))``"

#: ../doc/1.7/whats_new.rst:344
msgid "``lua_unref(L, ref)`` removed in favor of ``luaL_unref(L, ref)``"
msgstr "Удаление ``lua_unref(L, ref)`` в пользу ``luaL_unref(L, ref)``"

#: ../doc/1.7/whats_new.rst:345
msgid "``math.mod()`` removed in favor of ``math.fmod()``"
msgstr "Удаление ``math.mod()`` в пользу ``math.fmod()``"

#: ../doc/1.7/whats_new.rst:346
msgid "``string.gfind()`` removed in favor of ``string.gmatch()``"
msgstr "Удаление ``string.gfind()`` в пользу ``string.gmatch()``"

#: ../doc/1.7/whats_new.rst:348 ../doc/1.7/whats_new.rst:417
msgid "Issue `2396 <https://github.com/tarantool/tarantool/issues/2396>`_."
msgstr "Проблема `2396 <https://github.com/tarantool/tarantool/issues/2396>`_."

#: ../doc/1.7/whats_new.rst:352
msgid "(Vinyl) multi-level compaction. The compaction scheduler now groups runs of the same range into levels to reduce the write amplification during compaction. This design allows Vinyl to support 1:100+ ram:disk use-cases. Issue `1821 <https://github.com/tarantool/tarantool/issues/1821>`_."
msgstr "(Vinyl) многоуровневое слияние. Планировщик слияния будет группировать забеги одного диапазона в уровни, чтобы снизить \"паразитную\" запись во время слияния. Новая функция позволит Vinyl'у поддерживать сценарии 1:100+ оперативная память:диск. Проблема `1821 <https://github.com/tarantool/tarantool/issues/1821>`_."

#: ../doc/1.7/whats_new.rst:357
msgid "(Vinyl) bloom filters for sorted runs. Bloom filter is a probabilistic data structure which can be used to test whether a requested key is present in a run file without reading the actual file from the disk. Bloom filter may have false-positive matches but false-negative matches are impossible. This feature reduces the number of seeks needed for random lookups and speeds up REPLACE/DELETE with enabled secondary keys. Issue `1919 <https://github.com/tarantool/tarantool/issues/1919>`_."
msgstr "(Vinyl) Фильтры Блума для отсортированных забегов. Фильтр Блума — это вероятностная структура данных, которую можно использовать для проверки наличия необходимого ключа в файле забега без считывания самого файла с диска. Фильтр Блума может выдавать ложноположительное срабатывание (элемента в множестве нет, но структура данных сообщает, что он есть), но не ложноотрицательное. Данная функция уменьшает объем поиска, необходимый для случайного просмотра, и ускоряет операции REPLACE/DELETE with enabled secondary keys. Проблема `1919 <https://github.com/tarantool/tarantool/issues/1919>`_."

#: ../doc/1.7/whats_new.rst:365
msgid "(Vinyl) key-level cache for point lookups and range queries. Vinyl storage engine caches selected keys and key ranges instead of entire disk pages like in traditional databases. This approach is more efficient because the cache is not polluted with raw disk data. Issue `1692 <https://github.com/tarantool/tarantool/issues/1692>`_."
msgstr "(Vinyl) кэш на уровне ключей для поиска точек и запросов по диапазону. Движок базы данных Vinyl кэширует выбранные ключи и диапазоны ключей вместо страниц диска полностью, как в традиционных базах данных. Такой подход более эффективен, поскольку кэш не заполнен сырыми данными. Проблема `1692 <https://github.com/tarantool/tarantool/issues/1692>`_."

#: ../doc/1.7/whats_new.rst:370
msgid "(Vinyl) implemented the common memory level for in-memory indexes. Now all in-memory indexes of a space store pointers to the same tuples instead of cached secondary key index data. This feature significantly reduces the memory footprint in case of secondary keys. Issue `1908 <https://github.com/tarantool/tarantool/issues/1908>`_."
msgstr "(Vinyl) внедрение уровня общей памяти для in-memory индексов. Все in-memory индексы спейса будут хранить указатели на одни и те же кортежи, вместо закэшированных данных вторичного индекса. Данная функция значительно уменьшает объем необходимой памяти в случае вторичных ключей. Проблема `1908 <https://github.com/tarantool/tarantool/issues/1908>`_."

#: ../doc/1.7/whats_new.rst:375
msgid "(Vinyl) new implementation of initial state transfer of JOIN command in replication protocol. New replication protocol fixes problems with consistency and secondary keys. We implemented a special kind of low-cost database-wide read-view to avoid dirty reads in JOIN procedure. This trick wasn't not possible in traditional B-Tree based databases. Issue `2001 <https://github.com/tarantool/tarantool/issues/2001>`_."
msgstr "(Vinyl) новая реализация передачи начального состояния JOIN-команды в протоколе репликации. Новый протокол репликации исправляет проблемы с согласованностью и вторичными ключами. Мы внедрили специальный вид просмотра по всей базе данных с небольшой нагрузкой, чтобы избежать неподтвержденного чтения в JOIN-процедуре. В традиционных базах данных на основе B-Tree такое не представляется возможным. Проблема `2001 <https://github.com/tarantool/tarantool/issues/2001>`_."

#: ../doc/1.7/whats_new.rst:381
msgid "(Vinyl) index-wide mems/runs. Removed ranges from in-memory and and the stop layer of LSM tree on disk. Issue `2209 <https://github.com/tarantool/tarantool/issues/2209>`_."
msgstr "(Vinyl) забеги по всему индексу. Удалены диапазоны из оперативной памяти и уровень LSM-дерева на диске. Проблема `2209 <https://github.com/tarantool/tarantool/issues/2209>`_."

#: ../doc/1.7/whats_new.rst:384
msgid "(Vinyl) coalesce small ranges. Before dumping or compacting a range, consider coalescing it with its neighbors. Issue `1735 <https://github.com/tarantool/tarantool/issues/1735>`_."
msgstr "(Vinyl) объединение небольших диапазонов. Перед созданием дампа или слиянием диапазона рассмотрите возможность объединения его с соседними диапазонами. Проблема `1735 <https://github.com/tarantool/tarantool/issues/1735>`_."

#: ../doc/1.7/whats_new.rst:388
msgid "(Vinyl) implemented transnational journal for metadata. Now information about all Vinyl files is logged in a special ``.vylog`` file. Issue `1967 <https://github.com/tarantool/tarantool/issues/1967>`_."
msgstr "(Vinyl) внедрен многосторонний журнал для метаданных. Информация о всех Vinyl-файлах будет записываться в специальный ``.vylog``-файл. Проблема `1967 <https://github.com/tarantool/tarantool/issues/1967>`_."

#: ../doc/1.7/whats_new.rst:391
msgid "(Vinyl) implemented consistent secondary keys. Issue `2410 <https://github.com/tarantool/tarantool/issues/2410>`_."
msgstr "(Vinyl) появились постоянные вторичные ключи. Проблема `2410 <https://github.com/tarantool/tarantool/issues/2410>`_."

#: ../doc/1.7/whats_new.rst:393
msgid "(Memtx+Vinyl) implemented low-level Lua API to create consistent backups. of Memtx + Vinyl data. The new feature provides ``box.backup.start()/stop()`` functions to create backups of all spaces. ``box.backup.start()`` pauses garbage collection and returns the list of files to copy. These files then can be copied be any third-party tool, like cp, ln, tar, rsync, etc. ``box.backup.stop()`` resumes the background garbage collection process. Created backups can be restored instantly by copying into a new directory and starting a new Tarantool instance. No special preparation, conversion or unpacking is needed. Issue `1916 <https://github.com/tarantool/tarantool/issues/1916>`_."
msgstr "(Memtx+Vinyl) внедрен низкоуровневый API для Lua в целях создания согласованных резервных копий данных Memtx + Vinyl. Новая функциональность обеспечиваетсоздание резервных копий всех спейсов с помощью функций ``box.backup.start()/stop()``. ``box.backup.start()`` останавливает сбор мусора и возвращает список файлов для копирования. Затем эти файлы можно скопировать с помощью любого стороннего средства, например, cp, ln, tar, rsync и т.д. ``box.backup.stop()`` возобновляет фоновый процесс сборки мусора. Чтобы немедленно восстановить данные, скопируйте созданные резервные копии в новую директорию, а затем запустите новый экземпляр Tarantool'а. Нет необходимости в дополнительной подготовке, преобразовании или распаковывании. Проблема `1916 <https://github.com/tarantool/tarantool/issues/1916>`_."

#: ../doc/1.7/whats_new.rst:403
msgid "(Vinyl) added statistics for background workers to ``box.info.vinyl()``. Issue `2005 <https://github.com/tarantool/tarantool/issues/2005>`_."
msgstr "(Vinyl) добавлена статистика для фоновых рабочих процессов в ``box.info.vinyl()``. Проблема `2005 <https://github.com/tarantool/tarantool/issues/2005>`_."

#: ../doc/1.7/whats_new.rst:405
msgid "(Memtx+Vinyl) reduced the memory footprint for indexes which keys are sequential and start from the first field. This optimization was necessary for secondary keys in Vinyl, but we optimized Memtx as well. Issue `2046 <https://github.com/tarantool/tarantool/issues/2046>`_."
msgstr "(Memtx+Vinyl) уменьшен объем необходимой памяти для индексов с последовательными ключами, которые начинаются с первого поля. Такая оптимизация была необходима для вторичных ключей в Vinyl'е, но мы также оптимизировали Memtx. Проблема `2046 <https://github.com/tarantool/tarantool/issues/2046>`_."

#: ../doc/1.7/whats_new.rst:409
msgid "LuaJIT was rebased on the latest 2.1.0b3 with out patches:"
msgstr "LuaJIT получил все изменения с последней версии 2.1.0b3 с нашими патчами:"

#: ../doc/1.7/whats_new.rst:411
msgid "Added JIT compiler backend for ARM64"
msgstr "Добавлен бэкенд для JIT-компилятора для архитектуры ARM64"

#: ../doc/1.7/whats_new.rst:412
msgid "Added JIT compiler backend and interpreter for MIPS64"
msgstr "Добавлен бэкенд и интерпретатор для JIT-компилятора для архитектуры MIPS64"

#: ../doc/1.7/whats_new.rst:413
msgid "Added some more Lua 5.2 and Lua 5.3 extensions"
msgstr "Добавлены некоторые расширения для Lua 5.2 и Lua 5.3"

#: ../doc/1.7/whats_new.rst:414
msgid "Fixed several bugs"
msgstr "Исправление нескольких ошибок"

#: ../doc/1.7/whats_new.rst:415
msgid "Removed Lua 5.0 legacy (see incompatible changes above)."
msgstr "Удалены устаревшие функции Lua 5.0 (см. несовместимые изменения выше)."

#: ../doc/1.7/whats_new.rst:419
msgid "Enabled a new smart string hashing algorithm in LuaJIT to avoid significant slowdown when a lot of collisions are generated. Contributed by Yury Sokolov (@funny-falcon) and Nick Zavaritsky (@mejedi). See https://github.com/tarantool/luajit/pull/2."
msgstr "Запущен новый умный алгоритм хеширования строк в LuaJIT, чтобы избежать замедления работы в случае множества столкновений. Разработали Юрий Соколов (@funny-falcon) и Ник Заварицкий (@mejedi). См. https://github.com/tarantool/luajit/pull/2."

#: ../doc/1.7/whats_new.rst:423
msgid "``box.snapshot()`` now updates mtime of a snapshot file if there were no changes to the database since the last snapshot. Issue `2045 <https://github.com/tarantool/tarantl/issues/2045>`_."
msgstr "``box.snapshot()`` теперь обновляет время mtime в файле снимка, если не было изменений в базе данных с момента последнего снимка. Проблема `2045 <https://github.com/tarantool/tarantl/issues/2045>`_."

#: ../doc/1.7/whats_new.rst:426
msgid "Implemented ``space:bsize()`` to return the memory size utilized by all tuples of the space. Contributed by Roman Tokarev (@rtokarev). Issue `2043 <https://github.com/tarantool/tarantool/issues/2043>`_."
msgstr "Внедрена функция ``space:bsize()`` для возврата объема памяти, занятого всеми кортежами спейса. Разработал Роман Токарев (@rtokarev). Проблема `2043 <https://github.com/tarantool/tarantool/issues/2043>`_."

#: ../doc/1.7/whats_new.rst:430
msgid "Exported new Lua/C functions to public API:"
msgstr "Новые функци Lua/C вынесены в общедоступный API:"

#: ../doc/1.7/whats_new.rst:432
msgid "``luaT_pushtuple``, ``luaT_istuple`` (issue `1878 <https://github.com/tarantool/tarantool/issues/1878>`_)"
msgstr "``luaT_pushtuple``, ``luaT_istuple`` (проблема `1878 <https://github.com/tarantool/tarantool/issues/1878>`_)"

#: ../doc/1.7/whats_new.rst:434
msgid "``luaT_error``, ``luaT_call``, ``luaT_cpcall`` (issue `2291 <https://github.com/tarantool/tarantool/issues/2291>`_)"
msgstr "``luaT_error``, ``luaT_call``, ``luaT_cpcall`` (проблема `2291 <https://github.com/tarantool/tarantool/issues/2291>`_)"

#: ../doc/1.7/whats_new.rst:436
msgid "``luaT_state`` (issue `2416 <https://github.com/tarantool/tarantool/issues/2416>`_)"
msgstr "``luaT_state`` (проблема `2416 <https://github.com/tarantool/tarantool/issues/2416>`_)"

#: ../doc/1.7/whats_new.rst:439
msgid "Exported new Box/C functions to public API: ``box_key_def``, ``box_tuple_format``, ``tuple_compare()``, ``tuple_compare_with_key()``. Issue `2225 <https://github.com/tarantool/tarantool/issues/2225>`_."
msgstr "Новые функции Box/C вынесены в общедоступный API: ``box_key_def``, ``box_tuple_format``, ``tuple_compare()``, ``tuple_compare_with_key()``. Проблема `2225 <https://github.com/tarantool/tarantool/issues/2225>`_."

#: ../doc/1.7/whats_new.rst:442
msgid "xlogs now can be rotated based on size (``wal_max_size``) as well as the number of written rows (``wal_max_rows``). Issue `173 <https://github.com/tarantool/tarantool/issues/173>`_."
msgstr "Можно осуществлять ротацию xlog-файлов на основе размера (``wal_max_size``), а также количества записанных строк (``wal_max_rows``). Проблема `173 <https://github.com/tarantool/tarantool/issues/173>`_."

#: ../doc/1.7/whats_new.rst:445
msgid "Added ``string.split()``, ``string.startswith()``, ``string.endswith()``, ``string.ljust()``, ``string.rjust()``, ``string.center()`` API. Issues `2211 <https://github.com/tarantool/tarantool/issues/2211>`_, `2214 <https://github.com/tarantool/tarantool/issues/2214>`_, `2415 <https://github.com/tarantool/tarantool/issues/2415>`_."
msgstr "Добавлены следующие API: ``string.split()``, ``string.startswith()``, ``string.endswith()``, ``string.ljust()``, ``string.rjust()``, ``string.center()``. Проблемы `2211 <https://github.com/tarantool/tarantool/issues/2211>`_, `2214 <https://github.com/tarantool/tarantool/issues/2214>`_, `2415 <https://github.com/tarantool/tarantool/issues/2415>`_."

#: ../doc/1.7/whats_new.rst:450
msgid "Added ``table.copy()`` and ``table.deepcopy()`` functions. Issue `2212 <https://github.com/tarantool/tarantool/issues/2412>`_."
msgstr "Добавлены функции ``table.copy()`` и ``table.deepcopy()``. Проблема `2212 <https://github.com/tarantool/tarantool/issues/2412>`_."

#: ../doc/1.7/whats_new.rst:452
msgid "Added ``pwd`` module to work with UNIX users and groups. Issue `2213 <https://github.com/tarantool/tarantool/issues/2213>`_."
msgstr "Добавлен модуль ``pwd`` для работы с пользователями и группами в UNIX. Проблема `2213 <https://github.com/tarantool/tarantool/issues/2213>`_."

#: ../doc/1.7/whats_new.rst:454
msgid "Removed noisy \"client unix/: connected\" messages from logs. Use ``box.session.on_connect()``/``on_disconnect()`` triggers instead."
msgstr "Удалены сообщения  \"client unix/: connected\" из журналов. Используйте вместо них триггеры ``box.session.on_connect()``/``on_disconnect()`` (на подключение / отключение)."

#: ../doc/1.7/whats_new.rst:457
msgid "``box.session.on_connect()``/``on_disconnect()``/``on_auth()`` triggers now also fired for admin console connections."
msgstr "Триггеры ``box.session.on_connect()``/``on_disconnect()``/``on_auth()`` также срабатывают для подключений административной консоли."

#: ../doc/1.7/whats_new.rst:460
msgid "Issue `1938 <https://github.com/tarantool/t`arantool/issues/1938>`_."
msgstr "Проблема `1938 <https://github.com/tarantool/t`arantool/issues/1938>`_."

#: ../doc/1.7/whats_new.rst:462
msgid "tarantoolctl: ``eval``, ``enter``, ``connect`` commands now support UNIX pipes. Issue `672 <https://github.com/tarantool/tarantool/issues/672>`_."
msgstr "tarantoolctl: следующие команды: ``eval``, ``enter``, ``connect`` — теперь поддерживают конвейеры UNIX. Проблема `672 <https://github.com/tarantool/tarantool/issues/672>`_."

#: ../doc/1.7/whats_new.rst:464
msgid "tarantoolctl: improved error messages and added a new man page. Issue `1488 <https://github.com/tarantool/tarantool/issues/1488>`_."
msgstr "tarantoolctl: более точные сообщения об ошибке; добавлена новая страница справочника. Проблема `1488 <https://github.com/tarantool/tarantool/issues/1488>`_."

#: ../doc/1.7/whats_new.rst:466
msgid "tarantoolctl: added filter by ``replica_id`` to ``cat`` and ``play`` commands. Issue `2301 <https://github.com/tarantool/tarantool/issues/2301>`_."
msgstr "tarantoolctl: добавлен фильтр по ``replica_id`` для команд ``cat`` и ``play``. Проблема `2301 <https://github.com/tarantool/tarantool/issues/2301>`_."

#: ../doc/1.7/whats_new.rst:468
msgid "tarantoolctl: ``start``, ``stop`` and ``restart`` commands now redirect to ``systemctl start/stop/restart`` when systemd is enabled. Issue `2254 <https://github.com/tarantool/tarantool/issues/2254>`_."
msgstr "tarantoolctl: Команды ``start``, ``stop`` и ``restart`` перенаправляют на ``systemctl start/stop/restart``, когда запущен systemd. Проблема `2254 <https://github.com/tarantool/tarantool/issues/2254>`_."

#: ../doc/1.7/whats_new.rst:471
msgid "net.box: added ``buffer = <buffer>`` per-request option to store raw MessagePack responses into a C buffer. Issue `2195 <https://github.com/tarantool/tarantool/issues/2195>`_."
msgstr "net.box: по запросу добавлена опция ``buffer = <buffer>`` для хранения исходных ответов MessagePack в буфер C. Проблема `2195 <https://github.com/tarantool/tarantool/issues/2195>`_."

#: ../doc/1.7/whats_new.rst:474
msgid "net.box: added ``connect_timeout`` option. Issue `2054 <https://github.com/tarantool/tarantool/issues/2054>`_."
msgstr "net.box: добавлена опция ``connect_timeout``. Проблема `2054 <https://github.com/tarantool/tarantool/issues/2054>`_."

#: ../doc/1.7/whats_new.rst:476
msgid "net.box: added ``on_schema_reload()`` hook. Issue `2021 <https://github.com/tarantool/tarantool/issues/2021>`_."
msgstr "net.box: добавлена привязка ``on_schema_reload()``. Проблема `2021 <https://github.com/tarantool/tarantool/issues/2021>`_."

#: ../doc/1.7/whats_new.rst:478
msgid "net.box: exposed ``conn.schema_version`` and ``space.connection`` to API. Issue `2412 <https://github.com/tarantool/tarantool/issues/2412>`_."
msgstr "net.box: ``conn.schema_version`` и ``space.connection`` дополнены API. Проблема `2412 <https://github.com/tarantool/tarantool/issues/2412>`_."

#: ../doc/1.7/whats_new.rst:480
msgid "log: ``debug()``/``info()``/``warn()``/``error()`` now doesn't fail on formatting errors. Issue `889 <https://github.com/tarantool/tarantool/issues/889>`_."
msgstr "log: ``debug()``/``info()``/``warn()``/``error()`` не выдают сбой при ошибках форматирования. Проблема `889 <https://github.com/tarantool/tarantool/issues/889>`_."

#: ../doc/1.7/whats_new.rst:483
msgid "crypto: added HMAC support. Contributed by Andrey Kulikov (@amdei). Issue `725 <https://github.com/tarantool/tarantool/issues/725>`_."
msgstr "crypto: добавлена поддержка HMAC. Разработал Андрей Куликов (@amdei). Проблема `725 <https://github.com/tarantool/tarantool/issues/725>`_."

#: ../doc/1.7/whats_new.rst:489
msgid "**Release 1.7.3**"
msgstr "**Версия 1.7.3**"

#: ../doc/1.7/whats_new.rst:491
msgid "Release type: beta. Release date: 2016-12-24. Release tag: Tag: 1.7.3-0-gf0c92aa."
msgstr "Тип версии: бета. Дата выхода: 2016-12-24.  Тег версии: 1.7.3-0-gf0c92aa."

#: ../doc/1.7/whats_new.rst:493
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.7.3"
msgstr "Объявление о выходе: https://github.com/tarantool/tarantool/releases/tag/1.7.3"

#: ../doc/1.7/whats_new.rst:495
msgid "This is the second beta release in the 1.7 series."
msgstr "Данная сборка представляет собой вторую бета-версию в серии 1.7."

#: ../doc/1.7/whats_new.rst:499
msgid "Broken ``coredump()`` Lua function was removed. Use ``gdb -batch -ex \"generate-core-file\" -p $PID`` instead. Issue `1886 <https://github.com/tarantool/tarantool/issues/1886>`_."
msgstr "Удалена поврежденная Lua-функция ``coredump()``. Используйте вместо нее ``gdb -batch -ex \"generate-core-file\" -p $PID``. Проблема `1886 <https://github.com/tarantool/tarantool/issues/1886>`_."

#: ../doc/1.7/whats_new.rst:502
msgid "Vinyl disk layout was changed since 1.7.2 to add ZStandard compression and improve the performance of secondary keys. Use the replication mechanism to upgrade from 1.7.2 beta. Issue `1656 <https://github.com/tarantool/tarantool/issues/1656>`_."
msgstr "Структура диска Vinyl изменилась с версии 1.7.2: добавлен механизм компрессии ZStandard и улучшена производительность вторичных ключей. Используйте механизм репликации для обновления с бета-версии 1.7.2. Проблема `1656 <https://github.com/tarantool/tarantool/issues/1656>`_."

#: ../doc/1.7/whats_new.rst:509
msgid "Substantial progress on stabilizing the Vinyl storage engine:"
msgstr "Значительный прогресс в стабилизации движка базы данных Vinyl:"

#: ../doc/1.7/whats_new.rst:511
msgid "Fix most known crashes and bugs with bad results."
msgstr "Исправлены большинство известных отказов системы и ошибок, выдающих плохие результаты."

#: ../doc/1.7/whats_new.rst:512
msgid "Switch to use XLOG/SNAP format for all data files."
msgstr "Замена формата всех файлов с данными на XLOG/SNAP."

#: ../doc/1.7/whats_new.rst:513
msgid "Enable ZStandard compression for all data files."
msgstr "Использование механизма компрессии ZStandard для всех файлов с данными."

#: ../doc/1.7/whats_new.rst:514
msgid "Squash UPSERT operations on the fly and merge hot keys using a background fiber."
msgstr "Сжатие операций UPSERT на лету и объединение горячих клавиш с помощью фонового файбера."

#: ../doc/1.7/whats_new.rst:516
msgid "Significantly improve the performance of index:pairs() and index:count()."
msgstr "Значительное улучшение производительности index:pairs() и index:count()."

#: ../doc/1.7/whats_new.rst:517
msgid "Remove unnecessary conflicts from transactions."
msgstr "Удаление ненужных конфликтов из транзакций."

#: ../doc/1.7/whats_new.rst:518
msgid "In-memory level was mostly replaced by memtx data structures."
msgstr "Уровень In-memory по большей части заменен структурами данных  memtx."

#: ../doc/1.7/whats_new.rst:519
msgid "Specialized allocators are used in most places."
msgstr "В большинстве случаев используются специализированные распределители ресурсов."

#: ../doc/1.7/whats_new.rst:521
msgid "We're still actively working on Vinyl and plan to add multi-level compaction and improve the performance of secondary keys in 1.7.4. This implies a data format change."
msgstr "Мы все еще активно работаем над Vinyl'ом и планируем добавить многоуровневое слияние и улучшить производительность в работе со вторичными ключами в версии 1.7.4. Это подразумевает изменение формата данных."

#: ../doc/1.7/whats_new.rst:524
msgid "Support for DML requests for space:on_replace() triggers. Issue `587 <https://github.com/tarantool/tarantool/issues/587>`_."
msgstr "Поддержка DML-запросов для триггеров space:on_replace(). Проблема `587 <https://github.com/tarantool/tarantool/issues/587>`_."

#: ../doc/1.7/whats_new.rst:526
msgid "UPSERT can be used with the empty list of operations. Issue `1854 <https://github.com/tarantool/tarantool/issues/1854>`_."
msgstr "UPSERT можно использовать с пустым списком операций. Проблема `1854 <https://github.com/tarantool/tarantool/issues/1854>`_."

#: ../doc/1.7/whats_new.rst:528
msgid "Lua functions to manipulate environment variables. Issue `1718 <https://github.com/tarantool/tarantool/issues/1718>`_."
msgstr "Lua-функции будут управлять переменными окружения. Проблема `1718 <https://github.com/tarantool/tarantool/issues/1718>`_."

#: ../doc/1.7/whats_new.rst:530
msgid "Lua library to read Tarantool snapshots and xlogs. Issue `1782 <https://github.com/tarantool/tarantool/issues/1782>`_."
msgstr "Lua-библиотека будет считывать снимки Tarantool'а и xlog-файлы. Проблема `1782 <https://github.com/tarantool/tarantool/issues/1782>`_."

#: ../doc/1.7/whats_new.rst:532
msgid "New ``play`` and ``cat`` commands in ``tarantoolctl``. Issue `1861 <https://github.com/tarantool/tarantool/issues/1861>`_."
msgstr "Новые команды в ``tarantoolctl``: ``play`` и``cat``. Проблема `1861 <https://github.com/tarantool/tarantool/issues/1861>`_."

#: ../doc/1.7/whats_new.rst:534
msgid "Improve support for the large number of active network clients. Issue#5#1892."
msgstr "Улучшена поддержка большого количества активных сетевых клиентов. Проблема #5#1892."

#: ../doc/1.7/whats_new.rst:536
msgid "Support for ``space:pairs(key, iterator-type)`` syntax. Issue `1875 <https://github.com/tarantool/tarantool/issues/1875>`_."
msgstr "Поддержка синтаксиса ``space:pairs(key, iterator-type)``. Проблема `1875 <https://github.com/tarantool/tarantool/issues/1875>`_."

#: ../doc/1.7/whats_new.rst:538
msgid "Automatic cluster bootstrap now also works without authorization. Issue `1589 <https://github.com/tarantool/tarantool/issues/1589>`_."
msgstr "Автоматическая настройка кластера будет работать и без авторизации. Проблема `1589 <https://github.com/tarantool/tarantool/issues/1589>`_."

#: ../doc/1.7/whats_new.rst:540
msgid "Replication retries to connect to master indefinitely. Issue `1511 <https://github.com/tarantool/tarantool/issues/1511>`_."
msgstr "При репликации попытки повторного подключения к мастеру бесконечны. Проблема `1511 <https://github.com/tarantool/tarantool/issues/1511>`_."

#: ../doc/1.7/whats_new.rst:542
msgid "Temporary spaces now work with ``box.cfg { read_only = true }``. Issue `1378 <https://github.com/tarantool/tarantool/issues/1378>`_."
msgstr "Временные спейсы будут работать с ``box.cfg { read_only = true }``. Проблема `1378 <https://github.com/tarantool/tarantool/issues/1378>`_."

#: ../doc/1.7/whats_new.rst:544
msgid "The maximum length of space names increased to 64 bytes (was 32). Issue `2008 <https://github.com/tarantool/tarantool/issues/2008>`_."
msgstr "Максимальная длина имени спейса увеличена до 64 байтов (ранее 32). Проблема `2008 <https://github.com/tarantool/tarantool/issues/2008>`_."

#: ../doc/1.7/whats_new.rst:549
msgid "**Release 1.7.2**"
msgstr "**Версия 1.7.2**"

#: ../doc/1.7/whats_new.rst:551
msgid "Release type: beta. Release date: 2016-09-29. Release tag: Tag: `1.7.2-1-g92ed6c4`."
msgstr "Тип версии: бета. Дата выхода: 2016-09-29.  Тег версии: `1.7.2-1-g92ed6c4`."

#: ../doc/1.7/whats_new.rst:553
msgid "Announcement: https://groups.google.com/forum/#!topic/tarantool-ru/qUYUesEhRQg"
msgstr "Объявление о выходе: https://groups.google.com/forum/#!topic/tarantool-ru/qUYUesEhRQg"

#: ../doc/1.7/whats_new.rst:555
msgid "This is a release in the 1.7 series."
msgstr "Данная сборка представляет собой версию в серии 1.7."

#: ../doc/1.7/whats_new.rst:559
msgid "A new binary protocol command for CALL, which no more restricts a function to returning an array of tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility. It will be removed in the next major release. All programming language drivers will be gradually changed to use the new CALL. Issue `1296 <https://github.com/tarantool/tarantool/issues/1296>`_."
msgstr "Команда нового бинарного протокола для вызова CALL больше не ограничивает функцию в возврате массива кортежей и позволяет возвращать произвольный результат в формате MsgPack/JSON, включая scalar (скалярные значения), nil (нулевые значения) и void (пусто). Старый метод CALL оставлен нетронутым для обратной совместимости. В следующей основной версии он будет удален. Все драйверы для языков программирования будут постепенно переведены на использование нового метода CALL. Проблема `1296 <https://github.com/tarantool/tarantool/issues/1296>`_."

#: ../doc/1.7/whats_new.rst:569
msgid "Vinyl storage engine finally reached the beta stage. This release fixes more than 90 bugs in Vinyl, in particular, removing unpredictable latency spikes, all known crashes and bad/lost result bugs."
msgstr "Разработка движка базы данных Vinyl, наконец, перешла в бета-стадию. В данной версии исправлены более 90 ошибок в Vinyl'е, в частности, удаление непредсказуемых скачков задержки, все известные отказы системы и ошибки, выдающие плохие результаты или их отсутствие."

#: ../doc/1.7/whats_new.rst:573
msgid "new cooperative multitasking based architecture to eliminate latency spikes,"
msgstr "новая архитектура на основе кооперативной многозадачности для устранения скачков задержки,"

#: ../doc/1.7/whats_new.rst:574
msgid "support for non-sequential multi-part keys,"
msgstr "поддержка непоследовательных составных ключей,"

#: ../doc/1.7/whats_new.rst:575
msgid "support for secondary keys,"
msgstr "поддержка вторичных ключей,"

#: ../doc/1.7/whats_new.rst:576
msgid "support for ``auto_increment()``,"
msgstr "поддержка ``auto_increment()``,"

#: ../doc/1.7/whats_new.rst:577
msgid "number, integer, scalar field types in indexes,"
msgstr "типы полей в индексах: number (число), integer (целое число), scalar (скаляр),"

#: ../doc/1.7/whats_new.rst:578
msgid "INSERT, REPLACE and UPDATE return new tuple, like in memtx."
msgstr "операции INSERT, REPLACE и UPDATE возвращают новый кортеж, как в memtx'е."

#: ../doc/1.7/whats_new.rst:580
msgid "We're still actively working on Vinyl and plan to add ``zstd`` compression and a new memory allocator for Vinyl in-memory index in 1.7.3. This implies a data format change which we plan to implement before 1.7 becomes generally available."
msgstr "Мы все еще активно работаем над Vinyl'ом и планируем добавить механизм компрессии ``zstd`` и новый распределитель ресурсов для Vinyl'а в версии 1.7.3. Это подразумевает изменение формата данных, который планируется внедрить до того, как версия 1.7 станет общедоступной."

#: ../doc/1.7/whats_new.rst:584
msgid "Tab-based autocompletion in the interactive console, ``require('console').connect()``, ``tarantoolctl enter`` and ``tarantoolctl connect`` commands. Issues `86 <https://github.com/tarantool/tarantool/issues/86>`_ and `1790 <https://github.com/tarantool/tarantool/issues/1790>`_. Use the TAB key to auto complete the names of Lua variables, functions and meta-methods."
msgstr "Автозаполнение по Tab в интерактивной консоли, команды `require('console').connect()``, ``tarantoolctl enter`` и ``tarantoolctl connect``. Проблемы `86 <https://github.com/tarantool/tarantool/issues/86>`_ и `1790 <https://github.com/tarantool/tarantool/issues/1790>`_. Используйте клавишу TAB для автозаполнения имен переменных, функций и метаметодов в Lua."

#: ../doc/1.7/whats_new.rst:591
msgid "A new implementation of ``net.box`` improving performance and solving problems with the garbage collection of dead connections. Issues `799 <https://github.com/tarantool/tarantool/issues/799>`_, `800 <https://github.com/tarantool/tarantool/issues/800>`_, `1138 <https://github.com/tarantool/tarantool/issues/1138>`_ and `1750 <https://github.com/tarantool/tarantool/issues/1750>`_."
msgstr "Новая реализация ``net.box`` с улучшенной производительностью и решением проблем сборки мусора с недоступных соединений. Проблемы `799 <https://github.com/tarantool/tarantool/issues/799>`_, `800 <https://github.com/tarantool/tarantool/issues/800>`_, `1138 <https://github.com/tarantool/tarantool/issues/1138>`_ и `1750 <https://github.com/tarantool/tarantool/issues/1750>`_."

#: ../doc/1.7/whats_new.rst:597
msgid "memtx snapshots and xlog files are now compressed on the fly using the fast `ZStandard <https://github.com/facebook/zstd>`_ compression algorithm. Compression options are configured automatically to get an optimal trade-off between CPU utilization and disk throughput."
msgstr "Появилась компрессия снимков memtx и xlog-файлов на лету с использованием быстрого алгоритма компрессии `ZStandard <https://github.com/facebook/zstd>`_. Компрессия настраивается автоматически для получения оптимального соотношения между использованием ЦП и пропускной способностью диска."

#: ../doc/1.7/whats_new.rst:601
msgid "``fiber.cond()`` - a new synchronization mechanism for cooperative multitasking. Issue `1731 <https://github.com/tarantool/tarantool/issues/1731>`_."
msgstr "``fiber.cond()`` — новый механизм синхронизации для кооперативной многозадачности. Проблема `1731 <https://github.com/tarantool/tarantool/issues/1731>`_."

#: ../doc/1.7/whats_new.rst:603
msgid "Tarantool can now be installed using universal Snappy packages (http://snapcraft.io/) with ``snap install tarantool --channel=beta``."
msgstr "Tarantool теперь можно устанавливать из универсальных Snappy-пакетов (http://snapcraft.io/) с помощью команды ``snap install tarantool --channel=beta``."

#: ../doc/1.7/whats_new.rst:606 ../doc/1.7/whats_new.rst:768
#: ../doc/1.7/whats_new.rst:869
msgid "New rocks and packages:"
msgstr "Новые модули и пакеты:"

#: ../doc/1.7/whats_new.rst:608 ../doc/1.7/whats_new.rst:770
msgid "`curl <https://github.com/tarantool/tarantool-curl>`_ - non-blocking bindings for libcurl"
msgstr "`curl <https://github.com/tarantool/tarantool-curl>`_ - неблокирующие привязки для libcurl"

#: ../doc/1.7/whats_new.rst:609 ../doc/1.7/whats_new.rst:771
msgid "`prometheus <https://github.com/tarantool/prometheus>`_ - Prometheus metric collector for Tarantool"
msgstr "`prometheus <https://github.com/tarantool/prometheus>`_ - сборщик метрик Prometheus для Tarantool'а"

#: ../doc/1.7/whats_new.rst:610
msgid "`gis <https://github.com/tarantool/gis>`_ - a full-featured geospatial extension for Tarantool"
msgstr "`gis <https://github.com/tarantool/gis>`_ - полнофункциональное геопространственное расширение для Tarantool'а"

#: ../doc/1.7/whats_new.rst:611
msgid "`mqtt <https://github.com/tarantool/mqtt>`_ - an MQTT protocol client for Tarantool"
msgstr "`mqtt <https://github.com/tarantool/mqtt>`_ - клиент MQTT-протокола для Tarantool'а"

#: ../doc/1.7/whats_new.rst:612 ../doc/1.7/whats_new.rst:774
msgid "`luaossl <https://github.com/tarantool/luaossl>`_ - the most comprehensive OpenSSL module in the Lua universe"
msgstr "`luaossl <https://github.com/tarantool/luaossl>`_ -  самый полноценный OpenSSL-модуль во вселенной Lua"

#: ../doc/1.7/whats_new.rst:614
msgid "Deprecated, removed features and minor incompatibilities:"
msgstr "Устаревшие, удаленные и несовместимые функции:"

#: ../doc/1.7/whats_new.rst:616
msgid "``num`` and ``str`` fields type names are deprecated, use ``unsigned`` and ``string`` instead. Issue `1534 <https://github.com/tarantool/tarantool/issues/1534>`_."
msgstr "Имена типов полей ``num`` и ``str`` объявлены устаревшими, используйте вместо них ``unsigned`` и ``string``. Проблема `1534 <https://github.com/tarantool/tarantool/issues/1534>`_."

#: ../doc/1.7/whats_new.rst:619
msgid "``space:inc()`` and ``space:dec()`` were removed (deprecated in 1.6.x) Issue `1289 <https://github.com/tarantool/tarantool/issues/1289>`_."
msgstr "Удалены ``space:inc()`` и ``space:dec()`` (объявлены устаревшими в версии 1.6.x). Проблема `1289 <https://github.com/tarantool/tarantool/issues/1289>`_."

#: ../doc/1.7/whats_new.rst:621
msgid "``fiber:cancel()`` is now asynchronous and doesn't wait for the fiber to end. Issue `1732 <https://github.com/tarantool/tarantool/issues/1732>`_."
msgstr "Функция ``fiber:cancel()`` теперь является асинхронной и не ждет завершения работы файбера. Проблема `1732 <https://github.com/tarantool/tarantool/issues/1732>`_."

#: ../doc/1.7/whats_new.rst:623
msgid "Implicit error-prone ``tostring()`` was removed from ``digest`` API. Issue `1591 <https://github.com/tarantool/tarantool/issues/1591>`_."
msgstr "Склонная к ошибкам функция ``tostring()`` была удалена из API ``digest``. Проблема `1591 <https://github.com/tarantool/tarantool/issues/1591>`_."

#: ../doc/1.7/whats_new.rst:625 ../doc/1.7/whats_new.rst:741
msgid "Support for SHA-0 (``digest.sha()``) was removed due to OpenSSL upgrade."
msgstr "Поддержка SHA-0 (``digest.sha()``) прекращается по причине обновления OpenSSL."

#: ../doc/1.7/whats_new.rst:626
msgid "``net.box`` now uses one-based indexes for ``space.name.index[x].parts``. Issue `1729 <https://github.com/tarantool/tarantool/issues/1729>`_."
msgstr "``net.box`` будет использовать индексы, начинающиеся с 1, для ``space.name.index[x].parts``. Проблемы `1729 <https://github.com/tarantool/tarantool/issues/1729>`_."

#: ../doc/1.7/whats_new.rst:628
msgid "Tarantool binary now dynamically links with ``libssl.so`` during compile time instead of loading it at the run time."
msgstr "Бинарный файл Tarantool'а будет динамически связываться с ``libssl.so`` во время компиляции вместо загрузки во время выполнения."

#: ../doc/1.7/whats_new.rst:630
msgid "Debian and Ubuntu packages switched to use native ``systemd`` configuration alongside with old-fashioned ``sysvinit`` scripts."
msgstr "Пакеты Debian и Ubuntu будут использовать встроенную конфигурацию ``systemd`` вместе с вышедшими из употребления скриптами ``sysvinit``."

#: ../doc/1.7/whats_new.rst:633
msgid "``systemd`` provides its own facilities for multi-instance management. To upgrade, perform the following steps:"
msgstr "В ``systemd`` появляется возможность управления несколькими экземплярами. Чтобы обновить, выполните следующие действия:"

#: ../doc/1.7/whats_new.rst:636
msgid "Install new 1.7.2 packages."
msgstr "Установите новые пакеты версии 1.7.2."

#: ../doc/1.7/whats_new.rst:637
msgid "Ensure that ``INSTANCENAME.lua`` file is present in ``/etc/tarantool/instace.enabled``."
msgstr "Убедитесь в наличии файла ``ИМЯ_ЭКЗЕМПЛЯРА.lua`` в директории ``/etc/tarantool/instace.enabled``."

#: ../doc/1.7/whats_new.rst:638 ../doc/1.7/whats_new.rst:790
msgid "Stop INSTANCENAME using ``tarantoolctl stop INSTANCENAME``."
msgstr "Остановите ЭКЗЕМПЛЯР с помощью ``tarantoolctl stop ИМЯ_ЭКЗЕМПЛЯРА``."

#: ../doc/1.7/whats_new.rst:639 ../doc/1.7/whats_new.rst:791
msgid "Start INSTANCENAME using ``systemctl start tarantool@INSTANCENAME``."
msgstr "Запустите ЭКЗЕМПЛЯР с помощью ``systemctl start tarantool@ИМЯ_ЭКЗЕМПЛЯРА``."

#: ../doc/1.7/whats_new.rst:640 ../doc/1.7/whats_new.rst:792
msgid "Enable INSTANCENAME during system boot using ``systemctl enable trantool@INTANCENAME``."
msgstr "Включите ЭКЗЕМПЛЯР во время загрузки системы с помощью ``systemctl enable tarantool@ИМЯ_ЭКЗЕМПЛЯРА``."

#: ../doc/1.7/whats_new.rst:641
msgid "Say ``systemctl disable tarantool; update-rc.d tarantool remove`` to disable sysvinit-compatible wrappers."
msgstr "Введите команду ``systemctl disable tarantool; update-rc.d tarantool remove``, чтобы отключить надстройки, совместимые с sysvinit."

#: ../doc/1.7/whats_new.rst:644
msgid "Refer to issue `1291 <https://github.com/tarantool/tarantool/issues/1291>`_ comment and :ref:`the administration chapter <admin>` for additional information."
msgstr "Для получения дополнительной информации см. комментарии к проблеме `1291 <https://github.com/tarantool/tarantool/issues/1291>`_ и главу :ref:`по администрированию серверной части <admin>`."

#: ../doc/1.7/whats_new.rst:647
msgid "Debian and Ubuntu packages start a ready-to-use ``example.lua`` instance on a clean installation of the package. The default instance grants universe permissions for ``guest`` user and listens on \"locahost:3313\"."
msgstr "Пакеты для Debian и Ubuntu запускают готовый к использованию экземпляр ``example.lua`` при чистой установке пакета. В экземпляре, используемом по умолчанию, предоставлены права на universe для пользователя ``guest`` и настроено прослушивание по \"locahost:3313\"."

#: ../doc/1.7/whats_new.rst:651 ../doc/1.7/whats_new.rst:744
msgid "Fedora 22 packages were deprecated (EOL)."
msgstr "Пакеты для Fedora 22 объявлены устаревшими (прекращение поддержки)."

#: ../doc/1.7/whats_new.rst:655
msgid "**Release 1.7.1**"
msgstr "**Версия 1.7.1**"

#: ../doc/1.7/whats_new.rst:657
msgid "Release type: alpha. Release date: 2016-07-11."
msgstr "Тип версии: альфа. Дата выхода: 2016-07-11."

#: ../doc/1.7/whats_new.rst:659
msgid "Announcement: https://groups.google.com/forum/#!topic/tarantool/KGYj3VKJKb8"
msgstr "Объявление о выходе: https://groups.google.com/forum/#!topic/tarantool/KGYj3VKJKb8"

#: ../doc/1.7/whats_new.rst:661
msgid "This is the first alpha in the 1.7 series. The main feature of this release is a new storage engine, called \"vinyl\". Vinyl is a write optimized storage engine, allowing the amount of data stored exceed the amount of available RAM 10-100x times. Vinyl is a continuation of the Sophia engine from 1.6, and effectively a fork and a distant relative of Dmitry Simonenko's Sophia. Sophia is superseded and replaced by Vinyl. Internally it is organized as a log structured merge tree. However, it takes a serious effort to improve on the traditional deficiencies of log structured storage, such as poor read performance and unpredictable write latency. A single index is range partitioned among many LSM data structures, each having its own in-memory buffers of adjustable size. Range partitioning allows merges of LSM levels to be more granular, as well as to prioritize hot ranges over cold ones in access to resources, such as RAM and I/O. The merge scheduler is designed to minimize write latency while ensuring read performance stays within acceptable limits. Vinyl today only supports a primary key index. The index can consist of up to 256 parts, like in MemTX, up from 8 in Sophia. Partial key reads are supported. Support of non-sequential multi part keys, as well as secondary keys is on the short term todo. Our intent is to remove all limitations currently present in Vinyl, making it a first class citizen in Tarantool."
msgstr "Данная сборка представляет собой первую альфа-версию в серии 1.7. Основной функцией данной версии является новый движок базы данных под названием \"vinyl\". Vinyl представляет собой оптимизированный для записи движок базы данных, который позволяет сохранять объем сохраняемых данных, превышающий объем доступной памяти в 10-100 раз. Vinyl является продолжением движка Sophia из версии 1.6, а именно ответвлением и дальним родственником Sophia Дмитрия Симоненко. Новый Vinyl заменяет Sophia. Он реализован в виде журнально-структурированного дерева со слиянием (log-structured merge tree — LSM-tree). Однако усовершенствование таких традиционных недостатков журнально-структурированных хранилищ, как низкая производительность при чтении и непредсказуемая задержка во времени при записи, стоит больших усилий. Отдельный индекс секционирован по диапазонам между многими структурами данных LSM, в каждой из который находятся собственные буферы оперативной памяти регулируемого размера. Секционирование по диапазонам позволяет осуществить слияние LSM-уровней, чтобы добиться большей детализации, а также отдать приоритет горячим диапазонам по отношению к холодным в том, что касается доступа к ресурсам, таким как оперативная память и ввод-вывод. Планировщик слияний предназначен для сведения времени задержки записи к минимуму, а также для поддержания производительности при чтении в приемлемых пределах. На сегодняшний день Vinyl поддерживает только первичные индексы. Индекс может состоять из 256 частей, как в MemTX'е, по сравнению с 8 в Sophia. Поддерживает чтение по компонентам ключа. Вскоре ожидается поддержка непоследовательных составных ключей, а также вторичных ключей. Наше намерение заключается в том, чтобы убрать любые ограничения, которые есть сейчас в Vinyl'е, чтобы сделать его полноценным компонентом Tarantool'а."

#: ../doc/1.7/whats_new.rst:688
msgid "The disk-based storage engine, which was called ``sophia`` or ``phia`` in earlier versions, is superseded by the ``vinyl`` storage engine."
msgstr "Дисковый движок, который в более ранних версиях Tarantool'а назывался ``sophia`` или ``phia``, заменен новым движком под названием ``vinyl``."

#: ../doc/1.7/whats_new.rst:690
msgid "There are new types for indexed fields."
msgstr "Добавлены новые типы индексируемых полей."

#: ../doc/1.7/whats_new.rst:691
msgid "The LuaJIT version is updated."
msgstr "Обновлена версия LuaJIT."

#: ../doc/1.7/whats_new.rst:692
msgid "Automatic replica set bootstrap (for easier configuration of a new replica set) is supported."
msgstr "Поддерживается автоматическая настройка набора реплик, что существенно упрощает настройку нового набора реплик."

#: ../doc/1.7/whats_new.rst:694
msgid "The ``space_object:inc()`` function is removed."
msgstr "Функция ``space_object:inc()`` объявлена устаревшей."

#: ../doc/1.7/whats_new.rst:695
msgid "The ``space_object:dec()`` function is removed."
msgstr "Функция ``space_object:dec()`` объявлена устаревшей."

#: ../doc/1.7/whats_new.rst:696
msgid "The ``space_object:bsize()`` function is added."
msgstr "Добавлена функция ``space_object:bsize()``."

#: ../doc/1.7/whats_new.rst:697
msgid "The ``box.coredump()`` function is removed, for an alternative see :ref:`Core dumps <admin-core_dumps>`."
msgstr "Удалена функция ``box.coredump()``, аналог см. в главе :ref:`Создание дампов памяти <admin-core_dumps>`."

#: ../doc/1.7/whats_new.rst:699
msgid "The ``hot_standby`` configuration option is added."
msgstr "Добавлена опция настройки ``hot_standby`` (горячий резерв)."

#: ../doc/1.7/whats_new.rst:700
msgid "Configuration parameters revised or renamed:"
msgstr "Исправленные или переименованные конфигурационные параметры:"

#: ../doc/1.7/whats_new.rst:702
msgid "``slab_alloc_arena`` (in gigabytes) to ``memtx_memory`` (in bytes),"
msgstr "``slab_alloc_arena`` (в гигабайтах) в ``memtx_memory`` (в байтах),"

#: ../doc/1.7/whats_new.rst:703
msgid "``slab_alloc_minimal`` to ``memtx_min_tuple_size``,"
msgstr "``slab_alloc_minimal`` в ``memtx_min_tuple_size``,"

#: ../doc/1.7/whats_new.rst:704
msgid "``slab_alloc_maximal`` to ``memtx_max_tuple_size``,"
msgstr "``slab_alloc_maximal`` в ``memtx_max_tuple_size``,"

#: ../doc/1.7/whats_new.rst:705
msgid "``replication_source`` to ``replication``,"
msgstr "``replication_source`` в ``replication``,"

#: ../doc/1.7/whats_new.rst:706
msgid "``snap_dir`` to ``memtx_dir``,"
msgstr "``snap_dir`` в ``memtx_dir``,"

#: ../doc/1.7/whats_new.rst:707
msgid "``logger`` to ``log``,"
msgstr "``logger`` в ``log``,"

#: ../doc/1.7/whats_new.rst:708
msgid "``logger_nonblock`` to ``log_nonblock``,"
msgstr "``logger_nonblock`` в ``log_nonblock``,"

#: ../doc/1.7/whats_new.rst:709
msgid "``snapshot_count`` to ``checkpoint_count``,"
msgstr "``snapshot_count`` в ``checkpoint_count``,"

#: ../doc/1.7/whats_new.rst:710
msgid "``snapshot_period`` to ``checkpoint_interval``,"
msgstr "``snapshot_period`` в ``checkpoint_interval``,"

#: ../doc/1.7/whats_new.rst:711
msgid "``panic_on_wal_error`` and ``panic_on_snap_error`` united under ``force_recovery``."
msgstr "``panic_on_wal_error`` и ``panic_on_snap_error`` объединены в  ``force_recovery``."

#: ../doc/1.7/whats_new.rst:712
msgid "Until Tarantool 1.8, you can use :ref:`deprecated parameters <cfg_deprecated>` for both initial and runtime configuration, but Tarantool will display a warning. Also, you can specify both deprecated and up-to-date parameters, provided that their values are harmonized. If not, Tarantool will display an error."
msgstr "В версиях Tarantool'а до 1.8 можно использовать :ref:`устаревшие  параметры <cfg_deprecated>` как для начальной, так и для рабочей конфигурации, но в таком случае Tarantool выдаст предупреждение. Также можно указывать как устаревшие, так и новые параметры при условии, что их значения согласованы. В противном случае, Tarantool выдаст ошибку."

#: ../doc/1.7/whats_new.rst:716
msgid "Automatic replication cluster bootstrap; it's now much easier to configure a new replication cluster."
msgstr "У кластера репликации появилась возможность автоматической настройки, что существенно упрощает настройку нового кластера."

#: ../doc/1.7/whats_new.rst:718
msgid "New indexable data types: INTEGER and SCALAR."
msgstr "Новые индексируемые типы данных: INTEGER (целове число) и SCALAR (скаляр)."

#: ../doc/1.7/whats_new.rst:719
msgid "Code refactoring and performance improvements."
msgstr "Рефакторинг кода и улучшение производительности."

#: ../doc/1.7/whats_new.rst:720
msgid "Updated LuaJIT to 2.1-beta116."
msgstr "LuaJIT обновлен до версии 2.1-beta116."

#: ../doc/1.7/whats_new.rst:726
msgid "Version 1.6"
msgstr "Версия 1.6"

#: ../doc/1.7/whats_new.rst:730
msgid "**Release 1.6.9**"
msgstr "**Версия 1.6.9**"

#: ../doc/1.7/whats_new.rst:732
msgid "Release type: maintenance. Release date: 2016-09-27. Release tag: 1.6.9-4-gcc9ddd7."
msgstr "Тип версии: обновленная. Дата выхода: 2016-09-27. Тег версии: 1.6.9-4-gcc9ddd7."

#: ../doc/1.7/whats_new.rst:734
msgid "Since February 15, 2017, due to Tarantool issue#2040 `Remove sophia engine from 1.6 <https://github.com/tarantool/tarantool/issues/2040>`_ there no longer is a storage engine named `sophia`. It will be superseded in version 1.7 by the `vinyl` storage engine."
msgstr "С 15 февраля 2017 года вследствие проблемы № 2040 `Удалить движок sophia из версии 1.6 <https://github.com/tarantool/tarantool/issues/2040>`_, движок базы данных под названием `sophia` отсутствует. В версии 1.7 его заменит движок базы данных `vinyl`."

#: ../doc/1.7/whats_new.rst:742
msgid "Tarantool binary now dynamically links with libssl.so during compile time instead of loading it at the run time."
msgstr "Бинарный файл Tarantool'а будет динамически связываться с libssl.so во время компиляции вместо загрузки во время выполнения."

#: ../doc/1.7/whats_new.rst:748
msgid "Tab-based autocompletion in the interactive console. Issue `86 <https://github.com/tarantool/tarantool/issues/86>`_"
msgstr "Автозаполнение по Tab в интерактивной консоли. Проблема `86 <https://github.com/tarantool/tarantool/issues/86>`_"

#: ../doc/1.7/whats_new.rst:750
msgid "LUA_PATH and LUA_CPATH environment variables taken into account, like in PUC-RIO Lua. Issue `1428 <https://github.com/tarantool/tarantool/issues/1428>`_"
msgstr "Принимаются во внимание переменные окружения LUA_PATH и LUA_CPATH, как в PUC-RIO Lua. Проблема `1428 <https://github.com/tarantool/tarantool/issues/1428>`_"

#: ../doc/1.7/whats_new.rst:752
msgid "Search for ``.dylib`` as well as for ``.so`` libraries in OS X. Issue `810 <https://github.com/tarantool/tarantool/issues/810>`_."
msgstr "Поиск по библиотекам ``.dylib``, а также ``.so`` в OS X. Проблема `810 <https://github.com/tarantool/tarantool/issues/810>`_."

#: ../doc/1.7/whats_new.rst:754
msgid "A new ``box.cfg { read_only = true }`` option to emulate master-slave behavior. Issue `246 <https://github.com/tarantool/tarantool/issues/246>`_"
msgstr "Новая опция ``box.cfg { read_only = true }`` для моделирования поведения главный-ведомый. Проблема `246 <https://github.com/tarantool/tarantool/issues/246>`_"

#: ../doc/1.7/whats_new.rst:756
msgid "``if_not_exists = true`` option added to box.schema.user.grant. Issue `1683 <https://github.com/tarantool/tarantool/issues/1683>`_"
msgstr "Опция ``if_not_exists = true`` добавлена в box.schema.user.grant. Проблема `1683 <https://github.com/tarantool/tarantool/issues/1683>`_"

#: ../doc/1.7/whats_new.rst:758
msgid "``clock_realtime()``/``monotonic()`` functions added to the public C API. Issue `1455 <https://github.com/tarantool/tarantool/issues/1455>`_"
msgstr "Функции ``clock_realtime()``/``monotonic()`` добавлены в общедоступный API для языка C. Проблема `1455 <https://github.com/tarantool/tarantool/issues/1455>`_"

#: ../doc/1.7/whats_new.rst:760
msgid "``space:count(key, opts)`` introduced as an alias for ``space.index.primary:count(key, opts)``. Issue `1391 <https://github.com/tarantool/tarantool/issues/13918>`_"
msgstr "Появляется ``space:count(key, opts)`` в качестве псевдонима для ``space.index.primary:count(key, opts)``. Проблема `1391 <https://github.com/tarantool/tarantool/issues/13918>`_"

#: ../doc/1.7/whats_new.rst:763
msgid "Upgrade script for 1.6.4 -> 1.6.8 -> 1.6.9. Issue `1281 <https://github.com/tarantool/tarantool/issues/1281>`_"
msgstr "Обновление скрипта для 1.6.4 -> 1.6.8 -> 1.6.9. Проблема `1281 <https://github.com/tarantool/tarantool/issues/1281>`_"

#: ../doc/1.7/whats_new.rst:765
msgid "Support for OpenSSL 1.1. Issue `1722 <https://github.com/tarantool/tarantool/issues/1722>`_"
msgstr "Поддержка OpenSSL 1.1. Проблема `1722 <https://github.com/tarantool/tarantool/issues/1722>`_"

#: ../doc/1.7/whats_new.rst:772
msgid "`gis <https://github.com/tarantool/gis>`_ - full-featured geospatial extension for Tarantool."
msgstr "`gis <https://github.com/tarantool/gis>`_ — полнофункциональное геопространственное расширение для Tarantool'а."

#: ../doc/1.7/whats_new.rst:773
msgid "`mqtt <https://github.com/tarantool/mqtt>`_ - MQTT protocol client for Tarantool"
msgstr "`mqtt <https://github.com/tarantool/mqtt>`_ — клиент MQTT-протокола для Tarantool'а"

#: ../doc/1.7/whats_new.rst:778
msgid "**Release 1.6.8**"
msgstr "**Версия 1.6.8**"

#: ../doc/1.7/whats_new.rst:780
msgid "Release type: maintenance. Release date: 2016-02-25. Release tag: 1.6.8-525-ga571ac0."
msgstr "Тип версии: обновленная. Дата выхода: 2016-02-25. Тег версии: 1.6.8-525-ga571ac0."

#: ../doc/1.7/whats_new.rst:784
msgid "RPM packages for CentOS 7 / RHEL 7 and Fedora 22+ now use native systemd configuration without legacy sysvinit shell scripts. Systemd provides its own facilities for multi-instance management. To upgrade, perform the following steps:"
msgstr "RPM-пакеты для CentOS 7 / RHEL 7 Fedora 22+ будут использовать встроенную конфигурацию systemd без устаревших скриптов sysvinit. В systemd появляется возможность управления несколькими экземплярами. Чтобы обновить, выполните следующие действия:"

#: ../doc/1.7/whats_new.rst:789
msgid "Ensure that ``INSTANCENAME.lua`` file is present in ``/etc/tarantool/instace.available``."
msgstr "Убедитесь в наличии файла ``ИМЯ_ЭКЗЕМПЛЯРА.lua`` в директории ``/etc/tarantool/instace.available``."

#: ../doc/1.7/whats_new.rst:794
msgid "``/etc/tarantool/instance.enabled`` directory is now deprecated for systemd-enabled platforms."
msgstr "Директория ``/etc/tarantool/instance.enabled`` больше не используется для платформ, запускаемых по systemd."

#: ../doc/1.7/whats_new.rst:796
msgid "See :ref:`the administration chapter <admin>` for additional information."
msgstr "Для получения дополнительной информации см. главу :ref:`по администрированию серверной части `."

#: ../doc/1.7/whats_new.rst:798
msgid "Sophia was upgraded to v2.1 to fix upsert, memory corruption and other bugs. Sophia v2.1 doesn't support old v1.1 data format. Please use Tarantool replication to upgrade. Issue `1222 <https://github.com/tarantool/tarantool/issues/1222>`_"
msgstr "Движок Sophia был обновлен до версии 2.1 для исправления ошибок upsert, нарушения целостности данных в памяти и других ошибок. Sophia версии 2.1 не поддерживает старый формат данных версии 1.1. Используйте репликацию в Tarantool'е для обновления. Проблема `1222 <https://github.com/tarantool/tarantool/issues/1222>`_"

#: ../doc/1.7/whats_new.rst:802
msgid "Ubuntu Vivid, Fedora 20, Fedora 21 were deprecated due to EOL."
msgstr "Ubuntu Vivid, Fedora 20, Fedora 21 объявлены устаревшими по причине прекращения поддержки."

#: ../doc/1.7/whats_new.rst:803
msgid "i686 packages were deprecated. Please use our RPM and DEB specs to build these on your own infrastructure."
msgstr "i686-пакеты объявлены устаревшими. Используйте наши спецификации по RPM и DEB для сборки на своей инфраструктуре."

#: ../doc/1.7/whats_new.rst:805
msgid "Please update your ``yum.repos.d`` and/or apt ``sources.list.d`` according to instructions at http://tarantool.org/download.html"
msgstr "Обновите ``yum.repos.d`` и/или apt ``sources.list.d`` в соответствии с инструкциями по ссылке http://tarantool.org/download.html"

#: ../doc/1.7/whats_new.rst:810
msgid "Tarantool 1.6.8 fully supports ARMv7 and ARMv8 (aarch64) processors. Now it is possible to use Tarantool on a wide range of consumer devices, starting from popular Raspberry PI 2 to coin-size embedded boards and no-name mini-micro-nano-PCs. Issue `1153 <https://github.com/tarantool/tarantool/issues/1153>`_. (Also qemu works well, but we don't have real hardware to check.)"
msgstr "Tarantool в версии 1.6.8 полностью поддерживает процессоры ARMv7 и ARMv8 (aarch64). Теперь можно будет использовать Tarantool на самых разных пользовательских устройствах от популярного Raspberry PI 2 и до плат размером с монету и безымянных мини-микро-нано-компьютеров. Проблема `1153 <https://github.com/tarantool/tarantool/issues/1153>`_. (На qemu также работает хорошо, но у нас нет оборудования, чтобы проверить.)"

#: ../doc/1.7/whats_new.rst:816
msgid "Tuple comparator functions were optimized, providing up to 30% performance boost when an index key consists of 2, 3 or more parts. Issue `969 <https://github.com/tarantool/tarantool/issues/969>`_."
msgstr "Функции компаратора кортежей были оптимизированы, чтобы обеспечить повышение производительности на 30%, когда индексный ключ состоит из 2, 3 и более частей. Проблема `969 <https://github.com/tarantool/tarantool/issues/969>`_."

#: ../doc/1.7/whats_new.rst:819
msgid "Tuple allocator changes give another 15% performance improvement. Issue `1298 <https://github.com/tarantool/tarantool/issues/1298>`_"
msgstr "Изменения распределителя кортежей дают улучшение производительности еще на 15%. Проблема `1298 <https://github.com/tarantool/tarantool/issues/1298>`_"

#: ../doc/1.7/whats_new.rst:821
msgid "Replication relay performance was improved by reducing the amount of data directory re-scans. Issue `11150 <https://github.com/tarantool/tarantool/issues/1150>`_"
msgstr "Производительность передачи данных репликации была улучшена путем уменьшения объема данных в повторном сканировании. Проблема `11150 <https://github.com/tarantool/tarantool/issues/1150>`_"

#: ../doc/1.7/whats_new.rst:824
msgid "A random delay was introduced into snapshot daemon, reducing the chance that multiple instances take a snapshot at the same time. Issue `732 <https://github.com/tarantool/tarantool/issues/732>`_."
msgstr "В демоне создания снимков появилась произвольная задержка, что снижает возможность того, что несколько экземпляров будут делать снимки одновременно. Проблема `732 <https://github.com/tarantool/tarantool/issues/732>`_."

#: ../doc/1.7/whats_new.rst:827
msgid "Sophia storage engine was upgraded to v2.1:"
msgstr "Движок базы данных Sophia был обновлен до версии 2.1:"

#: ../doc/1.7/whats_new.rst:829
msgid "serializable Snapshot Isolation (SSI),"
msgstr "изоляция сериализуемых снимков (SSI — Serializable Snapshot Isolation),"

#: ../doc/1.7/whats_new.rst:830
msgid "RAM storage mode,"
msgstr "режим хранения в оперативной памяти,"

#: ../doc/1.7/whats_new.rst:831
msgid "anti-cache storage mode,"
msgstr "режим хранения без кэша,"

#: ../doc/1.7/whats_new.rst:832
msgid "persistent caching storage mode,"
msgstr "режим хранения в кэше с подключением к базе данных,"

#: ../doc/1.7/whats_new.rst:833
msgid "implemented AMQ Filter,"
msgstr "внедренный AMQ-фильтр,"

#: ../doc/1.7/whats_new.rst:834
msgid "LRU mode,"
msgstr "режим LRU (удаление страниц, которые дольше всего не использовались),"

#: ../doc/1.7/whats_new.rst:835
msgid "separate compression for hot and cold data,"
msgstr "отдельная компрессия горячих и холодных данных,"

#: ../doc/1.7/whats_new.rst:836
msgid "snapshot implementation for Faster Recovery,"
msgstr "внедрение снимков для быстрого восстановления,"

#: ../doc/1.7/whats_new.rst:837
msgid "upsert reorganizations and fixes,"
msgstr "реорганизация и исправление ошибок в upsert,"

#: ../doc/1.7/whats_new.rst:838
msgid "new performance metrics."
msgstr "новые метрики производительности."

#: ../doc/1.7/whats_new.rst:840
msgid "Please note \"Incompatible changes\" above."
msgstr "Обратите внимание на \"Несовместимые изменения\" выше."

#: ../doc/1.7/whats_new.rst:842
msgid "Allow to remove servers with non-zero LSN from ``_cluster`` space. Issue `1219 <https://github.com/tarantool/tarantool/issues/1219>`_."
msgstr "Возможно удаление серверов с ненулевым LSN из спейса ``_cluster``. Проблема `1219 <https://github.com/tarantool/tarantool/issues/1219>`_."

#: ../doc/1.7/whats_new.rst:844
msgid "``net.box`` now automatically reloads space and index definitions. Issue `1183 <https://github.com/tarantool/tarantool/issues/1183>`_."
msgstr "``net.box`` теперь автоматически перезагружает схемы спейса и индексов. Проблема `1183 <https://github.com/tarantool/tarantool/issues/1183>`_."

#: ../doc/1.7/whats_new.rst:846
msgid "The maximal number of indexes in space was increased to 128. Issue `1311 <https://github.com/tarantool/tarantool/issues/1311>`_."
msgstr "Максимальное количество индексов в спейсе было увеличено до 128. Проблема `1311 <https://github.com/tarantool/tarantool/issues/1311>`_."

#: ../doc/1.7/whats_new.rst:848
msgid "New native ``systemd`` configuration with support of instance management and daemon supervision (CentOS 7 and Fedora 22+ only). Please note \"Incompatible changes\" above. Issue `1264 <https://github.com/tarantool/tarantool/issues/1264>`_."
msgstr "Новая встроенная конфигурацию ``systemd`` с поддержкой управления экземплярами и контролем демонов (только CentOS 7 и Fedora 22+). См. \"Несовместимые изменения\" выше. Проблема `1264 <https://github.com/tarantool/tarantool/issues/1264>`_."

#: ../doc/1.7/whats_new.rst:852
msgid "Tarantool package was accepted to the official Fedora repositories (https://apps.fedoraproject.org/packages/tarantool)."
msgstr "Пакет Tarantool'а принят в официальный репозиторий Fedora (https://apps.fedoraproject.org/packages/tarantool)."

#: ../doc/1.7/whats_new.rst:854
msgid "Tarantool brew formula (OS X) was accepted to the official Homebrew repository (http://brewformulas.org/tarantool)."
msgstr "Пакет Tarantool'а (OS X) принят в официальный репозиторий Homebrew (http://brewformulas.org/tarantool)."

#: ../doc/1.7/whats_new.rst:856
msgid "Clang compiler support was added on FreeBSD. Issue `786 <https://github.com/tarantool/tarantool/issues/786>`_."
msgstr "Поддержка компилятора Clang добавлена в FreeBSD. Проблема `786 <https://github.com/tarantool/tarantool/issues/786>`_."

#: ../doc/1.7/whats_new.rst:858
msgid "Support for musl libc, used by Alpine Linux and Docker images, was added. Issue `1249 <https://github.com/tarantool/tarantool/issues/1249>`_."
msgstr "Добавлена поддержка библиотеки musl libc, используемой образами Alpine Linux и Docker. Проблема `1249 <https://github.com/tarantool/tarantool/issues/1249>`_."

#: ../doc/1.7/whats_new.rst:860
msgid "Added support for GCC 6.0."
msgstr "Добавлена поддержка GCC 6.0."

#: ../doc/1.7/whats_new.rst:861
msgid "Ubuntu Wily, Xenial and Fedora 22, 23 and 24 are now supported distributions for which we build official packages."
msgstr "Получили поддержку Ubuntu Wily, Xenial и Fedora 22, 23 и 24, для которых мы создаем официальные пакеты."

#: ../doc/1.7/whats_new.rst:863
msgid "box.info.cluster.uuid can be used to retrieve cluster UUID. Issue `1117 <https://github.com/tarantool/tarantool/issues/1117>`_."
msgstr "box.info.cluster.uuid можно использовать для получения UUID кластера. Проблема `1117 <https://github.com/tarantool/tarantool/issues/1117>`_."

#: ../doc/1.7/whats_new.rst:865
msgid "Numerous improvements in the documentation, added documentation for ``syslog``, ``clock``, ``fiber.storage`` packages, updated the built-in tutorial."
msgstr "Многочисленные исправления в документации, добавлена документация по пакетам ``syslog``, ``clock``, ``fiber.storage``, встроенное практическое задание получило обновление."

#: ../doc/1.7/whats_new.rst:871
msgid "Tarantool switched to a new Docker-based cloud build infrastructure The new buildbot significantly decreases commit-to-package time. The official repositories at http://tarantool.org now contain the latest version of the server, rocks and connectors. See http://github.com/tarantool/build"
msgstr "Tarantool перешел на новую облачную инфраструктуру на основе Docker. Новый инструмент интеграции разработки buildbot значительно уменьшает время передачи коммитов в пакеты. Официальные репозитории по ссылке http://tarantool.org теперь содержат последнюю версию сервера, модулей и коннекторов. См. http://github.com/tarantool/build"

#: ../doc/1.7/whats_new.rst:876
msgid "The repositories at http://tarantool.org/download.html were moved to http://packagecloud.io cloud hosting (backed by Amazon AWS). Thanks to packagecloud.io for their support of open source!"
msgstr "Репозитории по ссылке http://tarantool.org/download.html were был перенесены в облачное хранилище http://packagecloud.io (при поддержке Amazon AWS). Благодарим packagecloud.io за поддержку свободного ПО!"

#: ../doc/1.7/whats_new.rst:879
msgid "``memcached`` - memcached text and binary protocol implementation for Tarantool. Turns Tarantool into a persistent memcached with master-master replication. See https://github.com/tarantool/memcached"
msgstr "``memcached`` — внедрение текстового и бинарного протокола memcached для Tarantool'а. Превращает Tarantool в memcached с доступом к базе данных с репликацией по схеме мастер-мастер. См. https://github.com/tarantool/memcached"

#: ../doc/1.7/whats_new.rst:882
msgid "``migrate`` - a Tarantool rock for migration from Tarantool 1.5 to 1.6. See https://github.com/bigbes/migrate"
msgstr "``migrate`` — модуль Tarantool'а для миграции с версии 1.5 на версию 1.6. См. https://github.com/bigbes/migrate"

#: ../doc/1.7/whats_new.rst:884
msgid "``cqueues`` - a Lua asynchronous networking, threading, and notification framework (contributed by @daurnimator). PR `1204 <https://github.com/tarantool/tarantool/pull/1204>`_."
msgstr "``cqueues`` — асинхронный Lua-каркас для работы по сети с потоками и уведомлениями (разработал @daurnimator). Проблема `1204 <https://github.com/tarantool/tarantool/pull/1204>`_."

#: ../doc/1.7/whats_new.rst:890
msgid "**Release 1.6.7**"
msgstr "**Версия 1.6.7**"

#: ../doc/1.7/whats_new.rst:892
msgid "Release type: maintenance. Release date: 2015-11-17."
msgstr "Тип версии: обновленная. Дата выхода: 2015-11-17."

#: ../doc/1.7/whats_new.rst:896
msgid "The syntax of ``upsert`` command has been changed and an extra ``key`` argument was removed from it. The primary key for look up is now always taken from the tuple, which is the second argument of upsert. ``upsert()`` was added fairly late at a release cycle and the design had an obvious bug which we had to fix. Sorry for this."
msgstr "Изменился синтаксис команды ``upsert``, и из нее был удален дополнительный аргумент ``key``. Первичный ключ для поиска всегда берется из кортежа, который является вторым аргументом в upsert. ``upsert()`` добавили довольно поздно в рабочем цикле, и в проекте была очевидная ошибка, которую нам пришлось исправлять. Извините."

#: ../doc/1.7/whats_new.rst:902
msgid "``fiber.channel.broadcast()`` was removed since it wasn't used by anyone and didn't work properly."
msgstr "Функцию ``fiber.channel.broadcast()`` удалили, потому что ее никто не использовал, и она работала некорректно."

#: ../doc/1.7/whats_new.rst:904
msgid "tarantoolctl ``reload`` command renamed to ``eval``."
msgstr "Команда ``reload`` утилиты tarantoolctl переименована в``eval``."

#: ../doc/1.7/whats_new.rst:908
msgid "``logger`` option now accepts a syntax for syslog output. Use uri-style syntax for file, pipe or syslog log destination."
msgstr "Опция ``logger`` допускает синтаксис для вывода syslog. Используйте синтаксис URI для места назначения журнала файла, конвейера или syslog."

#: ../doc/1.7/whats_new.rst:910
msgid "``replication_source`` now accepts an array of URIs, so each replica can have up to 30 peers."
msgstr "``replication_source`` принимает массив URI, так что в каждой реплике может быть до 30 узлов."

#: ../doc/1.7/whats_new.rst:912
msgid "RTREE index now accept two types of ``distance`` functions: ``euclid`` and ``manhattan``."
msgstr "RTREE-индекс принимает два типа функций ``distance``: ``euclid`` и ``manhattan``."

#: ../doc/1.7/whats_new.rst:914
msgid "``fio.abspath()`` - a new function in ``fio`` rock to convert a relative path to absolute."
msgstr "``fio.abspath()`` — новая функция в модуле ``fio`` для ковертации относительного пути в абсолютный."

#: ../doc/1.7/whats_new.rst:916
msgid "The process title now can be set with an on-board ``title`` rock."
msgstr "Название процесса теперь можно определить с помощью встроенного модуля ``title``."

#: ../doc/1.7/whats_new.rst:917
msgid "This release uses LuaJIT 2.1."
msgstr "В данной версии используется LuaJIT 2.1."

#: ../doc/1.7/whats_new.rst:921
msgid "``memcached`` - makes Tarantool understand Memcached binary protocol. Text protocol support is in progress and will be added to the rock itself, without changes to the server core."
msgstr "``memcached`` помогает Tarantool'у понимать бинарный протокол Memcached. Поддержка текстового протокола находится в процессе разработки и будет добавлена в отдельный модуль без изменений основных компонентов."

#: ../doc/1.7/whats_new.rst:927
msgid "**Release 1.6.6**"
msgstr "**Версия 1.6.6**"

#: ../doc/1.7/whats_new.rst:929
msgid "Release type: maintenance. Release date: 2015-08-28."
msgstr "Тип версии: обновленная. Дата выхода: 2015-08-28."

#: ../doc/1.7/whats_new.rst:932
msgid "Tarantool 1.6 is no longer getting major new features, although it will be maintained. The developers are concentrating on Tarantool version 1.9."
msgstr "Tarantool версии 1.6 больше не получает значимых новых функций, но продолжает поддерживаться. Разработчики сосредоточили свои усилия на версии 1.9."

#: ../doc/1.7/whats_new.rst:938
msgid "A new schema of ``_index`` system space which accommodates multi-dimensional RTREE indexes. Tarantool 1.6.6 works fine with an old snapshot and system spaces, but you will not be able to start Tarantool 1.6.5 with a data directory created by Tarantool 1.6.6, neither will you be able to query Tarantool 1.6.6 schema with 1.6.5 net.box."
msgstr "Появляется новая схема системного спейса ``_index`` для размещения многомерных RTREE-индексов. Tarantool 1.6.6 нормально работает со старыми снимками и системными спейсами, но нельзя будет запустить Tarantool версии 1.6.5 с директорий, созданной в Tarantool'е версии 1.6.6, как нельзя будет ввести запрос в Tarantool 1.6.6 с net.box версии 1.6.5."

#: ../doc/1.7/whats_new.rst:944
msgid "``box.info.snapshot_pid`` is renamed to ``box.info.snapshot_in_progress``"
msgstr "Переименование ``box.info.snapshot_pid`` в ``box.info.snapshot_in_progress``"

#: ../doc/1.7/whats_new.rst:948
msgid "Threaded architecture for network. Network I/O has finally been moved to a separate thread, increasing single instance performance by up to 50%."
msgstr "Потоковая архитектура для работы по сети. Сетевой ввод-вывод окончательно переведен на отдельный поток, что увеличит производительность отдельного экземпляра до 50%."

#: ../doc/1.7/whats_new.rst:951
msgid "Threaded architecture for checkpointing. Tarantool no longer forks to create a snapshot, but uses a separate thread, accessing data via a consistent read view. This eliminates all known latency spikes caused by snapshotting."
msgstr "Потоковая архитектура для создания контрольных точек. Tarantool больше не делает ответвлений для создания снимка, а использует отдельный поток, получая доступ к данным с помощью вида постоянного просмотра. Это помогает устранить скачки задержки времени во время создания снимков."

#: ../doc/1.7/whats_new.rst:956
msgid "Stored procedures in C/C++. Stored procedures in C/C++ provide speed (3-4 times, compared to a Lua version in our measurements), as well as unlimited extensibility power. Since C/C++ procedures run in the same memory space as the database, they are also an easy tool to corrupt database memory. See :ref:`The C API description <index-c_api_reference>`."
msgstr "Хранимые процедуры на языках C/C++. Хранимые процедуры на языках C/C++ дают скорость (в 3-4 раза больше по сравнению с Lua-версией по нашим подсчетам), а также возможность неограниченного расширения. Поскольку процедуры C/C++ выполняются там же, где располагается база данных, они могут с легкостью повредить базу данных. См. :ref:`API для языка C <index-c_api_reference>`."

#: ../doc/1.7/whats_new.rst:963
msgid "Multidimensional RTREE index. RTREE index type now support a large (up to 32) number of dimensions. RTREE data structure has been optimized to actually use `R\\*-TREE <https://en.wikipedia.org/wiki/R*_tree>`_. We're working on further improvements of the index, in particular, configurable distance function. See https://github.com/tarantool/tarantool/wiki/R-tree-index-quick-start-and-usage"
msgstr "Многомерный RTREE-индекс. RTREE-индекс теперь поддерживает большое количество измерений (до 32). Cтруктура данных RTREE была оптимизирована так, чтобы действительно использовать `R\\*-TREE <https://en.wikipedia.org/wiki/R*_tree>`_. Мы работаем над дальнейшим улучшением индекса, в частности, над функцией конфигурации расстояния. См. https://github.com/tarantool/tarantool/wiki/R-tree-index-quick-start-and-usage"

#: ../doc/1.7/whats_new.rst:970
msgid "Sophia 2.1.1, with support of compression and multipart primary keys. See https://groups.google.com/forum/#!topic/sophia-database/GfcbEC7ksRg"
msgstr "Sophia 2.1.1 с поддержкой компрессии и составных первичных ключей. См. https://groups.google.com/forum/#!topic/sophia-database/GfcbEC7ksRg"

#: ../doc/1.7/whats_new.rst:973
msgid "New ``upsert`` command available in the binary protocol and in stored functions. The key advantage of upsert is that it's much faster with write-optimized storage (sophia storage engine), but some caveats exists as well. See Issue `905 <https://github.com/tarantool/tarantool/issues/905>`_ for details. Even though upsert performance advantage is most prominent with sophia engine, it works with all storage engines."
msgstr "В бинарном протоколе и в хранимых функциях доступна новая команда ``upsert``. Ключевое преимущество команды upsert в том, что она работает намного быстрее с хранилищами, оптимизированными для чтения (движок базы данных sophia), однако есть также некоторые оговорки. Для получения дополнительной информации см. проблему `905 <https://github.com/tarantool/tarantool/issues/905>`_. И хотя преимущество производительности upsert наиболее очевидно с движком sophia, команда работает со всеми движками базы данных."

#: ../doc/1.7/whats_new.rst:980
msgid "Better memory diagnostics information for fibers, tuple and index arena Try a new command ``box.slab.stats()``, for detailed information about tuple/index slabs, ``fiber.info()`` now displays information about memory used by the fiber."
msgstr "Более точная информация диагностики памяти для файберов, кортежей и индексов. Используйте новую команду ``box.slab.stats()`` для получения подробной информация о кортежах/индексах, команда ``fiber.info()`` отобразит информацию о памяти, занятой файбером."

#: ../doc/1.7/whats_new.rst:984
msgid "Update and delete now work using a secondary index, if the index is unique."
msgstr "Операции update и delete работают с использованием вторичного индекса, если индекс уникальный."

#: ../doc/1.7/whats_new.rst:986
msgid "Authentication triggers. Set ``box.session.on_auth`` triggers to catch authentication events. Trigger API is improved to display all defined triggers, easily remove old triggers."
msgstr "Триггеры для аутентификации. Установите триггеры ``box.session.on_auth`` для отслеживания событий аутентификации. API для триггеров улучшили, чтобы он отображал все заданные триггеры, старые триггеры легко удалить."

#: ../doc/1.7/whats_new.rst:989
msgid "Manifold performance improvements of ``net.box`` built-in package."
msgstr "Разнообразные улучшения производительности встроенного модуля ``net.box``."

#: ../doc/1.7/whats_new.rst:990
msgid "Performance optimizations of BITSET index."
msgstr "Оптимизация производительности BITSET-индекса."

#: ../doc/1.7/whats_new.rst:991
msgid "``panic_on_wal_error`` is a dynamic configuration option now."
msgstr "``panic_on_wal_error`` представляет собой динамический параметр конфигурации."

#: ../doc/1.7/whats_new.rst:992
msgid "iproto ``sync`` field is available in Lua as ``session.sync()``."
msgstr "Поле iproto ``sync`` доступно в Lua как ``session.sync()``."

#: ../doc/1.7/whats_new.rst:993
msgid "``box.once()`` - a new method to invoke code once in an instance and replica set lifetime. Use ``once()`` to set up spaces and uses, as well as do schema upgrade in production."
msgstr "``box.once()`` - a new method to invoke code once in an instance and replica set lifetime. Use ``once()`` to set up spaces and uses, as well as do schema upgrade in production."

#: ../doc/1.7/whats_new.rst:997
msgid "``box.error.last()`` to return the last error in a session."
msgstr "``box.error.last()`` возвращает последнюю ошибку в сессии."

#: ../doc/1.7/whats_new.rst:1001
msgid "``jit.*``, ``jit.dump``, ``jit.util``, ``jit.vmdef`` modules of LuaJIT 2.0 are now available as built-ins. See http://luajit.org/ext_jit.html"
msgstr "Следующие модули LuaJIT 2.0 теперь являются встроенными: ``jit.*``, ``jit.dump``, ``jit.util``, ``jit.vmdef``. См. http://luajit.org/ext_jit.html"

#: ../doc/1.7/whats_new.rst:1004
msgid "``strict`` built-in package, banning use of undeclared variables in Lua. Strict mode is on when Tarantool is compiled with debug. Turn on/off with ``require('strict').on()``/``require('strict').off()``."
msgstr "``strict`` — встроеный пакет, который запрещает использование необъявленных переменных в Lua. Работа ведется в таком режиме, когда Tarantool компилируется с отладкой. Чтобы включить/отключить этот режим, используйте ``require('strict').on()``/``require('strict').off()`` соответственно."

#: ../doc/1.7/whats_new.rst:1007
msgid "``pg`` and ``mysql`` rocks, available at http://rocks.tarantool.org - working with MySQL and PostgreSQL from Tarantool."
msgstr "``pg`` и ``mysql`` — модули, доступные по ссылке http://rocks.tarantool.org — работают с MySQL и PostgreSQL из Tarantool'а."

#: ../doc/1.7/whats_new.rst:1009
msgid "``gperftools`` rock, availble at http://rocks.tarantool.org - getting perfromance data using Google's gperf from Tarantool."
msgstr "``gperftools`` — модуль, доступный по ссылке http://rocks.tarantool.org — получает данные о производительности с помощью Google gperf из Tarantool'а."

#: ../doc/1.7/whats_new.rst:1011
msgid "``csv`` built-in rock, to parse and load CSV (comma-separated values) data."
msgstr "``csv`` — встроенный модуль для разбора и загрузки данных в формате CSV (значения, разделенные запятыми)."

#: ../doc/1.7/whats_new.rst:1014
msgid "New supported platforms:"
msgstr "Поддержка новой платформы:"

#: ../doc/1.7/whats_new.rst:1016
msgid "Fedora 22, Ubuntu Vivid"
msgstr "Fedora 22, Ubuntu Vivid"
